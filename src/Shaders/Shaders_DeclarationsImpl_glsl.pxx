// This file has been automatically generated from resource file src/Shaders/DeclarationsImpl.glsl

static const char Shaders_DeclarationsImpl_glsl[] =
  "\n"
  "//! @file DeclarationsImpl.glsl includes implementation of common functions and properties accessors\n"
  "#if defined(FRAGMENT_SHADER)\n"
  "\n"
  "#if defined(OCC_DEPTH_PEEL_OIT)\n"
  "uniform sampler2D occDepthPeelingDepth;\n"
  "uniform sampler2D occDepthPeelingFrontColor;\n"
  "int IsFrontPeelLayer = -1;\n"
  "bool occFragEarlyReturn()\n"
  "{\n"
  "  #define THE_DEPTH_CLEAR_VALUE -1e15f\n"
  "  ivec2  aFragCoord = ivec2 (gl_FragCoord.xy);\n"
  "  vec2   aLastDepth = texelFetch (occDepthPeelingDepth, aFragCoord, 0).rg;\n"
  "  occPeelFrontColor = texelFetch (occDepthPeelingFrontColor, aFragCoord, 0);\n"
  "  occPeelDepth.rg   = vec2 (THE_DEPTH_CLEAR_VALUE); // depth value always increases, so that MAX blend equation can be used\n"
  "  occPeelBackColor  = vec4 (0.0); // back color is blend after each peeling pass\n"
  "\n"
  "  float aNearDepth = -aLastDepth.x;\n"
  "  float aFarDepth  =  aLastDepth.y;\n"
  "  float aFragDepth = gl_FragCoord.z; // 0 - 1\n"
  "  if (aFragDepth < aNearDepth || aFragDepth > aFarDepth)\n"
  "  {\n"
  "    return true; // skip peeled depth\n"
  "  }\n"
  "  else if (aFragDepth > aNearDepth && aFragDepth < aFarDepth)\n"
  "  {\n"
  "    // to be rendered at next peeling pass\n"
  "    occPeelDepth.rg = vec2 (-aFragDepth, aFragDepth);\n"
  "    return true;\n"
  "  }\n"
  "\n"
  "  IsFrontPeelLayer = (gl_FragCoord.z == aNearDepth) ? 1 : 0;\n"
  "  return false;\n"
  "}\n"
  "#else\n"
  "bool occFragEarlyReturn() { return false; }\n"
  "#endif\n"
  "\n"
  "void occSetFragColor (in vec4 theColor)\n"
  "{\n"
  "#if defined(OCC_ALPHA_TEST)\n"
  "  if (theColor.a < occAlphaCutoff) discard;\n"
  "#endif\n"
  "#if defined(OCC_WRITE_WEIGHT_OIT_COVERAGE)\n"
  "  float aWeight     = theColor.a * clamp (1e+2 * pow (1.0 - gl_FragCoord.z * occOitDepthFactor, 3.0), 1e-2, 1e+2);\n"
  "  occFragCoverage.r = theColor.a * aWeight;\n"
  "  occFragColor      = vec4 (theColor.rgb * theColor.a * aWeight, theColor.a);\n"
  "#elif defined(OCC_DEPTH_PEEL_OIT)\n"
  "  if (IsFrontPeelLayer == 1) // front is blended directly\n"
  "  {\n"
  "    vec4 aLastColor = occPeelFrontColor;\n"
  "    float anAlphaMult = 1.0 - aLastColor.a;\n"
  "    occPeelFrontColor.rgb = aLastColor.rgb + theColor.rgb * theColor.a * anAlphaMult;\n"
  "    occPeelFrontColor.a = 1.0 - anAlphaMult * (1.0 - theColor.a);\n"
  "  }\n"
  "  else if (IsFrontPeelLayer == 0) // back is blended afterwards\n"
  "  {\n"
  "    occPeelBackColor = theColor;\n"
  "  }\n"
  "#else\n"
  "  occFragColor = theColor;\n"
  "#endif\n"
  "}\n"
  "#endif\n"
  "\n"
  "#if defined(THE_MAX_LIGHTS) && (THE_MAX_LIGHTS > 0)\n"
  "// arrays of light sources\n"
  "uniform               vec4 occLightSources[THE_MAX_LIGHTS * 4]; //!< packed light sources parameters\n"
  "uniform THE_PREC_ENUM int occLightSourcesTypes[THE_MAX_LIGHTS]; //!< packed light sources types\n"
  "#endif\n"
  "\n"
  "#if defined(THE_IS_PBR)\n"
  "vec3 occDiffIBLMap (in vec3 theNormal)\n"
  "{\n"
  "  vec3 aSHCoeffs[9];\n"
  "  for (int i = 0; i < 9; ++i)\n"
  "  {\n"
  "    aSHCoeffs[i] = occTexture2D (occDiffIBLMapSHCoeffs, vec2 ((float(i) + 0.5) / 9.0, 0.0)).rgb;\n"
  "  }\n"
  "  return aSHCoeffs[0]\n"
  "\n"
  "       + aSHCoeffs[1] * theNormal.x\n"
  "	   + aSHCoeffs[2] * theNormal.y\n"
  "	   + aSHCoeffs[3] * theNormal.z\n"
  "\n"
  "	   + aSHCoeffs[4] * theNormal.x * theNormal.z\n"
  "	   + aSHCoeffs[5] * theNormal.y * theNormal.z\n"
  "	   + aSHCoeffs[6] * theNormal.x * theNormal.y\n"
  "\n"
  "	   + aSHCoeffs[7] * (3.0 * theNormal.z * theNormal.z - 1.0)\n"
  "	   + aSHCoeffs[8] * (theNormal.x * theNormal.x - theNormal.y * theNormal.y);\n"
  "}\n"
  "#endif\n"
  "\n"
  "// front and back material properties accessors\n"
  "#if defined(THE_IS_PBR)\n"
  "uniform vec4 occPbrMaterial[3 * 2];\n"
  "\n"
  "#define MIN_ROUGHNESS 0.01\n"
  "float occRoughness (in float theNormalizedRoughness) { return theNormalizedRoughness * (1.0 - MIN_ROUGHNESS) + MIN_ROUGHNESS; }\n"
  "vec4  occPBRMaterial_Color(in bool theIsFront)     { return theIsFront ? occPbrMaterial[0]     : occPbrMaterial[3]; }\n"
  "vec3  occPBRMaterial_Emission(in bool theIsFront)  { return theIsFront ? occPbrMaterial[1].rgb : occPbrMaterial[4].rgb; }\n"
  "float occPBRMaterial_IOR(in bool theIsFront)       { return theIsFront ? occPbrMaterial[1].w   : occPbrMaterial[4].w; }\n"
  "float occPBRMaterial_Metallic(in bool theIsFront)  { return theIsFront ? occPbrMaterial[2].b   : occPbrMaterial[5].b; }\n"
  "float occPBRMaterial_NormalizedRoughness(in bool theIsFront) { return theIsFront ? occPbrMaterial[2].g : occPbrMaterial[5].g; }\n"
  "#else\n"
  "uniform vec4 occCommonMaterial[4 * 2];\n"
  "\n"
  "vec4  occMaterial_Diffuse(in bool theIsFront)   { return theIsFront ? occCommonMaterial[0]     : occCommonMaterial[4]; }\n"
  "vec3  occMaterial_Emission(in bool theIsFront)  { return theIsFront ? occCommonMaterial[1].rgb : occCommonMaterial[5].rgb; }\n"
  "vec3  occMaterial_Specular(in bool theIsFront)  { return theIsFront ? occCommonMaterial[2].rgb : occCommonMaterial[6].rgb; }\n"
  "float occMaterial_Shininess(in bool theIsFront) { return theIsFront ? occCommonMaterial[2].a   : occCommonMaterial[6].a; }\n"
  "vec3  occMaterial_Ambient(in bool theIsFront)   { return theIsFront ? occCommonMaterial[3].rgb : occCommonMaterial[7].rgb; }\n"
  "#endif\n"
  "\n"
  "// 2D texture coordinates transformation\n"
  "vec2  occTextureTrsf_Translation(void) { return occTexTrsf2d[0].xy; }\n"
  "vec2  occTextureTrsf_Scale(void)       { return occTexTrsf2d[0].zw; }\n"
  "float occTextureTrsf_RotationSin(void) { return occTexTrsf2d[1].x; }\n"
  "float occTextureTrsf_RotationCos(void) { return occTexTrsf2d[1].y; }\n"
  "//! @endfile DeclarationsImpl.glsl\n";
