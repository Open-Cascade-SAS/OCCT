// Copyright (c) 1997-1999 Matra Datavision
// Copyright (c) 1999-2014 OPEN CASCADE SAS
//
// This file is part of Open CASCADE Technology software library.
//
// This library is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License version 2.1 as published
// by the Free Software Foundation, with special exception defined in the file
// OCCT_LGPL_EXCEPTION.txt. Consult the file LICENSE_LGPL_21.txt included in OCCT
// distribution for complete text of the license and disclaimer of any warranty.
//
// Alternatively, this file may be used under the terms of Open CASCADE
// commercial license or contractual agreement.

#include <math_Gauss.hxx>
#include <math_NotSquare.hxx>
#include <math_SingularMatrix.hxx>
#include <math_Vector.hxx>
#include <Standard_DimensionError.hxx>
#include <Standard_DivideByZero.hxx>

#include <utility>

//==================================================================================================

inline Standard_OStream& operator<<(Standard_OStream& o, const math_Matrix& mat)
{
  mat.Dump(o);
  return o;
}

//==================================================================================================

inline math_Matrix operator*(const Standard_Real Left, const math_Matrix& Right)
{
  return Right.Multiplied(Left);
}

//==================================================================================================

inline const Standard_Real& math_Matrix::Value(const Standard_Integer Row,
                                               const Standard_Integer Col) const
{
  return Array.Value(Row, Col);
}

//==================================================================================================

inline Standard_Real& math_Matrix::Value(const Standard_Integer Row, const Standard_Integer Col)
{
  return Array.Value(Row, Col);
}

//==================================================================================================

inline Standard_Integer math_Matrix::RowNumber() const noexcept
{
  return Array.NbRows();
}

//==================================================================================================

inline Standard_Integer math_Matrix::ColNumber() const noexcept
{
  return Array.NbColumns();
}

//==================================================================================================

inline Standard_Integer math_Matrix::LowerRow() const noexcept
{
  return Array.LowerRow();
}

//==================================================================================================

inline Standard_Integer math_Matrix::UpperRow() const noexcept
{
  return Array.UpperRow();
}

//==================================================================================================

inline Standard_Integer math_Matrix::LowerCol() const noexcept
{
  return Array.LowerCol();
}

//==================================================================================================

inline Standard_Integer math_Matrix::UpperCol() const noexcept
{
  return Array.UpperCol();
}

//==================================================================================================

inline void math_Matrix::SetLower(const Standard_Integer LowerRow, const Standard_Integer LowerCol) noexcept
{
  SetLowerRow(LowerRow);
  SetLowerCol(LowerCol);
}

//==================================================================================================

inline math_Matrix::math_Matrix(const Standard_Integer LowerRow,
                                 const Standard_Integer UpperRow,
                                 const Standard_Integer LowerCol,
                                 const Standard_Integer UpperCol)
    : Array(LowerRow, UpperRow, LowerCol, UpperCol)
{
}

//==================================================================================================

inline math_Matrix::math_Matrix(const Standard_Integer LowerRow,
                                 const Standard_Integer UpperRow,
                                 const Standard_Integer LowerCol,
                                 const Standard_Integer UpperCol,
                                 const Standard_Real    InitialValue)
    : Array(LowerRow, UpperRow, LowerCol, UpperCol)
{
  Array.Init(InitialValue);
}

//==================================================================================================

inline math_Matrix::math_Matrix(const Standard_Address Tab,
                                 const Standard_Integer LowerRow,
                                 const Standard_Integer UpperRow,
                                 const Standard_Integer LowerCol,
                                 const Standard_Integer UpperCol)
    : Array(Tab, LowerRow, UpperRow, LowerCol, UpperCol)
{
}

//==================================================================================================

inline math_Matrix::math_Matrix(const math_Matrix& Other)
    : Array(Other.Array)
{
}

//==================================================================================================

inline math_Matrix::math_Matrix(math_Matrix&& Other) noexcept
    : Array(std::move(Other.Array))
{
}

//==================================================================================================

inline void math_Matrix::Init(const Standard_Real InitialValue) noexcept
{
  Array.Init(InitialValue);
}

//==================================================================================================

inline void math_Matrix::SetLowerRow(const Standard_Integer LowerRow) noexcept
{
  Array.SetLowerRow(LowerRow);
}

//==================================================================================================

inline void math_Matrix::SetLowerCol(const Standard_Integer LowerCol) noexcept
{
  Array.SetLowerCol(LowerCol);
}

//==================================================================================================

inline void math_Matrix::Multiply(const Standard_Real Right) noexcept
{
  const Standard_Integer aLowerRow = Array.LowerRow();
  const Standard_Integer anUpperRow = Array.UpperRow();
  const Standard_Integer aLowerCol = Array.LowerCol();
  const Standard_Integer anUpperCol = Array.UpperCol();

  for (Standard_Integer I = aLowerRow; I <= anUpperRow; I++)
  {
    for (Standard_Integer J = aLowerCol; J <= anUpperCol; J++)
    {
      Array(I, J) = Array(I, J) * Right;
    }
  }
}

//==================================================================================================

inline math_Matrix math_Matrix::Multiplied(const Standard_Real Right) const noexcept
{
  const Standard_Integer aLowerRow = Array.LowerRow();
  const Standard_Integer anUpperRow = Array.UpperRow();
  const Standard_Integer aLowerCol = Array.LowerCol();
  const Standard_Integer anUpperCol = Array.UpperCol();

  math_Matrix Result(aLowerRow, anUpperRow, aLowerCol, anUpperCol);
  for (Standard_Integer I = aLowerRow; I <= anUpperRow; I++)
  {
    for (Standard_Integer J = aLowerCol; J <= anUpperCol; J++)
    {
      Result.Array(I, J) = Array(I, J) * Right;
    }
  }
  return Result;
}

//==================================================================================================

inline math_Matrix math_Matrix::TMultiplied(const Standard_Real Right) const noexcept
{
  const Standard_Integer aLowerRow = Array.LowerRow();
  const Standard_Integer anUpperRow = Array.UpperRow();
  const Standard_Integer aLowerCol = Array.LowerCol();
  const Standard_Integer anUpperCol = Array.UpperCol();

  math_Matrix Result(aLowerRow, anUpperRow, aLowerCol, anUpperCol);
  for (Standard_Integer I = aLowerRow; I <= anUpperRow; I++)
  {
    for (Standard_Integer J = aLowerCol; J <= anUpperCol; J++)
    {
      Result.Array(I, J) = Array(I, J) * Right;
    }
  }
  return Result;
}

//==================================================================================================

inline void math_Matrix::Divide(const Standard_Real Right)
{
  Standard_DivideByZero_Raise_if(Abs(Right) <= RealEpsilon(),
                                 "math_Matrix::Divide() - zero divisor");

  const Standard_Integer aLowerRow = Array.LowerRow();
  const Standard_Integer anUpperRow = Array.UpperRow();
  const Standard_Integer aLowerCol = Array.LowerCol();
  const Standard_Integer anUpperCol = Array.UpperCol();

  for (Standard_Integer I = aLowerRow; I <= anUpperRow; I++)
  {
    for (Standard_Integer J = aLowerCol; J <= anUpperCol; J++)
    {
      Array(I, J) = Array(I, J) / Right;
    }
  }
}

//==================================================================================================

inline math_Matrix math_Matrix::Divided(const Standard_Real Right) const
{
  Standard_DivideByZero_Raise_if(Abs(Right) <= RealEpsilon(),
                                 "math_Matrix::Divided() - zero divisor");
  math_Matrix temp = Multiplied(1. / Right);
  return temp;
}

//==================================================================================================

inline void math_Matrix::Add(const math_Matrix& Right)
{
  Standard_DimensionError_Raise_if((RowNumber() != Right.RowNumber())
                                     || (ColNumber() != Right.ColNumber()),
                                   "math_Matrix::Add() - input matrix has different dimensions");

  const Standard_Integer aLowerRow = Array.LowerRow();
  const Standard_Integer anUpperRow = Array.UpperRow();
  const Standard_Integer aLowerCol = Array.LowerCol();
  const Standard_Integer anUpperCol = Array.UpperCol();

  Standard_Integer I2 = Right.LowerRow();
  for (Standard_Integer I = aLowerRow; I <= anUpperRow; I++)
  {
    Standard_Integer J2 = Right.LowerCol();
    for (Standard_Integer J = aLowerCol; J <= anUpperCol; J++)
    {
      Array(I, J) = Array(I, J) + Right.Array(I2, J2);
      J2++;
    }
    I2++;
  }
}

//==================================================================================================

inline math_Matrix math_Matrix::Added(const math_Matrix& Right) const
{
  Standard_DimensionError_Raise_if((RowNumber() != Right.RowNumber())
                                     || (ColNumber() != Right.ColNumber()),
                                   "math_Matrix::Added() - input matrix has different dimensions");

  const Standard_Integer aLowerRow = Array.LowerRow();
  const Standard_Integer anUpperRow = Array.UpperRow();
  const Standard_Integer aLowerCol = Array.LowerCol();
  const Standard_Integer anUpperCol = Array.UpperCol();

  math_Matrix Result(aLowerRow, anUpperRow, aLowerCol, anUpperCol);

  Standard_Integer I2 = Right.LowerRow();
  for (Standard_Integer I = aLowerRow; I <= anUpperRow; I++)
  {
    Standard_Integer J2 = Right.LowerCol();
    for (Standard_Integer J = aLowerCol; J <= anUpperCol; J++)
    {
      Result.Array(I, J) = Array(I, J) + Right.Array(I2, J2);
      J2++;
    }
    I2++;
  }
  return Result;
}

//==================================================================================================

inline void math_Matrix::Add(const math_Matrix& Left, const math_Matrix& Right)
{
  Standard_DimensionError_Raise_if(
    (RowNumber() != Right.RowNumber()) || (ColNumber() != Right.ColNumber())
      || (Right.RowNumber() != Left.RowNumber()) || (Right.ColNumber() != Left.ColNumber()),
    "math_Matrix::Add() - matrices have incompatible dimensions");

  const Standard_Integer aLowerRow = Array.LowerRow();
  const Standard_Integer anUpperRow = Array.UpperRow();
  const Standard_Integer aLowerCol = Array.LowerCol();
  const Standard_Integer anUpperCol = Array.UpperCol();

  Standard_Integer I1 = Left.LowerRow();
  Standard_Integer I2 = Right.LowerRow();
  for (Standard_Integer I = aLowerRow; I <= anUpperRow; I++)
  {
    Standard_Integer J1 = Left.LowerCol();
    Standard_Integer J2 = Right.LowerCol();
    for (Standard_Integer J = aLowerCol; J <= anUpperCol; J++)
    {
      Array(I, J) = Left.Array(I1, J1) + Right.Array(I2, J2);
      J1++;
      J2++;
    }
    I1++;
    I2++;
  }
}

//==================================================================================================

inline void math_Matrix::Subtract(const math_Matrix& Right)
{
  Standard_DimensionError_Raise_if(
    (RowNumber() != Right.RowNumber()) || (ColNumber() != Right.ColNumber()),
    "math_Matrix::Subtract() - input matrix has different dimensions");

  const Standard_Integer aLowerRow = Array.LowerRow();
  const Standard_Integer anUpperRow = Array.UpperRow();
  const Standard_Integer aLowerCol = Array.LowerCol();
  const Standard_Integer anUpperCol = Array.UpperCol();

  Standard_Integer I2 = Right.LowerRow();
  for (Standard_Integer I = aLowerRow; I <= anUpperRow; I++)
  {
    Standard_Integer J2 = Right.LowerCol();
    for (Standard_Integer J = aLowerCol; J <= anUpperCol; J++)
    {
      Array(I, J) = Array(I, J) - Right.Array(I2, J2);
      J2++;
    }
    I2++;
  }
}

//==================================================================================================

inline math_Matrix math_Matrix::Subtracted(const math_Matrix& Right) const
{
  Standard_DimensionError_Raise_if(
    (RowNumber() != Right.RowNumber()) || (ColNumber() != Right.ColNumber()),
    "math_Matrix::Subtracted() - input matrix has different dimensions");

  const Standard_Integer aLowerRow = Array.LowerRow();
  const Standard_Integer anUpperRow = Array.UpperRow();
  const Standard_Integer aLowerCol = Array.LowerCol();
  const Standard_Integer anUpperCol = Array.UpperCol();

  math_Matrix Result(aLowerRow, anUpperRow, aLowerCol, anUpperCol);

  Standard_Integer I2 = Right.LowerRow();
  for (Standard_Integer I = aLowerRow; I <= anUpperRow; I++)
  {
    Standard_Integer J2 = Right.LowerCol();
    for (Standard_Integer J = aLowerCol; J <= anUpperCol; J++)
    {
      Result.Array(I, J) = Array(I, J) - Right.Array(I2, J2);
      J2++;
    }
    I2++;
  }
  return Result;
}

//==================================================================================================

inline void math_Matrix::Subtract(const math_Matrix& Left, const math_Matrix& Right)
{
  Standard_DimensionError_Raise_if(
    (RowNumber() != Right.RowNumber()) || (ColNumber() != Right.ColNumber())
      || (Right.RowNumber() != Left.RowNumber()) || (Right.ColNumber() != Left.ColNumber()),
    "math_Matrix::Subtract() - matrices have incompatible dimensions");

  const Standard_Integer aLowerRow = Array.LowerRow();
  const Standard_Integer anUpperRow = Array.UpperRow();
  const Standard_Integer aLowerCol = Array.LowerCol();
  const Standard_Integer anUpperCol = Array.UpperCol();

  Standard_Integer I1 = Left.LowerRow();
  Standard_Integer I2 = Right.LowerRow();
  for (Standard_Integer I = aLowerRow; I <= anUpperRow; I++)
  {
    Standard_Integer J1 = Left.LowerCol();
    Standard_Integer J2 = Right.LowerCol();
    for (Standard_Integer J = aLowerCol; J <= anUpperCol; J++)
    {
      Array(I, J) = Left.Array(I1, J1) - Right.Array(I2, J2);
      J1++;
      J2++;
    }
    I1++;
    I2++;
  }
}

//==================================================================================================

inline math_Matrix math_Matrix::Opposite() const
{
  const Standard_Integer aLowerRow = Array.LowerRow();
  const Standard_Integer anUpperRow = Array.UpperRow();
  const Standard_Integer aLowerCol = Array.LowerCol();
  const Standard_Integer anUpperCol = Array.UpperCol();

  math_Matrix Result(aLowerRow, anUpperRow, aLowerCol, anUpperCol);

  for (Standard_Integer I = aLowerRow; I <= anUpperRow; I++)
  {
    for (Standard_Integer J = aLowerCol; J <= anUpperCol; J++)
    {
      Result.Array(I, J) = -Array(I, J);
    }
  }
  return Result;
}

//==================================================================================================

inline void math_Matrix::Set(const Standard_Integer I1,
                              const Standard_Integer I2,
                              const Standard_Integer J1,
                              const Standard_Integer J2,
                              const math_Matrix&     M)
{
  Standard_DimensionError_Raise_if(
    (I1 > I2) || (J1 > J2) || (I2 - I1 + 1 != M.RowNumber()) || (J2 - J1 + 1 != M.ColNumber()),
    "math_Matrix::Set() - invalid indices");

  Standard_Integer II = M.LowerRow();
  for (Standard_Integer I = I1; I <= I2; I++)
  {
    Standard_Integer JJ = M.LowerCol();
    for (Standard_Integer J = J1; J <= J2; J++)
    {
      Array(I, J) = M.Array(II, JJ);
      JJ++;
    }
    II++;
  }
}

//==================================================================================================

inline void math_Matrix::SetRow(const Standard_Integer Row, const math_Vector& V)
{
  Standard_DimensionError_Raise_if(ColNumber() != V.Length(),
                                   "math_Matrix::SetRow() - input vector has wrong dimensions");

  const Standard_Integer aLowerCol = Array.LowerCol();
  const Standard_Integer anUpperCol = Array.UpperCol();

  Standard_Integer I = V.Lower();
  for (Standard_Integer Index = aLowerCol; Index <= anUpperCol; Index++)
  {
    Array(Row, Index) = V.Array(I);
    I++;
  }
}

//==================================================================================================

inline void math_Matrix::SetCol(const Standard_Integer Col, const math_Vector& V)
{
  Standard_DimensionError_Raise_if(RowNumber() != V.Length(),
                                   "math_Matrix::SetCol() - input vector has wrong dimensions");

  const Standard_Integer aLowerRow = Array.LowerRow();
  const Standard_Integer anUpperRow = Array.UpperRow();

  Standard_Integer I = V.Lower();
  for (Standard_Integer Index = aLowerRow; Index <= anUpperRow; Index++)
  {
    Array(Index, Col) = V.Array(I);
    I++;
  }
}

//==================================================================================================

inline void math_Matrix::SetDiag(const Standard_Real Value)
{
  math_NotSquare_Raise_if(RowNumber() != ColNumber(),
                          "math_Matrix::SetDiag() - matrix is not square");

  const Standard_Integer aLowerRow = Array.LowerRow();
  const Standard_Integer anUpperRow = Array.UpperRow();

  for (Standard_Integer I = aLowerRow; I <= anUpperRow; I++)
  {
    Array(I, I) = Value;
  }
}

//==================================================================================================

inline math_Vector math_Matrix::Row(const Standard_Integer Row) const
{
  const Standard_Integer aLowerCol = Array.LowerCol();
  const Standard_Integer anUpperCol = Array.UpperCol();

  math_Vector Result(aLowerCol, anUpperCol);

  for (Standard_Integer Index = aLowerCol; Index <= anUpperCol; Index++)
  {
    Result.Array(Index) = Array(Row, Index);
  }
  return Result;
}

//==================================================================================================

inline math_Vector math_Matrix::Col(const Standard_Integer Col) const
{
  const Standard_Integer aLowerRow = Array.LowerRow();
  const Standard_Integer anUpperRow = Array.UpperRow();

  math_Vector Result(aLowerRow, anUpperRow);

  for (Standard_Integer Index = aLowerRow; Index <= anUpperRow; Index++)
  {
    Result.Array(Index) = Array(Index, Col);
  }
  return Result;
}

//==================================================================================================

inline void math_Matrix::SwapRow(const Standard_Integer Row1, const Standard_Integer Row2)
{
  math_Vector V1 = Row(Row1);
  math_Vector V2 = Row(Row2);
  SetRow(Row1, V2);
  SetRow(Row2, V1);
}

//==================================================================================================

inline void math_Matrix::SwapCol(const Standard_Integer Col1, const Standard_Integer Col2)
{
  math_Vector V1 = Col(Col1);
  math_Vector V2 = Col(Col2);
  SetCol(Col1, V2);
  SetCol(Col2, V1);
}

//==================================================================================================

inline math_Matrix math_Matrix::Transposed() const
{
  const Standard_Integer aLowerRow = Array.LowerRow();
  const Standard_Integer anUpperRow = Array.UpperRow();
  const Standard_Integer aLowerCol = Array.LowerCol();
  const Standard_Integer anUpperCol = Array.UpperCol();

  math_Matrix Result(aLowerCol, anUpperCol, aLowerRow, anUpperRow);

  for (Standard_Integer I = aLowerRow; I <= anUpperRow; I++)
  {
    for (Standard_Integer J = aLowerCol; J <= anUpperCol; J++)
    {
      Result.Array(J, I) = Array(I, J);
    }
  }
  return Result;
}

//==================================================================================================

inline void math_Matrix::Multiply(const math_Vector& Left, const math_Vector& Right)
{
  Standard_DimensionError_Raise_if(
    (RowNumber() != Left.Length()) || (ColNumber() != Right.Length()),
    "math_Matrix::Multiply() - input vectors have incompatible dimensions");

  const Standard_Integer aLowerRow = Array.LowerRow();
  const Standard_Integer anUpperRow = Array.UpperRow();
  const Standard_Integer aLowerCol = Array.LowerCol();
  const Standard_Integer anUpperCol = Array.UpperCol();

  for (Standard_Integer I = aLowerRow; I <= anUpperRow; I++)
  {
    for (Standard_Integer J = aLowerCol; J <= anUpperCol; J++)
    {
      Array(I, J) = Left.Array(I) * Right.Array(J);
    }
  }
}

//==================================================================================================

inline void math_Matrix::Multiply(const math_Matrix& Left, const math_Matrix& Right)
{
  Standard_DimensionError_Raise_if(
    (Left.ColNumber() != Right.RowNumber()) || (RowNumber() != Left.RowNumber())
      || (ColNumber() != Right.ColNumber()),
    "math_Matrix::Multiply() - matrices have incompatible dimensions");

  const Standard_Integer aLowerRow = Array.LowerRow();
  const Standard_Integer anUpperRow = Array.UpperRow();
  const Standard_Integer aLowerCol = Array.LowerCol();
  const Standard_Integer anUpperCol = Array.UpperCol();

  Standard_Real    Som;
  Standard_Integer I1 = Left.LowerRow();
  for (Standard_Integer I = aLowerRow; I <= anUpperRow; I++)
  {
    Standard_Integer J2 = Right.LowerCol();
    for (Standard_Integer J = aLowerCol; J <= anUpperCol; J++)
    {
      Som                 = 0.0;
      Standard_Integer J1 = Left.LowerCol();
      Standard_Integer I2 = Right.LowerRow();
      for (Standard_Integer K = Left.LowerCol(); K <= Left.UpperCol(); K++)
      {
        Som = Som + Left.Array(I1, J1) * Right.Array(I2, J2);
        J1++;
        I2++;
      }
      Array(I, J) = Som;
      J2++;
    }
    I1++;
  }
}

//==================================================================================================

inline void math_Matrix::Multiply(const math_Matrix& Right)
{
  Standard_DimensionError_Raise_if(
    ColNumber() != Right.RowNumber(),
    "math_Matrix::Multiply() - input matrix has incompatible dimensions");

  const Standard_Integer aLowerRow = Array.LowerRow();
  const Standard_Integer anUpperRow = Array.UpperRow();
  const Standard_Integer aLowerCol = Array.LowerCol();
  const Standard_Integer anUpperCol = Array.UpperCol();

  // Create a temporary copy to avoid corrupting our own data during calculation
  math_Matrix aTemp = *this;
  if (this == &Right)
  {
    Multiply(aTemp, aTemp);
    return;
  }

  Standard_Real Som;
  for (Standard_Integer I = aLowerRow; I <= anUpperRow; I++)
  {
    for (Standard_Integer J2 = Right.LowerCol(); J2 <= Right.UpperCol(); J2++)
    {
      Som                 = 0.0;
      Standard_Integer I2 = Right.LowerRow();
      for (Standard_Integer J = aLowerCol; J <= anUpperCol; J++)
      {
        Som += aTemp.Array(I, J) * Right.Array(I2, J2);
        I2++;
      }
      Array(I, J2) = Som;
    }
  }
}

//==================================================================================================

inline math_Matrix math_Matrix::Multiplied(const math_Matrix& Right) const
{
  Standard_DimensionError_Raise_if(
    ColNumber() != Right.RowNumber(),
    "math_Matrix::Multiplied() - matrices have incompatible dimensions");

  const Standard_Integer aLowerRow = Array.LowerRow();
  const Standard_Integer anUpperRow = Array.UpperRow();
  const Standard_Integer aLowerCol = Array.LowerCol();
  const Standard_Integer anUpperCol = Array.UpperCol();

  math_Matrix Result(aLowerRow, anUpperRow, Right.LowerCol(), Right.UpperCol());

  Standard_Real Som;
  for (Standard_Integer I = aLowerRow; I <= anUpperRow; I++)
  {
    for (Standard_Integer J2 = Right.LowerCol(); J2 <= Right.UpperCol(); J2++)
    {
      Som                 = 0.0;
      Standard_Integer I2 = Right.LowerRow();
      for (Standard_Integer J = aLowerCol; J <= anUpperCol; J++)
      {
        Som = Som + Array(I, J) * Right.Array(I2, J2);
        I2++;
      }
      Result.Array(I, J2) = Som;
    }
  }
  return Result;
}

//==================================================================================================

inline math_Vector math_Matrix::Multiplied(const math_VectorBase<>& Right) const
{
  Standard_DimensionError_Raise_if(
    ColNumber() != Right.Length(),
    "math_Matrix::Multiplied() - input vector has incompatible dimensions");

  const Standard_Integer aLowerRow = Array.LowerRow();
  const Standard_Integer anUpperRow = Array.UpperRow();
  const Standard_Integer aLowerCol = Array.LowerCol();
  const Standard_Integer anUpperCol = Array.UpperCol();

  math_Vector Result(aLowerRow, anUpperRow);

  for (Standard_Integer I = aLowerRow; I <= anUpperRow; I++)
  {
    Result.Array(I)     = 0.0;
    Standard_Integer II = Right.Lower();
    for (Standard_Integer J = aLowerCol; J <= anUpperCol; J++)
    {
      Result.Array(I) = Result.Array(I) + Array(I, J) * Right.Array(II);
      II++;
    }
  }
  return Result;
}

//==================================================================================================

inline math_VectorBase<> math_Matrix::operator*(const math_VectorBase<>& Right) const
{
  return Multiplied(Right);
}

//==================================================================================================

inline math_Matrix math_Matrix::TMultiply(const math_Matrix& Right) const
{
  Standard_DimensionError_Raise_if(
    RowNumber() != Right.RowNumber(),
    "math_Matrix::TMultiply() - matrices have incompatible dimensions");

  const Standard_Integer aLowerRow = Array.LowerRow();
  const Standard_Integer anUpperRow = Array.UpperRow();
  const Standard_Integer aLowerCol = Array.LowerCol();
  const Standard_Integer anUpperCol = Array.UpperCol();

  math_Matrix Result(aLowerCol, anUpperCol, Right.LowerCol(), Right.UpperCol());

  Standard_Real Som;
  for (Standard_Integer I = aLowerCol; I <= anUpperCol; I++)
  {
    for (Standard_Integer J2 = Right.LowerCol(); J2 <= Right.UpperCol(); J2++)
    {
      Som                 = 0.0;
      Standard_Integer I2 = Right.LowerRow();
      for (Standard_Integer J = aLowerRow; J <= anUpperRow; J++)
      {
        Som = Som + Array(J, I) * Right.Array(I2, J2);
        I2++;
      }
      Result.Array(I, J2) = Som;
    }
  }
  return Result;
}

//==================================================================================================

inline void math_Matrix::TMultiply(const math_Matrix& TLeft, const math_Matrix& Right)
{
  Standard_DimensionError_Raise_if(
    (TLeft.RowNumber() != Right.RowNumber()) || (RowNumber() != TLeft.ColNumber())
      || (ColNumber() != Right.ColNumber()),
    "math_Matrix::TMultiply() - matrices have incompatible dimensions");

  const Standard_Integer aLowerRow = Array.LowerRow();
  const Standard_Integer anUpperRow = Array.UpperRow();
  const Standard_Integer aLowerCol = Array.LowerCol();
  const Standard_Integer anUpperCol = Array.UpperCol();

  Standard_Real    Som;
  Standard_Integer I1 = TLeft.LowerCol();
  for (Standard_Integer I = aLowerRow; I <= anUpperRow; I++)
  {
    Standard_Integer J2 = Right.LowerCol();
    for (Standard_Integer J = aLowerCol; J <= anUpperCol; J++)
    {
      Som                 = 0.0;
      Standard_Integer J1 = TLeft.LowerRow();
      Standard_Integer I2 = Right.LowerRow();
      for (Standard_Integer K = TLeft.LowerRow(); K <= TLeft.UpperRow(); K++)
      {
        Som = Som + TLeft.Array(J1, I1) * Right.Array(I2, J2);
        J1++;
        I2++;
      }
      Array(I, J) = Som;
      J2++;
    }
    I1++;
  }
}

//==================================================================================================

inline math_Matrix& math_Matrix::Initialized(const math_Matrix& Other)
{
  Standard_DimensionError_Raise_if(
    (RowNumber() != Other.RowNumber()) || (ColNumber() != Other.ColNumber()),
    "math_Matrix::Initialized() - input matrix has different dimensions");

  (Other.Array).Copy(Array);
  return *this;
}

//==================================================================================================

inline math_Matrix& math_Matrix::operator=(math_Matrix&& Other) noexcept
{
  if (this != &Other)
  {
    Array = std::move(Other.Array);
  }
  return *this;
}

//==================================================================================================

inline Standard_Real math_Matrix::Determinant() const
{
  math_Gauss Sol(*this);

  if (Sol.IsDone())
  {
    return Sol.Determinant();
  }
  else
  {
    return 0.0;
  }
}

//==================================================================================================

inline void math_Matrix::Transpose()
{
  math_NotSquare_Raise_if(RowNumber() != ColNumber(),
                          "math_Matrix::Transpose() - matrix is not square");

  const Standard_Integer aLowerRow = Array.LowerRow();
  const Standard_Integer anUpperRow = Array.UpperRow();
  const Standard_Integer aLowerCol = Array.LowerCol();
  const Standard_Integer anUpperCol = Array.UpperCol();

  Standard_Integer Row = aLowerRow;
  Standard_Integer Col = aLowerCol;
  SetLowerCol(aLowerRow);
  Standard_Real Temp;
  for (Standard_Integer I = aLowerRow; I <= anUpperRow; I++)
  {
    for (Standard_Integer J = I; J <= anUpperCol; J++)
    {
      Temp        = Array(I, J);
      Array(I, J) = Array(J, I);
      Array(J, I) = Temp;
    }
  }
  SetLowerRow(Col);
  SetLowerCol(Row);
}

//==================================================================================================

inline void math_Matrix::Invert()
{
  math_NotSquare_Raise_if(RowNumber() != ColNumber(),
                          "math_Matrix::Invert() - matrix is not square");

  math_Gauss Sol(*this);
  if (Sol.IsDone())
  {
    Sol.Invert(*this);
  }
  else
  {
    throw math_SingularMatrix();
  }
}

//==================================================================================================

inline math_Matrix math_Matrix::Inverse() const
{
  math_Matrix Result = *this;
  Result.Invert();
  return Result;
}

//==================================================================================================

inline void math_Matrix::Dump(Standard_OStream& o) const
{
  const Standard_Integer aLowerRow = Array.LowerRow();
  const Standard_Integer anUpperRow = Array.UpperRow();
  const Standard_Integer aLowerCol = Array.LowerCol();
  const Standard_Integer anUpperCol = Array.UpperCol();

  o << "math_Matrix of RowNumber = " << RowNumber();
  o << " and ColNumber = " << ColNumber() << "\n";

  for (Standard_Integer I = aLowerRow; I <= anUpperRow; I++)
  {
    for (Standard_Integer J = aLowerCol; J <= anUpperCol; J++)
    {
      o << "math_Matrix ( " << I << ", " << J << " ) = ";
      o << Array(I, J) << "\n";
    }
  }
}
