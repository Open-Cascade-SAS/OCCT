// Copyright (c) 2025 OPEN CASCADE SAS
//
// This file is part of Open CASCADE Technology software library.
//
// This library is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License version 2.1 as published
// by the Free Software Foundation, with special exception defined in the file
// OCCT_LGPL_EXCEPTION.txt. Consult the file LICENSE_LGPL_21.txt included in OCCT
// distribution for complete text of the license and disclaimer of any warranty.
//
// Alternatively, this file may be used under the terms of Open CASCADE
// commercial license or contractual agreement.

#ifndef _Geom_EvalRepUtils_HeaderFile
#define _Geom_EvalRepUtils_HeaderFile

#include "Geom_EvalRepCurveDesc.hxx"
#include "Geom_EvalRepSurfaceDesc.hxx"

#include <Geom_Curve.hxx>
#include <Geom_Surface.hxx>

#include <Standard_ProgramError.hxx>

#include <cmath>
#include <optional>

//! Internal helper namespace for EvalRep dispatch and validation.
namespace Geom_EvalRepUtils
{
occ::handle<Geom_EvalRepCurveDesc::Base> CloneCurveDesc(
  const occ::handle<Geom_EvalRepCurveDesc::Base>& theDesc);
occ::handle<Geom_EvalRepSurfaceDesc::Base> CloneSurfaceDesc(
  const occ::handle<Geom_EvalRepSurfaceDesc::Base>& theDesc);

std::optional<gp_Pnt> TryEvalCurveD0(const occ::handle<Geom_EvalRepCurveDesc::Base>& theDesc,
                                     const double                                    theU);
std::optional<Geom_Curve::ResD1> TryEvalCurveD1(
  const occ::handle<Geom_EvalRepCurveDesc::Base>& theDesc,
  const double                                    theU);
std::optional<Geom_Curve::ResD2> TryEvalCurveD2(
  const occ::handle<Geom_EvalRepCurveDesc::Base>& theDesc,
  const double                                    theU);
std::optional<Geom_Curve::ResD3> TryEvalCurveD3(
  const occ::handle<Geom_EvalRepCurveDesc::Base>& theDesc,
  const double                                    theU);
std::optional<gp_Vec> TryEvalCurveDN(const occ::handle<Geom_EvalRepCurveDesc::Base>& theDesc,
                                     const double                                    theU,
                                     const int                                       theN);

std::optional<gp_Pnt> TryEvalSurfaceD0(const occ::handle<Geom_EvalRepSurfaceDesc::Base>& theDesc,
                                       const double                                      theU,
                                       const double                                      theV);
std::optional<Geom_Surface::ResD1> TryEvalSurfaceD1(
  const occ::handle<Geom_EvalRepSurfaceDesc::Base>& theDesc,
  const double                                      theU,
  const double                                      theV);
std::optional<Geom_Surface::ResD2> TryEvalSurfaceD2(
  const occ::handle<Geom_EvalRepSurfaceDesc::Base>& theDesc,
  const double                                      theU,
  const double                                      theV);
std::optional<Geom_Surface::ResD3> TryEvalSurfaceD3(
  const occ::handle<Geom_EvalRepSurfaceDesc::Base>& theDesc,
  const double                                      theU,
  const double                                      theV);
std::optional<gp_Vec> TryEvalSurfaceDN(const occ::handle<Geom_EvalRepSurfaceDesc::Base>& theDesc,
                                       const double                                      theU,
                                       const double                                      theV,
                                       const int                                         theNu,
                                       const int                                         theNv);

std::optional<gp_Pnt>            TryEvalCurveD0Mapped(const Geom_EvalRepCurveDesc::Mapped& theDesc,
                                                      const double                         theU);
std::optional<Geom_Curve::ResD1> TryEvalCurveD1Mapped(const Geom_EvalRepCurveDesc::Mapped& theDesc,
                                                      const double                         theU);
std::optional<Geom_Curve::ResD2> TryEvalCurveD2Mapped(const Geom_EvalRepCurveDesc::Mapped& theDesc,
                                                      const double                         theU);
std::optional<Geom_Curve::ResD3> TryEvalCurveD3Mapped(const Geom_EvalRepCurveDesc::Mapped& theDesc,
                                                      const double                         theU);
std::optional<gp_Vec>            TryEvalCurveDNMapped(const Geom_EvalRepCurveDesc::Mapped& theDesc,
                                                      const double                         theU,
                                                      const int                            theN);

std::optional<gp_Pnt> TryEvalSurfaceD0Mapped(const Geom_EvalRepSurfaceDesc::Mapped& theDesc,
                                             const double                           theU,
                                             const double                           theV);
std::optional<Geom_Surface::ResD1> TryEvalSurfaceD1Mapped(
  const Geom_EvalRepSurfaceDesc::Mapped& theDesc,
  const double                           theU,
  const double                           theV);
std::optional<Geom_Surface::ResD2> TryEvalSurfaceD2Mapped(
  const Geom_EvalRepSurfaceDesc::Mapped& theDesc,
  const double                           theU,
  const double                           theV);
std::optional<Geom_Surface::ResD3> TryEvalSurfaceD3Mapped(
  const Geom_EvalRepSurfaceDesc::Mapped& theDesc,
  const double                           theU,
  const double                           theV);
std::optional<gp_Vec> TryEvalSurfaceDNMapped(const Geom_EvalRepSurfaceDesc::Mapped& theDesc,
                                             const double                           theU,
                                             const double                           theV,
                                             const int                              theNu,
                                             const int                              theNv);
void                  ValidateCurveDesc(const occ::handle<Geom_EvalRepCurveDesc::Base>& theDesc,
                                        const Geom_Curve*                               theOwner);
void                  ValidateSurfaceDesc(const occ::handle<Geom_EvalRepSurfaceDesc::Base>& theDesc,
                                          const Geom_Surface*                               theOwner);
} // namespace Geom_EvalRepUtils

//==================================================================================================

inline void Geom_EvalRepUtils::ValidateCurveDesc(
  const occ::handle<Geom_EvalRepCurveDesc::Base>& theDesc,
  const Geom_Curve*                               theOwner)
{
  if (theDesc.IsNull())
  {
    return;
  }
  if (theDesc->Representation.IsNull())
  {
    throw Standard_ProgramError("SetEvalRepresentation: null Representation");
  }
  if (theDesc->GetKind() == Geom_EvalRepCurveDesc::Base::Kind::Mapped)
  {
    const auto* aMapped = static_cast<const Geom_EvalRepCurveDesc::Mapped*>(theDesc.get());
    if (!aMapped->ParamMap.IsValid())
    {
      throw Standard_ProgramError("SetEvalRepresentation: invalid parameter map");
    }
  }
  // Only direct self-reference is detected here; indirect cycles (A->B->A) are not
  // checked because EvalRepresentation() is not available on the Geom_Curve base class.
  if (theDesc->Representation.get() == theOwner)
  {
    throw Standard_ProgramError("SetEvalRepresentation: invalid descriptor chain");
  }
}

//==================================================================================================

inline void Geom_EvalRepUtils::ValidateSurfaceDesc(
  const occ::handle<Geom_EvalRepSurfaceDesc::Base>& theDesc,
  const Geom_Surface*                               theOwner)
{
  if (theDesc.IsNull())
  {
    return;
  }
  if (theDesc->Representation.IsNull())
  {
    throw Standard_ProgramError("SetEvalRepresentation: null Representation");
  }
  if (theDesc->GetKind() == Geom_EvalRepSurfaceDesc::Base::Kind::Mapped)
  {
    const auto* aMapped = static_cast<const Geom_EvalRepSurfaceDesc::Mapped*>(theDesc.get());
    if (!aMapped->ParamMap.IsValid())
    {
      throw Standard_ProgramError("SetEvalRepresentation: invalid parameter map");
    }
  }
  // Only direct self-reference is detected here; indirect cycles (A->B->A) are not
  // checked because EvalRepresentation() is not available on the Geom_Surface base class.
  if (theDesc->Representation.get() == theOwner)
  {
    throw Standard_ProgramError("SetEvalRepresentation: invalid descriptor chain");
  }
}

//==================================================================================================

inline occ::handle<Geom_EvalRepCurveDesc::Base> Geom_EvalRepUtils::CloneCurveDesc(
  const occ::handle<Geom_EvalRepCurveDesc::Base>& theDesc)
{
  if (theDesc.IsNull() || theDesc->Representation.IsNull())
  {
    return occ::handle<Geom_EvalRepCurveDesc::Base>();
  }

  const occ::handle<Geom_Curve> aRepCopy =
    occ::down_cast<Geom_Curve>(theDesc->Representation->Copy());
  if (aRepCopy.IsNull())
  {
    return occ::handle<Geom_EvalRepCurveDesc::Base>();
  }

  switch (theDesc->GetKind())
  {
    case Geom_EvalRepCurveDesc::Base::Kind::Full: {
      occ::handle<Geom_EvalRepCurveDesc::Full> aClone = new Geom_EvalRepCurveDesc::Full();
      aClone->Representation                          = aRepCopy;
      return aClone;
    }
    case Geom_EvalRepCurveDesc::Base::Kind::DerivBounded: {
      const auto* aSrc = static_cast<const Geom_EvalRepCurveDesc::DerivBounded*>(theDesc.get());
      occ::handle<Geom_EvalRepCurveDesc::DerivBounded> aClone =
        new Geom_EvalRepCurveDesc::DerivBounded();
      aClone->Representation = aRepCopy;
      aClone->MaxDerivOrder  = aSrc->MaxDerivOrder;
      return aClone;
    }
    case Geom_EvalRepCurveDesc::Base::Kind::Mapped: {
      const auto* aSrc = static_cast<const Geom_EvalRepCurveDesc::Mapped*>(theDesc.get());
      occ::handle<Geom_EvalRepCurveDesc::Mapped> aClone = new Geom_EvalRepCurveDesc::Mapped();
      aClone->Representation                            = aRepCopy;
      aClone->MaxDerivOrder                             = aSrc->MaxDerivOrder;
      aClone->Domain                                    = aSrc->Domain;
      aClone->ParamMap                                  = aSrc->ParamMap;
      return aClone;
    }
  }
  return occ::handle<Geom_EvalRepCurveDesc::Base>();
}

//==================================================================================================

inline occ::handle<Geom_EvalRepSurfaceDesc::Base> Geom_EvalRepUtils::CloneSurfaceDesc(
  const occ::handle<Geom_EvalRepSurfaceDesc::Base>& theDesc)
{
  if (theDesc.IsNull() || theDesc->Representation.IsNull())
  {
    return occ::handle<Geom_EvalRepSurfaceDesc::Base>();
  }

  const occ::handle<Geom_Surface> aRepCopy =
    occ::down_cast<Geom_Surface>(theDesc->Representation->Copy());
  if (aRepCopy.IsNull())
  {
    return occ::handle<Geom_EvalRepSurfaceDesc::Base>();
  }

  switch (theDesc->GetKind())
  {
    case Geom_EvalRepSurfaceDesc::Base::Kind::Full: {
      occ::handle<Geom_EvalRepSurfaceDesc::Full> aClone = new Geom_EvalRepSurfaceDesc::Full();
      aClone->Representation                            = aRepCopy;
      return aClone;
    }
    case Geom_EvalRepSurfaceDesc::Base::Kind::DerivBounded: {
      const auto* aSrc = static_cast<const Geom_EvalRepSurfaceDesc::DerivBounded*>(theDesc.get());
      occ::handle<Geom_EvalRepSurfaceDesc::DerivBounded> aClone =
        new Geom_EvalRepSurfaceDesc::DerivBounded();
      aClone->Representation = aRepCopy;
      aClone->MaxDerivOrder  = aSrc->MaxDerivOrder;
      return aClone;
    }
    case Geom_EvalRepSurfaceDesc::Base::Kind::Mapped: {
      const auto* aSrc = static_cast<const Geom_EvalRepSurfaceDesc::Mapped*>(theDesc.get());
      occ::handle<Geom_EvalRepSurfaceDesc::Mapped> aClone = new Geom_EvalRepSurfaceDesc::Mapped();
      aClone->Representation                              = aRepCopy;
      aClone->MaxDerivOrder                               = aSrc->MaxDerivOrder;
      aClone->Domain                                      = aSrc->Domain;
      aClone->ParamMap                                    = aSrc->ParamMap;
      return aClone;
    }
  }
  return occ::handle<Geom_EvalRepSurfaceDesc::Base>();
}

//==================================================================================================

inline std::optional<gp_Pnt> Geom_EvalRepUtils::TryEvalCurveD0(
  const occ::handle<Geom_EvalRepCurveDesc::Base>& theDesc,
  const double                                    theU)
{
  if (theDesc.IsNull())
  {
    return std::nullopt;
  }

  switch (theDesc->GetKind())
  {
    case Geom_EvalRepCurveDesc::Base::Kind::Full:
    case Geom_EvalRepCurveDesc::Base::Kind::DerivBounded:
      return theDesc->Representation->EvalD0(theU);
    case Geom_EvalRepCurveDesc::Base::Kind::Mapped:
      return TryEvalCurveD0Mapped(*static_cast<const Geom_EvalRepCurveDesc::Mapped*>(theDesc.get()),
                                  theU);
  }
  return std::nullopt;
}

//==================================================================================================

inline std::optional<Geom_Curve::ResD1> Geom_EvalRepUtils::TryEvalCurveD1(
  const occ::handle<Geom_EvalRepCurveDesc::Base>& theDesc,
  const double                                    theU)
{
  if (theDesc.IsNull())
  {
    return std::nullopt;
  }

  switch (theDesc->GetKind())
  {
    case Geom_EvalRepCurveDesc::Base::Kind::Full:
      return theDesc->Representation->EvalD1(theU);
    case Geom_EvalRepCurveDesc::Base::Kind::DerivBounded: {
      const auto* aBounded = static_cast<const Geom_EvalRepCurveDesc::DerivBounded*>(theDesc.get());
      if (aBounded->MaxDerivOrder < 1)
        return std::nullopt;
      return theDesc->Representation->EvalD1(theU);
    }
    case Geom_EvalRepCurveDesc::Base::Kind::Mapped: {
      const auto* aMapped = static_cast<const Geom_EvalRepCurveDesc::Mapped*>(theDesc.get());
      if (aMapped->MaxDerivOrder < 1)
        return std::nullopt;
      return TryEvalCurveD1Mapped(*aMapped, theU);
    }
  }
  return std::nullopt;
}

//==================================================================================================

inline std::optional<Geom_Curve::ResD2> Geom_EvalRepUtils::TryEvalCurveD2(
  const occ::handle<Geom_EvalRepCurveDesc::Base>& theDesc,
  const double                                    theU)
{
  if (theDesc.IsNull())
  {
    return std::nullopt;
  }

  switch (theDesc->GetKind())
  {
    case Geom_EvalRepCurveDesc::Base::Kind::Full:
      return theDesc->Representation->EvalD2(theU);
    case Geom_EvalRepCurveDesc::Base::Kind::DerivBounded: {
      const auto* aBounded = static_cast<const Geom_EvalRepCurveDesc::DerivBounded*>(theDesc.get());
      if (aBounded->MaxDerivOrder < 2)
        return std::nullopt;
      return theDesc->Representation->EvalD2(theU);
    }
    case Geom_EvalRepCurveDesc::Base::Kind::Mapped: {
      const auto* aMapped = static_cast<const Geom_EvalRepCurveDesc::Mapped*>(theDesc.get());
      if (aMapped->MaxDerivOrder < 2)
        return std::nullopt;
      return TryEvalCurveD2Mapped(*aMapped, theU);
    }
  }
  return std::nullopt;
}

//==================================================================================================

inline std::optional<Geom_Curve::ResD3> Geom_EvalRepUtils::TryEvalCurveD3(
  const occ::handle<Geom_EvalRepCurveDesc::Base>& theDesc,
  const double                                    theU)
{
  if (theDesc.IsNull())
  {
    return std::nullopt;
  }

  switch (theDesc->GetKind())
  {
    case Geom_EvalRepCurveDesc::Base::Kind::Full:
      return theDesc->Representation->EvalD3(theU);
    case Geom_EvalRepCurveDesc::Base::Kind::DerivBounded: {
      const auto* aBounded = static_cast<const Geom_EvalRepCurveDesc::DerivBounded*>(theDesc.get());
      if (aBounded->MaxDerivOrder < 3)
        return std::nullopt;
      return theDesc->Representation->EvalD3(theU);
    }
    case Geom_EvalRepCurveDesc::Base::Kind::Mapped: {
      const auto* aMapped = static_cast<const Geom_EvalRepCurveDesc::Mapped*>(theDesc.get());
      if (aMapped->MaxDerivOrder < 3)
        return std::nullopt;
      return TryEvalCurveD3Mapped(*aMapped, theU);
    }
  }
  return std::nullopt;
}

//==================================================================================================

inline std::optional<gp_Vec> Geom_EvalRepUtils::TryEvalCurveDN(
  const occ::handle<Geom_EvalRepCurveDesc::Base>& theDesc,
  const double                                    theU,
  const int                                       theN)
{
  if (theDesc.IsNull() || theN < 1)
  {
    return std::nullopt;
  }

  switch (theDesc->GetKind())
  {
    case Geom_EvalRepCurveDesc::Base::Kind::Full:
      return theDesc->Representation->EvalDN(theU, theN);
    case Geom_EvalRepCurveDesc::Base::Kind::DerivBounded: {
      const auto* aBounded = static_cast<const Geom_EvalRepCurveDesc::DerivBounded*>(theDesc.get());
      if (aBounded->MaxDerivOrder < static_cast<std::size_t>(theN))
        return std::nullopt;
      return theDesc->Representation->EvalDN(theU, theN);
    }
    case Geom_EvalRepCurveDesc::Base::Kind::Mapped: {
      const auto* aMapped = static_cast<const Geom_EvalRepCurveDesc::Mapped*>(theDesc.get());
      if (aMapped->MaxDerivOrder < static_cast<std::size_t>(theN))
        return std::nullopt;
      return TryEvalCurveDNMapped(*aMapped, theU, theN);
    }
  }
  return std::nullopt;
}

//==================================================================================================

inline std::optional<gp_Pnt> Geom_EvalRepUtils::TryEvalSurfaceD0(
  const occ::handle<Geom_EvalRepSurfaceDesc::Base>& theDesc,
  const double                                      theU,
  const double                                      theV)
{
  if (theDesc.IsNull())
  {
    return std::nullopt;
  }

  switch (theDesc->GetKind())
  {
    case Geom_EvalRepSurfaceDesc::Base::Kind::Full:
    case Geom_EvalRepSurfaceDesc::Base::Kind::DerivBounded:
      return theDesc->Representation->EvalD0(theU, theV);
    case Geom_EvalRepSurfaceDesc::Base::Kind::Mapped:
      return TryEvalSurfaceD0Mapped(
        *static_cast<const Geom_EvalRepSurfaceDesc::Mapped*>(theDesc.get()),
        theU,
        theV);
  }
  return std::nullopt;
}

//==================================================================================================

inline std::optional<Geom_Surface::ResD1> Geom_EvalRepUtils::TryEvalSurfaceD1(
  const occ::handle<Geom_EvalRepSurfaceDesc::Base>& theDesc,
  const double                                      theU,
  const double                                      theV)
{
  if (theDesc.IsNull())
  {
    return std::nullopt;
  }

  switch (theDesc->GetKind())
  {
    case Geom_EvalRepSurfaceDesc::Base::Kind::Full:
      return theDesc->Representation->EvalD1(theU, theV);
    case Geom_EvalRepSurfaceDesc::Base::Kind::DerivBounded: {
      const auto* aBounded =
        static_cast<const Geom_EvalRepSurfaceDesc::DerivBounded*>(theDesc.get());
      if (aBounded->MaxDerivOrder < 1)
        return std::nullopt;
      return theDesc->Representation->EvalD1(theU, theV);
    }
    case Geom_EvalRepSurfaceDesc::Base::Kind::Mapped: {
      const auto* aMapped = static_cast<const Geom_EvalRepSurfaceDesc::Mapped*>(theDesc.get());
      if (aMapped->MaxDerivOrder < 1)
        return std::nullopt;
      return TryEvalSurfaceD1Mapped(*aMapped, theU, theV);
    }
  }
  return std::nullopt;
}

//==================================================================================================

inline std::optional<Geom_Surface::ResD2> Geom_EvalRepUtils::TryEvalSurfaceD2(
  const occ::handle<Geom_EvalRepSurfaceDesc::Base>& theDesc,
  const double                                      theU,
  const double                                      theV)
{
  if (theDesc.IsNull())
  {
    return std::nullopt;
  }

  switch (theDesc->GetKind())
  {
    case Geom_EvalRepSurfaceDesc::Base::Kind::Full:
      return theDesc->Representation->EvalD2(theU, theV);
    case Geom_EvalRepSurfaceDesc::Base::Kind::DerivBounded: {
      const auto* aBounded =
        static_cast<const Geom_EvalRepSurfaceDesc::DerivBounded*>(theDesc.get());
      if (aBounded->MaxDerivOrder < 2)
        return std::nullopt;
      return theDesc->Representation->EvalD2(theU, theV);
    }
    case Geom_EvalRepSurfaceDesc::Base::Kind::Mapped: {
      const auto* aMapped = static_cast<const Geom_EvalRepSurfaceDesc::Mapped*>(theDesc.get());
      if (aMapped->MaxDerivOrder < 2)
        return std::nullopt;
      return TryEvalSurfaceD2Mapped(*aMapped, theU, theV);
    }
  }
  return std::nullopt;
}

//==================================================================================================

inline std::optional<Geom_Surface::ResD3> Geom_EvalRepUtils::TryEvalSurfaceD3(
  const occ::handle<Geom_EvalRepSurfaceDesc::Base>& theDesc,
  const double                                      theU,
  const double                                      theV)
{
  if (theDesc.IsNull())
  {
    return std::nullopt;
  }

  switch (theDesc->GetKind())
  {
    case Geom_EvalRepSurfaceDesc::Base::Kind::Full:
      return theDesc->Representation->EvalD3(theU, theV);
    case Geom_EvalRepSurfaceDesc::Base::Kind::DerivBounded: {
      const auto* aBounded =
        static_cast<const Geom_EvalRepSurfaceDesc::DerivBounded*>(theDesc.get());
      if (aBounded->MaxDerivOrder < 3)
        return std::nullopt;
      return theDesc->Representation->EvalD3(theU, theV);
    }
    case Geom_EvalRepSurfaceDesc::Base::Kind::Mapped: {
      const auto* aMapped = static_cast<const Geom_EvalRepSurfaceDesc::Mapped*>(theDesc.get());
      if (aMapped->MaxDerivOrder < 3)
        return std::nullopt;
      return TryEvalSurfaceD3Mapped(*aMapped, theU, theV);
    }
  }
  return std::nullopt;
}

//==================================================================================================

inline std::optional<gp_Vec> Geom_EvalRepUtils::TryEvalSurfaceDN(
  const occ::handle<Geom_EvalRepSurfaceDesc::Base>& theDesc,
  const double                                      theU,
  const double                                      theV,
  const int                                         theNu,
  const int                                         theNv)
{
  const int aTotalOrder = theNu + theNv;
  if (theDesc.IsNull() || theNu < 0 || theNv < 0 || aTotalOrder < 1)
  {
    return std::nullopt;
  }

  switch (theDesc->GetKind())
  {
    case Geom_EvalRepSurfaceDesc::Base::Kind::Full:
      return theDesc->Representation->EvalDN(theU, theV, theNu, theNv);
    case Geom_EvalRepSurfaceDesc::Base::Kind::DerivBounded: {
      const auto* aBounded =
        static_cast<const Geom_EvalRepSurfaceDesc::DerivBounded*>(theDesc.get());
      if (aBounded->MaxDerivOrder < static_cast<std::size_t>(aTotalOrder))
        return std::nullopt;
      return theDesc->Representation->EvalDN(theU, theV, theNu, theNv);
    }
    case Geom_EvalRepSurfaceDesc::Base::Kind::Mapped: {
      const auto* aMapped = static_cast<const Geom_EvalRepSurfaceDesc::Mapped*>(theDesc.get());
      if (aMapped->MaxDerivOrder < static_cast<std::size_t>(aTotalOrder))
        return std::nullopt;
      return TryEvalSurfaceDNMapped(*aMapped, theU, theV, theNu, theNv);
    }
  }
  return std::nullopt;
}

//==================================================================================================

inline std::optional<gp_Pnt> Geom_EvalRepUtils::TryEvalCurveD0Mapped(
  const Geom_EvalRepCurveDesc::Mapped& theDesc,
  const double                         theU)
{
  const double aURep = theDesc.ParamMap.Map(theU);

  if (theDesc.Domain.has_value() && !theDesc.Domain->Contains(aURep))
  {
    return std::nullopt;
  }

  return theDesc.Representation->EvalD0(aURep);
}

//==================================================================================================

inline std::optional<Geom_Curve::ResD1> Geom_EvalRepUtils::TryEvalCurveD1Mapped(
  const Geom_EvalRepCurveDesc::Mapped& theDesc,
  const double                         theU)
{
  const double aURep = theDesc.ParamMap.Map(theU);

  if (theDesc.Domain.has_value() && !theDesc.Domain->Contains(aURep))
  {
    return std::nullopt;
  }

  const std::optional<Geom_Curve::ResD1> aRepRes = theDesc.Representation->EvalD1(aURep);
  if (!aRepRes)
  {
    return std::nullopt;
  }

  const double      aScale = theDesc.ParamMap.Scale;
  Geom_Curve::ResD1 aRes;
  aRes.Point = aRepRes->Point;
  aRes.D1    = aRepRes->D1 * aScale;
  return aRes;
}

//==================================================================================================

inline std::optional<Geom_Curve::ResD2> Geom_EvalRepUtils::TryEvalCurveD2Mapped(
  const Geom_EvalRepCurveDesc::Mapped& theDesc,
  const double                         theU)
{
  const double aURep = theDesc.ParamMap.Map(theU);

  if (theDesc.Domain.has_value() && !theDesc.Domain->Contains(aURep))
  {
    return std::nullopt;
  }

  const std::optional<Geom_Curve::ResD2> aRepRes = theDesc.Representation->EvalD2(aURep);
  if (!aRepRes)
  {
    return std::nullopt;
  }

  const double aScale  = theDesc.ParamMap.Scale;
  const double aScale2 = aScale * aScale;

  Geom_Curve::ResD2 aRes;
  aRes.Point = aRepRes->Point;
  aRes.D1    = aRepRes->D1 * aScale;
  aRes.D2    = aRepRes->D2 * aScale2;
  return aRes;
}

//==================================================================================================

inline std::optional<Geom_Curve::ResD3> Geom_EvalRepUtils::TryEvalCurveD3Mapped(
  const Geom_EvalRepCurveDesc::Mapped& theDesc,
  const double                         theU)
{
  const double aURep = theDesc.ParamMap.Map(theU);

  if (theDesc.Domain.has_value() && !theDesc.Domain->Contains(aURep))
  {
    return std::nullopt;
  }

  const std::optional<Geom_Curve::ResD3> aRepRes = theDesc.Representation->EvalD3(aURep);
  if (!aRepRes)
  {
    return std::nullopt;
  }

  const double aScale  = theDesc.ParamMap.Scale;
  const double aScale2 = aScale * aScale;
  const double aScale3 = aScale2 * aScale;

  Geom_Curve::ResD3 aRes;
  aRes.Point = aRepRes->Point;
  aRes.D1    = aRepRes->D1 * aScale;
  aRes.D2    = aRepRes->D2 * aScale2;
  aRes.D3    = aRepRes->D3 * aScale3;
  return aRes;
}

//==================================================================================================

inline std::optional<gp_Vec> Geom_EvalRepUtils::TryEvalCurveDNMapped(
  const Geom_EvalRepCurveDesc::Mapped& theDesc,
  const double                         theU,
  const int                            theN)
{
  const double aURep = theDesc.ParamMap.Map(theU);

  if (theDesc.Domain.has_value() && !theDesc.Domain->Contains(aURep))
  {
    return std::nullopt;
  }

  const std::optional<gp_Vec> aRepVec = theDesc.Representation->EvalDN(aURep, theN);
  if (!aRepVec)
  {
    return std::nullopt;
  }

  const double aScaleN = std::pow(theDesc.ParamMap.Scale, theN);
  return (*aRepVec) * aScaleN;
}

//==================================================================================================

inline std::optional<gp_Pnt> Geom_EvalRepUtils::TryEvalSurfaceD0Mapped(
  const Geom_EvalRepSurfaceDesc::Mapped& theDesc,
  const double                           theU,
  const double                           theV)
{
  double aURep = 0.0;
  double aVRep = 0.0;
  theDesc.ParamMap.Map(theU, theV, aURep, aVRep);

  if (theDesc.Domain.has_value() && !theDesc.Domain->Contains(aURep, aVRep))
  {
    return std::nullopt;
  }

  return theDesc.Representation->EvalD0(aURep, aVRep);
}

//==================================================================================================

inline std::optional<Geom_Surface::ResD1> Geom_EvalRepUtils::TryEvalSurfaceD1Mapped(
  const Geom_EvalRepSurfaceDesc::Mapped& theDesc,
  const double                           theU,
  const double                           theV)
{
  double aURep = 0.0;
  double aVRep = 0.0;
  theDesc.ParamMap.Map(theU, theV, aURep, aVRep);

  if (theDesc.Domain.has_value() && !theDesc.Domain->Contains(aURep, aVRep))
  {
    return std::nullopt;
  }

  const std::optional<Geom_Surface::ResD1> aRepRes = theDesc.Representation->EvalD1(aURep, aVRep);
  if (!aRepRes)
  {
    return std::nullopt;
  }

  Geom_Surface::ResD1 aRes;
  aRes.Point = aRepRes->Point;

  if (theDesc.ParamMap.SwapUV)
  {
    aRes.D1U = aRepRes->D1V * theDesc.ParamMap.ScaleV;
    aRes.D1V = aRepRes->D1U * theDesc.ParamMap.ScaleU;
  }
  else
  {
    aRes.D1U = aRepRes->D1U * theDesc.ParamMap.ScaleU;
    aRes.D1V = aRepRes->D1V * theDesc.ParamMap.ScaleV;
  }

  return aRes;
}

//==================================================================================================

inline std::optional<Geom_Surface::ResD2> Geom_EvalRepUtils::TryEvalSurfaceD2Mapped(
  const Geom_EvalRepSurfaceDesc::Mapped& theDesc,
  const double                           theU,
  const double                           theV)
{
  double aURep = 0.0;
  double aVRep = 0.0;
  theDesc.ParamMap.Map(theU, theV, aURep, aVRep);

  if (theDesc.Domain.has_value() && !theDesc.Domain->Contains(aURep, aVRep))
  {
    return std::nullopt;
  }

  const std::optional<Geom_Surface::ResD2> aRepRes = theDesc.Representation->EvalD2(aURep, aVRep);
  if (!aRepRes)
  {
    return std::nullopt;
  }

  Geom_Surface::ResD2 aRes;
  aRes.Point = aRepRes->Point;

  const double aSu   = theDesc.ParamMap.ScaleU;
  const double aSv   = theDesc.ParamMap.ScaleV;
  const double aSu2  = aSu * aSu;
  const double aSv2  = aSv * aSv;
  const double aSuSv = aSu * aSv;

  if (theDesc.ParamMap.SwapUV)
  {
    aRes.D1U  = aRepRes->D1V * aSv;
    aRes.D1V  = aRepRes->D1U * aSu;
    aRes.D2U  = aRepRes->D2V * aSv2;
    aRes.D2V  = aRepRes->D2U * aSu2;
    aRes.D2UV = aRepRes->D2UV * aSuSv;
  }
  else
  {
    aRes.D1U  = aRepRes->D1U * aSu;
    aRes.D1V  = aRepRes->D1V * aSv;
    aRes.D2U  = aRepRes->D2U * aSu2;
    aRes.D2V  = aRepRes->D2V * aSv2;
    aRes.D2UV = aRepRes->D2UV * aSuSv;
  }

  return aRes;
}

//==================================================================================================

inline std::optional<Geom_Surface::ResD3> Geom_EvalRepUtils::TryEvalSurfaceD3Mapped(
  const Geom_EvalRepSurfaceDesc::Mapped& theDesc,
  const double                           theU,
  const double                           theV)
{
  double aURep = 0.0;
  double aVRep = 0.0;
  theDesc.ParamMap.Map(theU, theV, aURep, aVRep);

  if (theDesc.Domain.has_value() && !theDesc.Domain->Contains(aURep, aVRep))
  {
    return std::nullopt;
  }

  const std::optional<Geom_Surface::ResD3> aRepRes = theDesc.Representation->EvalD3(aURep, aVRep);
  if (!aRepRes)
  {
    return std::nullopt;
  }

  Geom_Surface::ResD3 aRes;
  aRes.Point = aRepRes->Point;

  const double aSu = theDesc.ParamMap.ScaleU;
  const double aSv = theDesc.ParamMap.ScaleV;

  if (theDesc.ParamMap.SwapUV)
  {
    aRes.D1U   = aRepRes->D1V * aSv;
    aRes.D1V   = aRepRes->D1U * aSu;
    aRes.D2U   = aRepRes->D2V * (aSv * aSv);
    aRes.D2V   = aRepRes->D2U * (aSu * aSu);
    aRes.D2UV  = aRepRes->D2UV * (aSu * aSv);
    aRes.D3U   = aRepRes->D3V * (aSv * aSv * aSv);
    aRes.D3V   = aRepRes->D3U * (aSu * aSu * aSu);
    aRes.D3UUV = aRepRes->D3UVV * (aSv * aSv * aSu);
    aRes.D3UVV = aRepRes->D3UUV * (aSu * aSu * aSv);
  }
  else
  {
    aRes.D1U   = aRepRes->D1U * aSu;
    aRes.D1V   = aRepRes->D1V * aSv;
    aRes.D2U   = aRepRes->D2U * (aSu * aSu);
    aRes.D2V   = aRepRes->D2V * (aSv * aSv);
    aRes.D2UV  = aRepRes->D2UV * (aSu * aSv);
    aRes.D3U   = aRepRes->D3U * (aSu * aSu * aSu);
    aRes.D3V   = aRepRes->D3V * (aSv * aSv * aSv);
    aRes.D3UUV = aRepRes->D3UUV * (aSu * aSu * aSv);
    aRes.D3UVV = aRepRes->D3UVV * (aSu * aSv * aSv);
  }

  return aRes;
}

//==================================================================================================

inline std::optional<gp_Vec> Geom_EvalRepUtils::TryEvalSurfaceDNMapped(
  const Geom_EvalRepSurfaceDesc::Mapped& theDesc,
  const double                           theU,
  const double                           theV,
  const int                              theNu,
  const int                              theNv)
{
  double aURep = 0.0;
  double aVRep = 0.0;
  theDesc.ParamMap.Map(theU, theV, aURep, aVRep);

  if (theDesc.Domain.has_value() && !theDesc.Domain->Contains(aURep, aVRep))
  {
    return std::nullopt;
  }

  int aNuRep = theNu;
  int aNvRep = theNv;

  if (theDesc.ParamMap.SwapUV)
  {
    aNuRep = theNv;
    aNvRep = theNu;
  }

  const std::optional<gp_Vec> aRepVec =
    theDesc.Representation->EvalDN(aURep, aVRep, aNuRep, aNvRep);
  if (!aRepVec)
  {
    return std::nullopt;
  }

  const double aScale =
    std::pow(theDesc.ParamMap.ScaleU, aNuRep) * std::pow(theDesc.ParamMap.ScaleV, aNvRep);

  return (*aRepVec) * aScale;
}

#endif // _Geom_EvalRepUtils_HeaderFile
