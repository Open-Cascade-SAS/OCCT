// Copyright (c) 2015-2025 OPEN CASCADE SAS
//
// This file is part of Open CASCADE Technology software library.
//
// This library is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License version 2.1 as published
// by the Free Software Foundation, with special exception defined in the file
// OCCT_LGPL_EXCEPTION.txt. Consult the file LICENSE_LGPL_21.txt included in OCCT
// distribution for complete text of the license and disclaimer of any warranty.
//
// Alternatively, this file may be used under the terms of Open CASCADE
// commercial license or contractual agreement.

#ifndef _Geom_OffsetSurfaceUtils_HeaderFile
#define _Geom_OffsetSurfaceUtils_HeaderFile

#include <CSLib.hxx>
#include <CSLib_NormalStatus.hxx>
#include <Geom_BSplineSurface.hxx>
#include <Geom_Surface.hxx>
#include <gp_Dir.hxx>
#include <gp_Pnt.hxx>
#include <gp_Vec.hxx>
#include <gp_XYZ.hxx>
#include <NCollection_LocalArray.hxx>
#include <Precision.hxx>
#include <NCollection_Array2.hxx>

#include <cmath>

//! Internal helper namespace for 3D offset surface calculations.
//! Provides static inline functions to compute offset surface point and derivatives
//! from basis surface derivatives.
//!
//! Includes both non-singular (simple cross product normal) and singular
//! (osculating surface) case handling.
//!
//! Mathematical basis:
//! P(u,v) = p(u,v) + Offset * N / ||N||
//! where N = dP/du ^ dP/dv is the surface normal
namespace Geom_OffsetSurfaceUtils
{

//! Default tolerance for normal magnitude check
constexpr double THE_D1_MAGNITUDE_TOL = 1.e-9;

//! Struct to hold osculating surface query results.
//! Used to abstract osculating surface handling between different classes.
struct OsculatingInfo
{
  bool AlongU     = false; //!< True if osculating along U direction
  bool AlongV     = false; //!< True if osculating along V direction
  bool IsOpposite = false; //!< True if normal direction should be reversed

  //! Returns the sign factor for offset calculation
  double Sign() const { return ((AlongU || AlongV) && IsOpposite) ? -1.0 : 1.0; }

  //! Returns true if osculating surface is available
  bool HasOsculating() const { return AlongU || AlongV; }
};

//! Checks if a vector has infinite coordinates.
//! @param[in] theVec vector to check
//! @return true if any coordinate is infinite
inline bool IsInfiniteCoord(const gp_Vec& theVec)
{
  return Precision::IsInfinite(theVec.X()) || Precision::IsInfinite(theVec.Y())
         || Precision::IsInfinite(theVec.Z());
}

//! Checks if surface normal is singular (has zero magnitude).
//! @param[in] theD1U first derivative with respect to U
//! @param[in] theD1V first derivative with respect to V
//! @param[in] theTol tolerance for magnitude check
//! @return true if normal magnitude is below tolerance (singular case)
inline bool IsSingular(const gp_Vec& theD1U,
                       const gp_Vec& theD1V,
                       double        theTol = THE_D1_MAGNITUDE_TOL)
{
  // Normalize derivatives before normal calculation for stability
  gp_Vec aD1U(theD1U);
  gp_Vec aD1V(theD1V);
  double aD1UNorm2 = aD1U.SquareMagnitude();
  double aD1VNorm2 = aD1V.SquareMagnitude();
  if (aD1UNorm2 > 1.0)
    aD1U /= std::sqrt(aD1UNorm2);
  if (aD1VNorm2 > 1.0)
    aD1V /= std::sqrt(aD1VNorm2);

  gp_Vec aNorm = aD1U.Crossed(aD1V);
  return aNorm.SquareMagnitude() <= theTol * theTol;
}

//! Calculates normalized normal vector for non-singular case.
//! @param[in] theD1U first derivative with respect to U
//! @param[in] theD1V first derivative with respect to V
//! @param[out] theNormal computed normalized normal (valid only if return is true)
//! @param[in] theTol tolerance for magnitude check
//! @return true if normal computed successfully, false if singular
inline bool ComputeNormal(const gp_Vec& theD1U,
                          const gp_Vec& theD1V,
                          gp_Vec&       theNormal,
                          double        theTol = THE_D1_MAGNITUDE_TOL)
{
  // Normalize derivatives before normal calculation for stability
  gp_Vec aD1U(theD1U);
  gp_Vec aD1V(theD1V);
  double aD1UNorm2 = aD1U.SquareMagnitude();
  double aD1VNorm2 = aD1V.SquareMagnitude();
  if (aD1UNorm2 > 1.0)
    aD1U /= std::sqrt(aD1UNorm2);
  if (aD1VNorm2 > 1.0)
    aD1V /= std::sqrt(aD1VNorm2);

  theNormal = aD1U.Crossed(aD1V);
  if (theNormal.SquareMagnitude() <= theTol * theTol)
  {
    return false;
  }
  theNormal.Normalize();
  return true;
}

//! Computes dN/du for non-singular offset surface.
//! @param[in] theD1U first derivative with respect to U
//! @param[in] theD1V first derivative with respect to V
//! @param[in] theD2U second derivative d2P/du2
//! @param[in] theD2UV mixed derivative d2P/dudv
//! @param[in] theNormal unit normal vector
//! @return derivative of normal with respect to U
inline gp_Vec ComputeDNormalU(const gp_Vec& theD1U,
                              const gp_Vec& theD1V,
                              const gp_Vec& theD2U,
                              const gp_Vec& theD2UV,
                              const gp_Vec& theNormal)
{
  double aScale = (theD1U ^ theD1V).Dot(theNormal);

  gp_Vec aN1U;
  aN1U.SetX(theD2U.Y() * theD1V.Z() + theD1U.Y() * theD2UV.Z() - theD2U.Z() * theD1V.Y()
            - theD1U.Z() * theD2UV.Y());
  aN1U.SetY(-(theD2U.X() * theD1V.Z() + theD1U.X() * theD2UV.Z() - theD2U.Z() * theD1V.X()
              - theD1U.Z() * theD2UV.X()));
  aN1U.SetZ(theD2U.X() * theD1V.Y() + theD1U.X() * theD2UV.Y() - theD2U.Y() * theD1V.X()
            - theD1U.Y() * theD2UV.X());
  double aScaleU = aN1U.Dot(theNormal);
  aN1U.Subtract(aScaleU * theNormal);
  aN1U /= aScale;

  return aN1U;
}

//! Computes dN/dv for non-singular offset surface.
//! @param[in] theD1U first derivative with respect to U
//! @param[in] theD1V first derivative with respect to V
//! @param[in] theD2V second derivative d2P/dv2
//! @param[in] theD2UV mixed derivative d2P/dudv
//! @param[in] theNormal unit normal vector
//! @return derivative of normal with respect to V
inline gp_Vec ComputeDNormalV(const gp_Vec& theD1U,
                              const gp_Vec& theD1V,
                              const gp_Vec& theD2V,
                              const gp_Vec& theD2UV,
                              const gp_Vec& theNormal)
{
  double aScale = (theD1U ^ theD1V).Dot(theNormal);

  gp_Vec aN1V;
  aN1V.SetX(theD2UV.Y() * theD1V.Z() + theD2V.Z() * theD1U.Y() - theD2UV.Z() * theD1V.Y()
            - theD2V.Y() * theD1U.Z());
  aN1V.SetY(-(theD2UV.X() * theD1V.Z() + theD2V.Z() * theD1U.X() - theD2UV.Z() * theD1V.X()
              - theD2V.X() * theD1U.Z()));
  aN1V.SetZ(theD2UV.X() * theD1V.Y() + theD2V.Y() * theD1U.X() - theD2UV.Y() * theD1V.X()
            - theD2V.X() * theD1U.Y());
  double aScaleV = aN1V.Dot(theNormal);
  aN1V.Subtract(aScaleV * theNormal);
  aN1V /= aScale;

  return aN1V;
}

//! Calculates D0 (point) for offset surface in non-singular case.
//! @param[in,out] theValue on input: basis surface point; on output: offset point
//! @param[in] theD1U first derivative with respect to U
//! @param[in] theD1V first derivative with respect to V
//! @param[in] theOffset offset distance value
//! @param[in] theSign sign factor (1.0 or -1.0) for offset direction
//! @return false if singular (normal has zero magnitude), true otherwise
inline bool CalculateD0(gp_Pnt&       theValue,
                        const gp_Vec& theD1U,
                        const gp_Vec& theD1V,
                        double        theOffset,
                        double        theSign = 1.0)
{
  gp_Vec aNorm;
  if (!ComputeNormal(theD1U, theD1V, aNorm))
  {
    return false;
  }
  theValue.SetXYZ(theValue.XYZ() + theOffset * theSign * aNorm.XYZ());
  return true;
}

//! Calculates D0 and D1 for offset surface in non-singular case.
//! @param[in,out] theValue on input: basis surface point; on output: offset point
//! @param[in,out] theD1U on input: basis dP/du; on output: offset surface dP/du
//! @param[in,out] theD1V on input: basis dP/dv; on output: offset surface dP/dv
//! @param[in] theD2U second derivative d2P/du2 of basis surface
//! @param[in] theD2V second derivative d2P/dv2 of basis surface
//! @param[in] theD2UV mixed derivative d2P/dudv of basis surface
//! @param[in] theOffset offset distance value
//! @param[in] theSign sign factor (1.0 or -1.0) for offset direction
//! @return false if singular (normal has zero magnitude), true otherwise
inline bool CalculateD1(gp_Pnt&       theValue,
                        gp_Vec&       theD1U,
                        gp_Vec&       theD1V,
                        const gp_Vec& theD2U,
                        const gp_Vec& theD2V,
                        const gp_Vec& theD2UV,
                        double        theOffset,
                        double        theSign = 1.0)
{
  gp_Vec aNorm;
  if (!ComputeNormal(theD1U, theD1V, aNorm))
  {
    return false;
  }

  // Compute offset point
  theValue.SetXYZ(theValue.XYZ() + theOffset * theSign * aNorm.XYZ());

  // Compute normal derivatives
  gp_Vec aN1U = ComputeDNormalU(theD1U, theD1V, theD2U, theD2UV, aNorm);
  gp_Vec aN1V = ComputeDNormalV(theD1U, theD1V, theD2V, theD2UV, aNorm);

  theD1U += theOffset * theSign * aN1U;
  theD1V += theOffset * theSign * aN1V;

  return true;
}

//! Template function for computing derivatives at singular points.
//! Works with any surface type that provides D1, D2, D3, DN methods.
//! @tparam BasisSurfType type of basis surface (Handle to surface or adaptor)
//! @tparam OscSurfType type of osculating surface (Handle to BSpline surface)
//! @param[in] theMaxOrder maximum derivative order
//! @param[in] theMinOrder minimum derivative order
//! @param[in] theU U parameter
//! @param[in] theV V parameter
//! @param[in] theBasisSurf basis surface
//! @param[in] theNU derivative order in U for output
//! @param[in] theNV derivative order in V for output
//! @param[in] theAlongU true if osculating along U
//! @param[in] theAlongV true if osculating along V
//! @param[in] theOscSurf osculating surface (may be null)
//! @param[out] theDerNUV array of normal derivatives
//! @param[in,out] theDerSurf array of surface derivatives
template <class BasisSurfType, class OscSurfType>
bool ComputeDerivatives(int                         theMaxOrder,
                        int                         theMinOrder,
                        double                      theU,
                        double                      theV,
                        const BasisSurfType&        theBasisSurf,
                        int                         theNU,
                        int                         theNV,
                        bool                        theAlongU,
                        bool                        theAlongV,
                        const OscSurfType&          theOscSurf,
                        NCollection_Array2<gp_Vec>& theDerNUV,
                        NCollection_Array2<gp_Vec>& theDerSurf)
{
  if (theAlongU || theAlongV)
  {
    theMaxOrder = 0;
    // Stack buffer for DerSurfL: max size is (theNU + 2) x (theNV + 2)
    // DN can have theNU/theNV up to 6, so max is 8x8=64
    const int aDerSurfLSize = (theMaxOrder + theNU + 2) * (theMaxOrder + theNV + 2);
    NCollection_LocalArray<gp_Vec, 64> aDerSurfLBuffer(aDerSurfLSize);
    NCollection_Array2<gp_Vec>         DerSurfL(aDerSurfLBuffer[0],
                                        0,
                                        theMaxOrder + theNU + 1,
                                        0,
                                        theMaxOrder + theNV + 1);
    switch (theMinOrder)
    {
      case 1: {
        Geom_Surface::ResD1 aD1 = theOscSurf->EvalD1(theU, theV);
        DerSurfL.SetValue(1, 0, aD1.D1U);
        DerSurfL.SetValue(0, 1, aD1.D1V);
        break;
      }
      case 2: {
        Geom_Surface::ResD2 aD2 = theOscSurf->EvalD2(theU, theV);
        DerSurfL.SetValue(1, 0, aD2.D1U);
        DerSurfL.SetValue(0, 1, aD2.D1V);
        DerSurfL.SetValue(1, 1, aD2.D2UV);
        DerSurfL.SetValue(2, 0, aD2.D2U);
        DerSurfL.SetValue(0, 2, aD2.D2V);
        break;
      }
      case 3: {
        Geom_Surface::ResD3 aD3 = theOscSurf->EvalD3(theU, theV);
        DerSurfL.SetValue(1, 0, aD3.D1U);
        DerSurfL.SetValue(0, 1, aD3.D1V);
        DerSurfL.SetValue(1, 1, aD3.D2UV);
        DerSurfL.SetValue(2, 0, aD3.D2U);
        DerSurfL.SetValue(0, 2, aD3.D2V);
        DerSurfL.SetValue(3, 0, aD3.D3U);
        DerSurfL.SetValue(2, 1, aD3.D3UUV);
        DerSurfL.SetValue(1, 2, aD3.D3UVV);
        DerSurfL.SetValue(0, 3, aD3.D3V);
        break;
      }
      default:
        break;
    }

    if (theNU <= theNV)
    {
      for (int i = 0; i <= theMaxOrder + 1 + theNU; i++)
        for (int j = i; j <= theMaxOrder + theNV + 1; j++)
          if (i + j > theMinOrder)
          {
            gp_Vec aOscDN   = theOscSurf->EvalDN(theU, theV, i, j);
            gp_Vec aBasisDN = theBasisSurf->EvalDN(theU, theV, i, j);
            DerSurfL.SetValue(i, j, aOscDN);
            theDerSurf.SetValue(i, j, aBasisDN);
            if (i != j && j <= theNU + 1)
            {
              gp_Vec aBasisDNji = theBasisSurf->EvalDN(theU, theV, j, i);
              gp_Vec aOscDNji   = theOscSurf->EvalDN(theU, theV, j, i);
              theDerSurf.SetValue(j, i, aBasisDNji);
              DerSurfL.SetValue(j, i, aOscDNji);
            }
          }
    }
    else
    {
      for (int j = 0; j <= theMaxOrder + 1 + theNV; j++)
        for (int i = j; i <= theMaxOrder + theNU + 1; i++)
          if (i + j > theMinOrder)
          {
            gp_Vec aOscDN   = theOscSurf->EvalDN(theU, theV, i, j);
            gp_Vec aBasisDN = theBasisSurf->EvalDN(theU, theV, i, j);
            DerSurfL.SetValue(i, j, aOscDN);
            theDerSurf.SetValue(i, j, aBasisDN);
            if (i != j && i <= theNV + 1)
            {
              gp_Vec aBasisDNji = theBasisSurf->EvalDN(theU, theV, j, i);
              gp_Vec aOscDNji   = theOscSurf->EvalDN(theU, theV, j, i);
              theDerSurf.SetValue(j, i, aBasisDNji);
              DerSurfL.SetValue(j, i, aOscDNji);
            }
          }
    }
    for (int i = 0; i <= theMaxOrder + theNU; i++)
      for (int j = 0; j <= theMaxOrder + theNV; j++)
      {
        if (theAlongU)
          theDerNUV.SetValue(i, j, CSLib::DNNUV(i, j, DerSurfL, theDerSurf));
        if (theAlongV)
          theDerNUV.SetValue(i, j, CSLib::DNNUV(i, j, theDerSurf, DerSurfL));
      }
  }
  else
  {
    for (int i = 0; i <= theMaxOrder + theNU + 1; i++)
    {
      for (int j = i; j <= theMaxOrder + theNV + 1; j++)
      {
        if (i + j > theMinOrder)
        {
          gp_Vec aDN = theBasisSurf->EvalDN(theU, theV, i, j);
          theDerSurf.SetValue(i, j, aDN);
          if (i != j && j <= theDerSurf.UpperRow() && i <= theDerSurf.UpperCol())
          {
            gp_Vec aDNji = theBasisSurf->EvalDN(theU, theV, j, i);
            theDerSurf.SetValue(j, i, aDNji);
          }
        }
      }
    }
    for (int i = 0; i <= theMaxOrder + theNU; i++)
      for (int j = 0; j <= theMaxOrder + theNV; j++)
        theDerNUV.SetValue(i, j, CSLib::DNNUV(i, j, theDerSurf));
  }
  return true;
}

//! Attempts to replace a zero derivative by stepping away and recomputing.
//! This handles CSLib_InfinityOfSolutions case where one derivative is zero.
//!
//! @tparam BasisSurfType type of basis surface (must have D1 method)
//! @param[in] theU U parameter
//! @param[in] theV V parameter
//! @param[in] theUMin minimum U bound
//! @param[in] theUMax maximum U bound
//! @param[in] theVMin minimum V bound
//! @param[in] theVMax maximum V bound
//! @param[in,out] theDU first derivative with respect to U
//! @param[in,out] theDV first derivative with respect to V
//! @param[in] theSquareTol squared tolerance for zero check
//! @param[in] theBasisSurf basis surface for computing derivatives
//! @return true if derivative was successfully replaced
template <class BasisSurfType>
bool ReplaceDerivative(double               theU,
                       double               theV,
                       double               theUMin,
                       double               theUMax,
                       double               theVMin,
                       double               theVMax,
                       gp_Vec&              theDU,
                       gp_Vec&              theDV,
                       double               theSquareTol,
                       const BasisSurfType& theBasisSurf)
{
  bool isReplaceDU = theDU.SquareMagnitude() < theSquareTol;
  bool isReplaceDV = theDV.SquareMagnitude() < theSquareTol;
  bool isReplaced  = false;

  // Only handle case where exactly one derivative is zero
  if (isReplaceDU != isReplaceDV)
  {
    // Calculate step along non-zero derivative
    double aStep;
    if (isReplaceDV)
    {
      aStep = Precision::Confusion() * theDU.Magnitude();
      if (aStep > theUMax - theUMin)
        aStep = (theUMax - theUMin) / 100.;
    }
    else
    {
      aStep = Precision::Confusion() * theDV.Magnitude();
      if (aStep > theVMax - theVMin)
        aStep = (theVMax - theVMin) / 100.;
    }

    // Step away from current parametric coordinates and calculate derivatives once again.
    // Replace zero derivative by the obtained.
    for (double aStepSign = -1.0; aStepSign <= 1.0 && !isReplaced; aStepSign += 2.0)
    {
      double aU = theU;
      double aV = theV;

      if (isReplaceDV)
      {
        aU = theU + aStepSign * aStep;
        if (aU < theUMin || aU > theUMax)
          continue;
      }
      else
      {
        aV = theV + aStepSign * aStep;
        if (aV < theVMin || aV > theVMax)
          continue;
      }

      Geom_Surface::ResD1 aD1Result = theBasisSurf->EvalD1(aU, aV);

      if (isReplaceDU && aD1Result.D1U.SquareMagnitude() > theSquareTol)
      {
        theDU      = aD1Result.D1U;
        isReplaced = true;
      }
      if (isReplaceDV && aD1Result.D1V.SquareMagnitude() > theSquareTol)
      {
        theDV      = aD1Result.D1V;
        isReplaced = true;
      }
    }
  }
  return isReplaced;
}

//! Attempts to shift the evaluation point towards the center of the parametric space.
//! This is used when normal calculation fails at singular points near boundaries.
//! The point is shifted iteratively, each time doubling the distance from the start point.
//!
//! @param[in] theUStart original U parameter (for direction calculation)
//! @param[in] theVStart original V parameter (for direction calculation)
//! @param[in,out] theU current U parameter, modified on success
//! @param[in,out] theV current V parameter, modified on success
//! @param[in] theUMin minimum U bound
//! @param[in] theUMax maximum U bound
//! @param[in] theVMin minimum V bound
//! @param[in] theVMax maximum V bound
//! @param[in] theIsUPeriodic true if surface is U-periodic
//! @param[in] theIsVPeriodic true if surface is V-periodic
//! @param[in] theD1U first derivative with respect to U (for singularity check)
//! @param[in] theD1V first derivative with respect to V (for singularity check)
//! @return true if shift was successful, false if center is reached
inline bool ShiftPoint(double        theUStart,
                       double        theVStart,
                       double&       theU,
                       double&       theV,
                       double        theUMin,
                       double        theUMax,
                       double        theVMin,
                       double        theVMax,
                       bool          theIsUPeriodic,
                       bool          theIsVPeriodic,
                       const gp_Vec& theD1U,
                       const gp_Vec& theD1V)
{
  // Check if either U or V is singular (normally one of them is)
  bool isUSingular = (theD1U.SquareMagnitude() < THE_D1_MAGNITUDE_TOL * THE_D1_MAGNITUDE_TOL);
  bool isVSingular = (theD1V.SquareMagnitude() < THE_D1_MAGNITUDE_TOL * THE_D1_MAGNITUDE_TOL);

  // Compute vector to shift from start point to center of the surface;
  // if surface is periodic or singular in some direction, take shift in that direction zero
  double aDirU =
    (theIsUPeriodic || (isUSingular && !isVSingular) ? 0. : 0.5 * (theUMin + theUMax) - theUStart);
  double aDirV =
    (theIsVPeriodic || (isVSingular && !isUSingular) ? 0. : 0.5 * (theVMin + theVMax) - theVStart);
  double aDist = std::sqrt(aDirU * aDirU + aDirV * aDirV);

  // Shift current point from its current position towards center, by value of twice
  // current distance from it to start (but not less than Precision::PConfusion());
  // fail if center is overpassed.
  double aDU   = theU - theUStart;
  double aDV   = theV - theVStart;
  double aStep = std::max(2. * std::sqrt(aDU * aDU + aDV * aDV), Precision::PConfusion());
  if (aStep >= aDist)
  {
    return false;
  }

  aStep /= aDist;
  theU += aDirU * aStep;
  theV += aDirV * aStep;

  return true;
}

//! Template function for D0 evaluation with pre-computed basis surface D1.
//! When normal calculation fails at singular points, falls back to full evaluation
//! with retry mechanism.
//!
//! @tparam BasisSurfType type of basis surface (must have D1 method)
//! @tparam OscSurfQueryType type providing osculating surface query
//! @param[in] theU U parameter
//! @param[in] theV V parameter
//! @param[in] theBasisSurf basis surface adaptor
//! @param[in] theOffset offset distance
//! @param[in] theOscQuery osculating surface query object (may be null)
//! @param[in,out] theValue on input: basis surface point; on output: offset point
//! @param[in] theD1U pre-computed basis surface D1U (used for first iteration)
//! @param[in] theD1V pre-computed basis surface D1V (used for first iteration)
//! @return true if calculation succeeded, false if failed at singular point
template <class BasisSurfType, class OscSurfQueryType>
bool EvaluateD0(double                  theU,
                double                  theV,
                const BasisSurfType&    theBasisSurf,
                double                  theOffset,
                const OscSurfQueryType& theOscQuery,
                gp_Pnt&                 theValue,
                const gp_Vec&           theD1U,
                const gp_Vec&           theD1V)
{
  const double aUStart = theU;
  const double aVStart = theV;
  double       aUMin, aUMax, aVMin, aVMax;
  theBasisSurf->Bounds(aUMin, aUMax, aVMin, aVMax);
  const bool isUPer = theBasisSurf->IsUPeriodic();
  const bool isVPer = theBasisSurf->IsVPeriodic();

  // Use pre-computed D1 for first iteration
  gp_Vec aD1U             = theD1U;
  gp_Vec aD1V             = theD1V;
  bool   isFirstIteration = true;

  for (;;)
  {
    // For subsequent iterations, recompute D1 at shifted point
    if (!isFirstIteration)
    {
      Geom_Surface::ResD1 aD1Result = theBasisSurf->EvalD1(theU, theV);
      theValue                      = aD1Result.Point;
      aD1U                          = aD1Result.D1U;
      aD1V                          = aD1Result.D1V;
    }
    isFirstIteration = false;

    if (IsInfiniteCoord(aD1U) || IsInfiniteCoord(aD1V))
    {
      return false;
    }

    // Try non-singular case first
    if (CalculateD0(theValue, aD1U, aD1V, theOffset))
    {
      return true;
    }

    // Singular case - query osculating surface and use higher order derivatives
    constexpr int aMaxOrder = 3;

    OsculatingInfo                   aOscInfo;
    occ::handle<Geom_BSplineSurface> aOscSurf;
    if (theOscQuery)
    {
      aOscInfo.AlongU = theOscQuery->UOsculatingSurface(theU, theV, aOscInfo.IsOpposite, aOscSurf);
      aOscInfo.AlongV = theOscQuery->VOsculatingSurface(theU, theV, aOscInfo.IsOpposite, aOscSurf);
    }

    constexpr int aDerNUVSize  = (aMaxOrder + 1) * (aMaxOrder + 1); // 16
    constexpr int aDerSurfSize = (aMaxOrder + 2) * (aMaxOrder + 2); // 25
    NCollection_LocalArray<gp_Vec, aDerNUVSize>  aDerNUVBuffer(aDerNUVSize);
    NCollection_LocalArray<gp_Vec, aDerSurfSize> aDerSurfBuffer(aDerSurfSize);
    NCollection_Array2<gp_Vec> aDerNUV(aDerNUVBuffer[0], 0, aMaxOrder, 0, aMaxOrder);
    NCollection_Array2<gp_Vec> aDerSurf(aDerSurfBuffer[0], 0, aMaxOrder + 1, 0, aMaxOrder + 1);

    aDerSurf.SetValue(1, 0, aD1U);
    aDerSurf.SetValue(0, 1, aD1V);

    // Use ComputeDerivatives which handles osculating surface properly
    if (aOscInfo.HasOsculating() && !aOscSurf.IsNull())
    {
      if (!ComputeDerivatives(aMaxOrder,
                              1,
                              theU,
                              theV,
                              theBasisSurf,
                              0,
                              0,
                              aOscInfo.AlongU,
                              aOscInfo.AlongV,
                              aOscSurf,
                              aDerNUV,
                              aDerSurf))
        return false;
    }
    else
    {
      occ::handle<Geom_BSplineSurface> aDummy;
      if (!ComputeDerivatives(aMaxOrder,
                              1,
                              theU,
                              theV,
                              theBasisSurf,
                              0,
                              0,
                              false,
                              false,
                              aDummy,
                              aDerNUV,
                              aDerSurf))
        return false;
    }

    gp_Dir             aNormal;
    CSLib_NormalStatus aNStatus;
    int                OrderU, OrderV;
    CSLib::Normal(aMaxOrder,
                  aDerNUV,
                  THE_D1_MAGNITUDE_TOL,
                  theU,
                  theV,
                  aUMin,
                  aUMax,
                  aVMin,
                  aVMax,
                  aNStatus,
                  aNormal,
                  OrderU,
                  OrderV);

    // Handle CSLib_InfinityOfSolutions by replacing zero derivative
    if (aNStatus == CSLib_InfinityOfSolutions)
    {
      gp_Vec aNewDU = aD1U;
      gp_Vec aNewDV = aD1V;
      if (ReplaceDerivative(theU,
                            theV,
                            aUMin,
                            aUMax,
                            aVMin,
                            aVMax,
                            aNewDU,
                            aNewDV,
                            THE_D1_MAGNITUDE_TOL * THE_D1_MAGNITUDE_TOL,
                            theBasisSurf))
      {
        CSLib::Normal(aNewDU, aNewDV, THE_D1_MAGNITUDE_TOL, aNStatus, aNormal);
      }
    }

    if (aNStatus == CSLib_Defined)
    {
      theValue.SetXYZ(theValue.XYZ() + theOffset * aOscInfo.Sign() * aNormal.XYZ());
      return true;
    }

    // Try shifting point towards center - returns false when center is overpassed
    if (!ShiftPoint(aUStart,
                    aVStart,
                    theU,
                    theV,
                    aUMin,
                    aUMax,
                    aVMin,
                    aVMax,
                    isUPer,
                    isVPer,
                    aD1U,
                    aD1V))
    {
      return false;
    }
  }
}

//! Template function for D0 evaluation with retry mechanism for singular points.
//! When normal calculation fails, attempts to shift the point towards the center
//! and retry the calculation.
//!
//! @tparam BasisSurfType type of basis surface (must have D1 method)
//! @tparam OscSurfQueryType type providing osculating surface query
//! @param[in] theU U parameter
//! @param[in] theV V parameter
//! @param[in] theBasisSurf basis surface adaptor
//! @param[in] theOffset offset distance
//! @param[in] theOscQuery osculating surface query object (may be null)
//! @param[out] theValue computed offset point
//! @return true if calculation succeeded, false if failed at singular point
template <class BasisSurfType, class OscSurfQueryType>
bool EvaluateD0(double                  theU,
                double                  theV,
                const BasisSurfType&    theBasisSurf,
                double                  theOffset,
                const OscSurfQueryType& theOscQuery,
                gp_Pnt&                 theValue)
{
  Geom_Surface::ResD1 aBasisD1 = theBasisSurf->EvalD1(theU, theV);
  theValue                     = aBasisD1.Point;
  return EvaluateD0(theU,
                    theV,
                    theBasisSurf,
                    theOffset,
                    theOscQuery,
                    theValue,
                    aBasisD1.D1U,
                    aBasisD1.D1V);
}

//! Template function for D1 evaluation with pre-computed basis surface D2.
//! When normal calculation fails at singular points, falls back to full evaluation
//! with retry mechanism.
//!
//! @tparam BasisSurfType type of basis surface (must have D2 method)
//! @tparam OscSurfQueryType type providing osculating surface query
//! @param[in] theU U parameter
//! @param[in] theV V parameter
//! @param[in] theBasisSurf basis surface adaptor
//! @param[in] theOffset offset distance
//! @param[in] theOscQuery osculating surface query object (may be null)
//! @param[in,out] theValue on input: basis surface point; on output: offset point
//! @param[in,out] theD1U on input: pre-computed basis D1U; on output: offset D1U
//! @param[in,out] theD1V on input: pre-computed basis D1V; on output: offset D1V
//! @param[in] theD2U pre-computed basis surface D2U (used for first iteration)
//! @param[in] theD2V pre-computed basis surface D2V (used for first iteration)
//! @param[in] theD2UV pre-computed basis surface D2UV (used for first iteration)
//! @return true if calculation succeeded, false if failed at singular point
template <class BasisSurfType, class OscSurfQueryType>
bool EvaluateD1(double                  theU,
                double                  theV,
                const BasisSurfType&    theBasisSurf,
                double                  theOffset,
                const OscSurfQueryType& theOscQuery,
                gp_Pnt&                 theValue,
                gp_Vec&                 theD1U,
                gp_Vec&                 theD1V,
                const gp_Vec&           theD2U,
                const gp_Vec&           theD2V,
                const gp_Vec&           theD2UV)
{
  const double aUStart = theU;
  const double aVStart = theV;
  double       aUMin, aUMax, aVMin, aVMax;
  theBasisSurf->Bounds(aUMin, aUMax, aVMin, aVMax);
  const bool isUPer = theBasisSurf->IsUPeriodic();
  const bool isVPer = theBasisSurf->IsVPeriodic();

  // Use pre-computed D2 for first iteration
  gp_Vec aD2U             = theD2U;
  gp_Vec aD2V             = theD2V;
  gp_Vec aD2UV            = theD2UV;
  bool   isFirstIteration = true;

  for (;;)
  {
    // For subsequent iterations, recompute D2 at shifted point
    if (!isFirstIteration)
    {
      Geom_Surface::ResD2 aD2Result = theBasisSurf->EvalD2(theU, theV);
      theValue                      = aD2Result.Point;
      theD1U                        = aD2Result.D1U;
      theD1V                        = aD2Result.D1V;
      aD2U                          = aD2Result.D2U;
      aD2V                          = aD2Result.D2V;
      aD2UV                         = aD2Result.D2UV;
    }
    isFirstIteration = false;

    if (IsInfiniteCoord(theD1U) || IsInfiniteCoord(theD1V))
    {
      return false;
    }

    // Check if singular by normalizing derivatives and computing cross product
    gp_Vec aD1U(theD1U);
    gp_Vec aD1V(theD1V);
    double aD1UNorm2 = aD1U.SquareMagnitude();
    double aD1VNorm2 = aD1V.SquareMagnitude();
    if (aD1UNorm2 > 1.0)
      aD1U /= std::sqrt(aD1UNorm2);
    if (aD1VNorm2 > 1.0)
      aD1V /= std::sqrt(aD1VNorm2);

    bool      isSingular = false;
    const int aMaxOrder  = 3;
    gp_Vec    aNorm      = aD1U.Crossed(aD1V);

    // Query osculating surface only if singular
    OsculatingInfo                   aOscInfo;
    occ::handle<Geom_BSplineSurface> aOscSurf;
    if (aNorm.SquareMagnitude() <= THE_D1_MAGNITUDE_TOL * THE_D1_MAGNITUDE_TOL)
    {
      if (theOscQuery)
      {
        aOscInfo.AlongU =
          theOscQuery->UOsculatingSurface(theU, theV, aOscInfo.IsOpposite, aOscSurf);
        aOscInfo.AlongV =
          theOscQuery->VOsculatingSurface(theU, theV, aOscInfo.IsOpposite, aOscSurf);
      }
      isSingular = true;
    }

    // Compute sign factor
    const double aSign = aOscInfo.Sign();

    // Non-singular case: use direct formulas
    if (!isSingular)
    {
      aNorm.Normalize();
      theValue.SetXYZ(theValue.XYZ() + theOffset * aSign * aNorm.XYZ());

      // Compute normal derivatives using inline formulas
      gp_Vec       aN0(aNorm.XYZ()), aN1U, aN1V;
      const double aScale = (theD1U ^ theD1V).Dot(aN0);
      aN1U.SetX(aD2U.Y() * theD1V.Z() + theD1U.Y() * aD2UV.Z() - aD2U.Z() * theD1V.Y()
                - theD1U.Z() * aD2UV.Y());
      aN1U.SetY((aD2U.X() * theD1V.Z() + theD1U.X() * aD2UV.Z() - aD2U.Z() * theD1V.X()
                 - theD1U.Z() * aD2UV.X())
                * -1.0);
      aN1U.SetZ(aD2U.X() * theD1V.Y() + theD1U.X() * aD2UV.Y() - aD2U.Y() * theD1V.X()
                - theD1U.Y() * aD2UV.X());
      const double aScaleU = aN1U.Dot(aN0);
      aN1U.Subtract(aScaleU * aN0);
      aN1U /= aScale;

      aN1V.SetX(aD2UV.Y() * theD1V.Z() + aD2V.Z() * theD1U.Y() - aD2UV.Z() * theD1V.Y()
                - aD2V.Y() * theD1U.Z());
      aN1V.SetY((aD2UV.X() * theD1V.Z() + aD2V.Z() * theD1U.X() - aD2UV.Z() * theD1V.X()
                 - aD2V.X() * theD1U.Z())
                * -1.0);
      aN1V.SetZ(aD2UV.X() * theD1V.Y() + aD2V.Y() * theD1U.X() - aD2UV.Y() * theD1V.X()
                - aD2V.X() * theD1U.Y());
      const double aScaleV = aN1V.Dot(aN0);
      aN1V.Subtract(aScaleV * aN0);
      aN1V /= aScale;

      theD1U += theOffset * aSign * aN1U;
      theD1V += theOffset * aSign * aN1V;

      return true;
    }

    // Singular case - use higher order derivatives
    constexpr int aDerNUVSize  = (aMaxOrder + 2) * (aMaxOrder + 2); // 25
    constexpr int aDerSurfSize = (aMaxOrder + 3) * (aMaxOrder + 3); // 36
    NCollection_LocalArray<gp_Vec, aDerNUVSize>  aDerNUVBuffer(aDerNUVSize);
    NCollection_LocalArray<gp_Vec, aDerSurfSize> aDerSurfBuffer(aDerSurfSize);
    NCollection_Array2<gp_Vec> aDerNUV(aDerNUVBuffer[0], 0, aMaxOrder + 1, 0, aMaxOrder + 1);
    NCollection_Array2<gp_Vec> aDerSurf(aDerSurfBuffer[0], 0, aMaxOrder + 2, 0, aMaxOrder + 2);

    aDerSurf.SetValue(1, 0, theD1U);
    aDerSurf.SetValue(0, 1, theD1V);
    aDerSurf.SetValue(1, 1, aD2UV);
    aDerSurf.SetValue(2, 0, aD2U);
    aDerSurf.SetValue(0, 2, aD2V);

    if (aOscInfo.HasOsculating() && !aOscSurf.IsNull())
    {
      if (!ComputeDerivatives(aMaxOrder,
                              2,
                              theU,
                              theV,
                              theBasisSurf,
                              1,
                              1,
                              aOscInfo.AlongU,
                              aOscInfo.AlongV,
                              aOscSurf,
                              aDerNUV,
                              aDerSurf))
        return false;
    }
    else
    {
      occ::handle<Geom_BSplineSurface> aDummy;
      if (!ComputeDerivatives(aMaxOrder,
                              2,
                              theU,
                              theV,
                              theBasisSurf,
                              1,
                              1,
                              false,
                              false,
                              aDummy,
                              aDerNUV,
                              aDerSurf))
        return false;
    }

    gp_Dir             aNormal;
    CSLib_NormalStatus aNStatus;
    int                aOrderU, aOrderV;
    CSLib::Normal(aMaxOrder,
                  aDerNUV,
                  THE_D1_MAGNITUDE_TOL,
                  theU,
                  theV,
                  aUMin,
                  aUMax,
                  aVMin,
                  aVMax,
                  aNStatus,
                  aNormal,
                  aOrderU,
                  aOrderV);

    // Handle CSLib_InfinityOfSolutions by replacing zero derivative
    if (aNStatus == CSLib_InfinityOfSolutions)
    {
      gp_Vec aNewDU = theD1U;
      gp_Vec aNewDV = theD1V;
      if (ReplaceDerivative(theU,
                            theV,
                            aUMin,
                            aUMax,
                            aVMin,
                            aVMax,
                            aNewDU,
                            aNewDV,
                            THE_D1_MAGNITUDE_TOL * THE_D1_MAGNITUDE_TOL,
                            theBasisSurf))
      {
        // Re-compute with replaced derivatives
        aDerSurf.SetValue(1, 0, aNewDU);
        aDerSurf.SetValue(0, 1, aNewDV);
        if (aOscInfo.HasOsculating() && !aOscSurf.IsNull())
        {
          if (!ComputeDerivatives(aMaxOrder,
                                  2,
                                  theU,
                                  theV,
                                  theBasisSurf,
                                  1,
                                  1,
                                  aOscInfo.AlongU,
                                  aOscInfo.AlongV,
                                  aOscSurf,
                                  aDerNUV,
                                  aDerSurf))
            return false;
        }
        else
        {
          occ::handle<Geom_BSplineSurface> aDummy;
          if (!ComputeDerivatives(aMaxOrder,
                                  2,
                                  theU,
                                  theV,
                                  theBasisSurf,
                                  1,
                                  1,
                                  false,
                                  false,
                                  aDummy,
                                  aDerNUV,
                                  aDerSurf))
            return false;
        }
        CSLib::Normal(aMaxOrder,
                      aDerNUV,
                      THE_D1_MAGNITUDE_TOL,
                      theU,
                      theV,
                      aUMin,
                      aUMax,
                      aVMin,
                      aVMax,
                      aNStatus,
                      aNormal,
                      aOrderU,
                      aOrderV);
      }
    }

    if (aNStatus == CSLib_Defined)
    {
      // Compute offset point
      theValue.SetXYZ(theValue.XYZ() + theOffset * aSign * aNormal.XYZ());
      // Compute D1 using CSLib
      theD1U = CSLib::DNNormal(1, 0, aDerNUV, aOrderU, aOrderV);
      theD1V = CSLib::DNNormal(0, 1, aDerNUV, aOrderU, aOrderV);

      theD1U.Multiply(theOffset * aSign);
      theD1U.Add(aDerSurf(1, 0));
      theD1V.Multiply(theOffset * aSign);
      theD1V.Add(aDerSurf(0, 1));
      return true;
    }

    // Try shifting point towards center - returns false when center is overpassed
    if (!ShiftPoint(aUStart,
                    aVStart,
                    theU,
                    theV,
                    aUMin,
                    aUMax,
                    aVMin,
                    aVMax,
                    isUPer,
                    isVPer,
                    theD1U,
                    theD1V))
    {
      return false;
    }
  }
}

//! Template function for D1 evaluation with retry mechanism for singular points.
//! Computes D2 internally and calls the pre-computed overload.
//!
//! @tparam BasisSurfType type of basis surface (must have D2 method)
//! @tparam OscSurfQueryType type providing osculating surface query
//! @param[in] theU U parameter
//! @param[in] theV V parameter
//! @param[in] theBasisSurf basis surface adaptor
//! @param[in] theOffset offset distance
//! @param[in] theOscQuery osculating surface query object (may be null)
//! @param[out] theValue computed offset point
//! @param[out] theD1U computed D1U derivative
//! @param[out] theD1V computed D1V derivative
//! @return true if calculation succeeded, false if failed at singular point
template <class BasisSurfType, class OscSurfQueryType>
bool EvaluateD1(double                  theU,
                double                  theV,
                const BasisSurfType&    theBasisSurf,
                double                  theOffset,
                const OscSurfQueryType& theOscQuery,
                gp_Pnt&                 theValue,
                gp_Vec&                 theD1U,
                gp_Vec&                 theD1V)
{
  Geom_Surface::ResD2 aBasisD2 = theBasisSurf->EvalD2(theU, theV);
  theValue                     = aBasisD2.Point;
  theD1U                       = aBasisD2.D1U;
  theD1V                       = aBasisD2.D1V;
  return EvaluateD1(theU,
                    theV,
                    theBasisSurf,
                    theOffset,
                    theOscQuery,
                    theValue,
                    theD1U,
                    theD1V,
                    aBasisD2.D2U,
                    aBasisD2.D2V,
                    aBasisD2.D2UV);
}

//! Template function for D2 evaluation with pre-computed basis surface D3.
//! When normal calculation fails at singular points, falls back to full evaluation
//! with retry mechanism.
//!
//! @tparam BasisSurfType type of basis surface (must have D3 method)
//! @tparam OscSurfQueryType type providing osculating surface query
//! @param[in] theU U parameter
//! @param[in] theV V parameter
//! @param[in] theBasisSurf basis surface adaptor
//! @param[in] theOffset offset distance
//! @param[in] theOscQuery osculating surface query object (may be null)
//! @param[in,out] theValue on input: basis surface point; on output: offset point
//! @param[in,out] theD1U on input: pre-computed basis D1U; on output: offset D1U
//! @param[in,out] theD1V on input: pre-computed basis D1V; on output: offset D1V
//! @param[in,out] theD2U on input: pre-computed basis D2U; on output: offset D2U
//! @param[in,out] theD2V on input: pre-computed basis D2V; on output: offset D2V
//! @param[in,out] theD2UV on input: pre-computed basis D2UV; on output: offset D2UV
//! @param[in] theD3U pre-computed basis surface D3U (used for first iteration)
//! @param[in] theD3V pre-computed basis surface D3V (used for first iteration)
//! @param[in] theD3UUV pre-computed basis surface D3UUV (used for first iteration)
//! @param[in] theD3UVV pre-computed basis surface D3UVV (used for first iteration)
//! @return true if calculation succeeded, false if failed at singular point
template <class BasisSurfType, class OscSurfQueryType>
bool EvaluateD2(double                  theU,
                double                  theV,
                const BasisSurfType&    theBasisSurf,
                double                  theOffset,
                const OscSurfQueryType& theOscQuery,
                gp_Pnt&                 theValue,
                gp_Vec&                 theD1U,
                gp_Vec&                 theD1V,
                gp_Vec&                 theD2U,
                gp_Vec&                 theD2V,
                gp_Vec&                 theD2UV,
                const gp_Vec&           theD3U,
                const gp_Vec&           theD3V,
                const gp_Vec&           theD3UUV,
                const gp_Vec&           theD3UVV)
{
  const double aUStart = theU;
  const double aVStart = theV;
  double       aUMin, aUMax, aVMin, aVMax;
  theBasisSurf->Bounds(aUMin, aUMax, aVMin, aVMax);
  const bool isUPer = theBasisSurf->IsUPeriodic();
  const bool isVPer = theBasisSurf->IsVPeriodic();

  // Use pre-computed D3 for first iteration
  gp_Vec aD3U             = theD3U;
  gp_Vec aD3V             = theD3V;
  gp_Vec aD3UUV           = theD3UUV;
  gp_Vec aD3UVV           = theD3UVV;
  bool   isFirstIteration = true;

  for (;;)
  {
    // For subsequent iterations, recompute D3 at shifted point
    if (!isFirstIteration)
    {
      Geom_Surface::ResD3 aD3Result = theBasisSurf->EvalD3(theU, theV);
      theValue                      = aD3Result.Point;
      theD1U                        = aD3Result.D1U;
      theD1V                        = aD3Result.D1V;
      theD2U                        = aD3Result.D2U;
      theD2V                        = aD3Result.D2V;
      theD2UV                       = aD3Result.D2UV;
      aD3U                          = aD3Result.D3U;
      aD3V                          = aD3Result.D3V;
      aD3UUV                        = aD3Result.D3UUV;
      aD3UVV                        = aD3Result.D3UVV;
    }
    isFirstIteration = false;

    if (IsInfiniteCoord(theD1U) || IsInfiniteCoord(theD1V))
    {
      return false;
    }

    // Check if singular using CSLib::Normal
    gp_Dir             aNormal;
    CSLib_NormalStatus aNStatus;
    CSLib::Normal(theD1U, theD1V, THE_D1_MAGNITUDE_TOL, aNStatus, aNormal);

    // MaxOrder = 0 for non-singular, 3 for singular
    const int aMaxOrder = (aNStatus == CSLib_Defined) ? 0 : 3;

    // Get osculating surface info
    OsculatingInfo                   aOscInfo;
    occ::handle<Geom_BSplineSurface> aOscSurf;
    if ((aNStatus != CSLib_Defined) && theOscQuery)
    {
      aOscInfo.AlongU = theOscQuery->UOsculatingSurface(theU, theV, aOscInfo.IsOpposite, aOscSurf);
      aOscInfo.AlongV = theOscQuery->VOsculatingSurface(theU, theV, aOscInfo.IsOpposite, aOscSurf);
    }

    // Setup derivative arrays
    const int                          aDerNUVSize  = (aMaxOrder + 3) * (aMaxOrder + 3);
    const int                          aDerSurfSize = (aMaxOrder + 4) * (aMaxOrder + 4);
    NCollection_LocalArray<gp_Vec, 36> aDerNUVBuffer(aDerNUVSize);
    NCollection_LocalArray<gp_Vec, 49> aDerSurfBuffer(aDerSurfSize);
    NCollection_Array2<gp_Vec> aDerNUV(aDerNUVBuffer[0], 0, aMaxOrder + 2, 0, aMaxOrder + 2);
    NCollection_Array2<gp_Vec> aDerSurf(aDerSurfBuffer[0], 0, aMaxOrder + 3, 0, aMaxOrder + 3);

    aDerSurf.SetValue(1, 0, theD1U);
    aDerSurf.SetValue(0, 1, theD1V);
    aDerSurf.SetValue(1, 1, theD2UV);
    aDerSurf.SetValue(2, 0, theD2U);
    aDerSurf.SetValue(0, 2, theD2V);
    aDerSurf.SetValue(3, 0, aD3U);
    aDerSurf.SetValue(2, 1, aD3UUV);
    aDerSurf.SetValue(1, 2, aD3UVV);
    aDerSurf.SetValue(0, 3, aD3V);

    // Use ComputeDerivatives to populate DerNUV
    if (aOscInfo.HasOsculating() && !aOscSurf.IsNull())
    {
      if (!ComputeDerivatives(aMaxOrder,
                              3,
                              theU,
                              theV,
                              theBasisSurf,
                              2,
                              2,
                              aOscInfo.AlongU,
                              aOscInfo.AlongV,
                              aOscSurf,
                              aDerNUV,
                              aDerSurf))
        return false;
    }
    else
    {
      occ::handle<Geom_BSplineSurface> aDummy;
      if (!ComputeDerivatives(aMaxOrder,
                              3,
                              theU,
                              theV,
                              theBasisSurf,
                              2,
                              2,
                              false,
                              false,
                              aDummy,
                              aDerNUV,
                              aDerSurf))
        return false;
    }

    // Compute normal using CSLib (second call with MaxOrder)
    int aOrderU, aOrderV;
    CSLib::Normal(aMaxOrder,
                  aDerNUV,
                  THE_D1_MAGNITUDE_TOL,
                  theU,
                  theV,
                  aUMin,
                  aUMax,
                  aVMin,
                  aVMax,
                  aNStatus,
                  aNormal,
                  aOrderU,
                  aOrderV);

    if (aNStatus == CSLib_Defined)
    {
      const double aSign = theOffset * aOscInfo.Sign();

      // Compute offset point
      theValue.SetXYZ(theValue.XYZ() + aSign * aNormal.XYZ());

      // Compute D1 using CSLib::DNNormal
      theD1U =
        aDerSurf(1, 0).Added(CSLib::DNNormal(1, 0, aDerNUV, aOrderU, aOrderV).Multiplied(aSign));
      theD1V =
        aDerSurf(0, 1).Added(CSLib::DNNormal(0, 1, aDerNUV, aOrderU, aOrderV).Multiplied(aSign));

      // For D2, re-fetch from basis surface
      gp_Vec aDN20 = theBasisSurf->EvalDN(theU, theV, 2, 0);
      gp_Vec aDN02 = theBasisSurf->EvalDN(theU, theV, 0, 2);
      gp_Vec aDN11 = theBasisSurf->EvalDN(theU, theV, 1, 1);
      theD2U       = aDN20;
      theD2V       = aDN02;
      theD2UV      = aDN11;

      // Add offset corrections using CSLib::DNNormal
      theD2U.Add(CSLib::DNNormal(2, 0, aDerNUV, aOrderU, aOrderV).Multiplied(aSign));
      theD2V.Add(CSLib::DNNormal(0, 2, aDerNUV, aOrderU, aOrderV).Multiplied(aSign));
      theD2UV.Add(CSLib::DNNormal(1, 1, aDerNUV, aOrderU, aOrderV).Multiplied(aSign));
      return true;
    }

    // Try shifting point towards center - returns false when center is overpassed
    if (!ShiftPoint(aUStart,
                    aVStart,
                    theU,
                    theV,
                    aUMin,
                    aUMax,
                    aVMin,
                    aVMax,
                    isUPer,
                    isVPer,
                    theD1U,
                    theD1V))
    {
      return false;
    }
  }
}

//! Template function for D2 evaluation with retry mechanism for singular points.
//! Computes D3 internally and calls the pre-computed overload.
//!
//! @tparam BasisSurfType type of basis surface (must have D3 method)
//! @tparam OscSurfQueryType type providing osculating surface query
//! @param[in] theU U parameter
//! @param[in] theV V parameter
//! @param[in] theBasisSurf basis surface adaptor
//! @param[in] theOffset offset distance
//! @param[in] theOscQuery osculating surface query object (may be null)
//! @param[out] theValue computed offset point
//! @param[out] theD1U computed D1U derivative
//! @param[out] theD1V computed D1V derivative
//! @param[out] theD2U computed D2U derivative
//! @param[out] theD2V computed D2V derivative
//! @param[out] theD2UV computed D2UV derivative
//! @return true if calculation succeeded, false if failed at singular point
template <class BasisSurfType, class OscSurfQueryType>
bool EvaluateD2(double                  theU,
                double                  theV,
                const BasisSurfType&    theBasisSurf,
                double                  theOffset,
                const OscSurfQueryType& theOscQuery,
                gp_Pnt&                 theValue,
                gp_Vec&                 theD1U,
                gp_Vec&                 theD1V,
                gp_Vec&                 theD2U,
                gp_Vec&                 theD2V,
                gp_Vec&                 theD2UV)
{
  Geom_Surface::ResD3 aBasisD3 = theBasisSurf->EvalD3(theU, theV);
  theValue                     = aBasisD3.Point;
  theD1U                       = aBasisD3.D1U;
  theD1V                       = aBasisD3.D1V;
  theD2U                       = aBasisD3.D2U;
  theD2V                       = aBasisD3.D2V;
  theD2UV                      = aBasisD3.D2UV;
  return EvaluateD2(theU,
                    theV,
                    theBasisSurf,
                    theOffset,
                    theOscQuery,
                    theValue,
                    theD1U,
                    theD1V,
                    theD2U,
                    theD2V,
                    theD2UV,
                    aBasisD3.D3U,
                    aBasisD3.D3V,
                    aBasisD3.D3UUV,
                    aBasisD3.D3UVV);
}

//! Template function for D3 evaluation with retry mechanism for singular points.
//!
//! @tparam BasisSurfType type of basis surface (must have D3 method)
//! @tparam OscSurfQueryType type providing osculating surface query
//! @param[in] theU U parameter
//! @param[in] theV V parameter
//! @param[in] theBasisSurf basis surface adaptor
//! @param[in] theOffset offset distance
//! @param[in] theOscQuery osculating surface query object (may be null)
//! @param[out] theValue computed offset point
//! @param[out] theD1U computed D1U derivative
//! @param[out] theD1V computed D1V derivative
//! @param[out] theD2U computed D2U derivative
//! @param[out] theD2V computed D2V derivative
//! @param[out] theD2UV computed D2UV derivative
//! @param[out] theD3U computed D3U derivative
//! @param[out] theD3V computed D3V derivative
//! @param[out] theD3UUV computed D3UUV derivative
//! @param[out] theD3UVV computed D3UVV derivative
//! @return true if calculation succeeded, false if failed at singular point
template <class BasisSurfType, class OscSurfQueryType>
bool EvaluateD3(double                  theU,
                double                  theV,
                const BasisSurfType&    theBasisSurf,
                double                  theOffset,
                const OscSurfQueryType& theOscQuery,
                gp_Pnt&                 theValue,
                gp_Vec&                 theD1U,
                gp_Vec&                 theD1V,
                gp_Vec&                 theD2U,
                gp_Vec&                 theD2V,
                gp_Vec&                 theD2UV,
                gp_Vec&                 theD3U,
                gp_Vec&                 theD3V,
                gp_Vec&                 theD3UUV,
                gp_Vec&                 theD3UVV)
{
  const double aUStart = theU;
  const double aVStart = theV;
  double       aUMin, aUMax, aVMin, aVMax;
  theBasisSurf->Bounds(aUMin, aUMax, aVMin, aVMax);
  const bool isUPer = theBasisSurf->IsUPeriodic();
  const bool isVPer = theBasisSurf->IsVPeriodic();

  for (;;)
  {
    Geom_Surface::ResD3 aD3Result = theBasisSurf->EvalD3(theU, theV);
    theValue                      = aD3Result.Point;
    theD1U                        = aD3Result.D1U;
    theD1V                        = aD3Result.D1V;
    theD2U                        = aD3Result.D2U;
    theD2V                        = aD3Result.D2V;
    theD2UV                       = aD3Result.D2UV;
    theD3U                        = aD3Result.D3U;
    theD3V                        = aD3Result.D3V;
    theD3UUV                      = aD3Result.D3UUV;
    theD3UVV                      = aD3Result.D3UVV;

    if (IsInfiniteCoord(theD1U) || IsInfiniteCoord(theD1V))
    {
      return false;
    }

    // Check if singular using CSLib::Normal
    gp_Dir             aNormal;
    CSLib_NormalStatus aNStatus;
    CSLib::Normal(theD1U, theD1V, THE_D1_MAGNITUDE_TOL, aNStatus, aNormal);

    // MaxOrder = 0 for non-singular, 3 for singular
    const int aMaxOrder = (aNStatus == CSLib_Defined) ? 0 : 3;

    // Get osculating surface info
    OsculatingInfo                   aOscInfo;
    occ::handle<Geom_BSplineSurface> aOscSurf;
    if ((aNStatus != CSLib_Defined) && theOscQuery)
    {
      aOscInfo.AlongU = theOscQuery->UOsculatingSurface(theU, theV, aOscInfo.IsOpposite, aOscSurf);
      aOscInfo.AlongV = theOscQuery->VOsculatingSurface(theU, theV, aOscInfo.IsOpposite, aOscSurf);
    }

    // Setup derivative arrays
    // For D3: DerNUV needs (aMaxOrder + 4), DerSurf needs (aMaxOrder + 5)
    const int                          aDerNUVSize  = (aMaxOrder + 4) * (aMaxOrder + 4);
    const int                          aDerSurfSize = (aMaxOrder + 5) * (aMaxOrder + 5);
    NCollection_LocalArray<gp_Vec, 49> aDerNUVBuffer(aDerNUVSize);
    NCollection_LocalArray<gp_Vec, 64> aDerSurfBuffer(aDerSurfSize);
    NCollection_Array2<gp_Vec> aDerNUV(aDerNUVBuffer[0], 0, aMaxOrder + 3, 0, aMaxOrder + 3);
    NCollection_Array2<gp_Vec> aDerSurf(aDerSurfBuffer[0], 0, aMaxOrder + 4, 0, aMaxOrder + 4);

    aDerSurf.SetValue(1, 0, theD1U);
    aDerSurf.SetValue(0, 1, theD1V);
    aDerSurf.SetValue(1, 1, theD2UV);
    aDerSurf.SetValue(2, 0, theD2U);
    aDerSurf.SetValue(0, 2, theD2V);
    aDerSurf.SetValue(3, 0, theD3U);
    aDerSurf.SetValue(2, 1, theD3UUV);
    aDerSurf.SetValue(1, 2, theD3UVV);
    aDerSurf.SetValue(0, 3, theD3V);

    // Use ComputeDerivatives to populate DerNUV
    if (aOscInfo.HasOsculating() && !aOscSurf.IsNull())
    {
      if (!ComputeDerivatives(aMaxOrder,
                              3,
                              theU,
                              theV,
                              theBasisSurf,
                              3,
                              3,
                              aOscInfo.AlongU,
                              aOscInfo.AlongV,
                              aOscSurf,
                              aDerNUV,
                              aDerSurf))
        return false;
    }
    else
    {
      occ::handle<Geom_BSplineSurface> aDummy;
      if (!ComputeDerivatives(aMaxOrder,
                              3,
                              theU,
                              theV,
                              theBasisSurf,
                              3,
                              3,
                              false,
                              false,
                              aDummy,
                              aDerNUV,
                              aDerSurf))
        return false;
    }

    // Compute normal using CSLib (second call with MaxOrder)
    int aOrderU, aOrderV;
    CSLib::Normal(aMaxOrder,
                  aDerNUV,
                  THE_D1_MAGNITUDE_TOL,
                  theU,
                  theV,
                  aUMin,
                  aUMax,
                  aVMin,
                  aVMax,
                  aNStatus,
                  aNormal,
                  aOrderU,
                  aOrderV);

    if (aNStatus == CSLib_Defined)
    {
      const double aSign = theOffset * aOscInfo.Sign();

      // Compute offset point
      theValue.SetXYZ(theValue.XYZ() + aSign * aNormal.XYZ());

      // Compute D1 using CSLib::DNNormal
      theD1U =
        aDerSurf(1, 0).Added(CSLib::DNNormal(1, 0, aDerNUV, aOrderU, aOrderV).Multiplied(aSign));
      theD1V =
        aDerSurf(0, 1).Added(CSLib::DNNormal(0, 1, aDerNUV, aOrderU, aOrderV).Multiplied(aSign));

      // For D2 and D3, re-fetch from basis surface
      gp_Vec aDN20 = theBasisSurf->EvalDN(theU, theV, 2, 0);
      gp_Vec aDN02 = theBasisSurf->EvalDN(theU, theV, 0, 2);
      gp_Vec aDN11 = theBasisSurf->EvalDN(theU, theV, 1, 1);
      gp_Vec aDN30 = theBasisSurf->EvalDN(theU, theV, 3, 0);
      gp_Vec aDN03 = theBasisSurf->EvalDN(theU, theV, 0, 3);
      gp_Vec aDN21 = theBasisSurf->EvalDN(theU, theV, 2, 1);
      gp_Vec aDN12 = theBasisSurf->EvalDN(theU, theV, 1, 2);
      theD2U       = aDN20;
      theD2V       = aDN02;
      theD2UV      = aDN11;
      theD3U       = aDN30;
      theD3V       = aDN03;
      theD3UUV     = aDN21;
      theD3UVV     = aDN12;

      // Add offset corrections using CSLib::DNNormal
      theD2U.Add(CSLib::DNNormal(2, 0, aDerNUV, aOrderU, aOrderV).Multiplied(aSign));
      theD2V.Add(CSLib::DNNormal(0, 2, aDerNUV, aOrderU, aOrderV).Multiplied(aSign));
      theD2UV.Add(CSLib::DNNormal(1, 1, aDerNUV, aOrderU, aOrderV).Multiplied(aSign));
      theD3U.Add(CSLib::DNNormal(3, 0, aDerNUV, aOrderU, aOrderV).Multiplied(aSign));
      theD3V.Add(CSLib::DNNormal(0, 3, aDerNUV, aOrderU, aOrderV).Multiplied(aSign));
      theD3UUV.Add(CSLib::DNNormal(2, 1, aDerNUV, aOrderU, aOrderV).Multiplied(aSign));
      theD3UVV.Add(CSLib::DNNormal(1, 2, aDerNUV, aOrderU, aOrderV).Multiplied(aSign));
      return true;
    }

    // Try shifting point towards center - returns false when center is overpassed
    if (!ShiftPoint(aUStart,
                    aVStart,
                    theU,
                    theV,
                    aUMin,
                    aUMax,
                    aVMin,
                    aVMax,
                    isUPer,
                    isVPer,
                    theD1U,
                    theD1V))
    {
      return false;
    }
  }
}

//! Template function for DN evaluation with pre-computed basis surface D1.
//! When normal calculation fails at singular points, falls back to full evaluation
//! with retry mechanism.
//!
//! @tparam BasisSurfType type of basis surface (must have D1 and DN methods)
//! @tparam OscSurfQueryType type providing osculating surface query
//! @param[in] theU U parameter
//! @param[in] theV V parameter
//! @param[in] theNu derivative order in U
//! @param[in] theNv derivative order in V
//! @param[in] theBasisSurf basis surface adaptor
//! @param[in] theOffset offset distance
//! @param[in] theOscQuery osculating surface query object (may be null)
//! @param[out] theResult computed derivative vector
//! @param[in] theD1U pre-computed basis surface D1U (used for first iteration)
//! @param[in] theD1V pre-computed basis surface D1V (used for first iteration)
//! @return true if calculation succeeded, false if failed at singular point
template <class BasisSurfType, class OscSurfQueryType>
bool EvaluateDN(double                  theU,
                double                  theV,
                int                     theNu,
                int                     theNv,
                const BasisSurfType&    theBasisSurf,
                double                  theOffset,
                const OscSurfQueryType& theOscQuery,
                gp_Vec&                 theResult,
                const gp_Vec&           theD1U,
                const gp_Vec&           theD1V)
{
  const double aUStart = theU;
  const double aVStart = theV;
  double       aUMin, aUMax, aVMin, aVMax;
  theBasisSurf->Bounds(aUMin, aUMax, aVMin, aVMax);
  const bool isUPer = theBasisSurf->IsUPeriodic();
  const bool isVPer = theBasisSurf->IsVPeriodic();

  // Use pre-computed D1 for first iteration
  gp_Vec aD1U             = theD1U;
  gp_Vec aD1V             = theD1V;
  bool   isFirstIteration = true;

  for (;;)
  {
    // For subsequent iterations, recompute D1 at shifted point
    if (!isFirstIteration)
    {
      Geom_Surface::ResD1 aD1Result = theBasisSurf->EvalD1(theU, theV);
      aD1U                          = aD1Result.D1U;
      aD1V                          = aD1Result.D1V;
    }
    isFirstIteration = false;

    if (IsInfiniteCoord(aD1U) || IsInfiniteCoord(aD1V))
    {
      return false;
    }

    // Check if singular to determine MaxOrder
    gp_Dir             aNormal;
    CSLib_NormalStatus aNStatus;
    CSLib::Normal(aD1U, aD1V, THE_D1_MAGNITUDE_TOL, aNStatus, aNormal);

    const int aMaxOrder = (aNStatus == CSLib_Defined) ? 0 : 3;
    int       aOrderU, aOrderV;

    // Stack buffers: max size with aMaxOrder=3, theNu=theNv=3 is 7x7=49 and 8x8=64
    const int aDerNUVSize  = (aMaxOrder + theNu + 1) * (aMaxOrder + theNv + 1);
    const int aDerSurfSize = (aMaxOrder + theNu + 2) * (aMaxOrder + theNv + 2);
    NCollection_LocalArray<gp_Vec, 49> aDerNUVBuffer(aDerNUVSize);
    NCollection_LocalArray<gp_Vec, 64> aDerSurfBuffer(aDerSurfSize);
    NCollection_Array2<gp_Vec>         aDerNUV(aDerNUVBuffer[0],
                                       0,
                                       aMaxOrder + theNu,
                                       0,
                                       aMaxOrder + theNv);
    NCollection_Array2<gp_Vec>         aDerSurf(aDerSurfBuffer[0],
                                        0,
                                        aMaxOrder + theNu + 1,
                                        0,
                                        aMaxOrder + theNv + 1);

    aDerSurf.SetValue(1, 0, aD1U);
    aDerSurf.SetValue(0, 1, aD1V);

    // Check osculating surface only in singular case
    OsculatingInfo                   aOscInfo;
    occ::handle<Geom_BSplineSurface> aOscSurf;
    if ((aNStatus != CSLib_Defined) && theOscQuery)
    {
      aOscInfo.AlongU = theOscQuery->UOsculatingSurface(theU, theV, aOscInfo.IsOpposite, aOscSurf);
      aOscInfo.AlongV = theOscQuery->VOsculatingSurface(theU, theV, aOscInfo.IsOpposite, aOscSurf);
    }

    // Use ComputeDerivatives
    if (aOscInfo.HasOsculating() && !aOscSurf.IsNull())
    {
      if (!ComputeDerivatives(aMaxOrder,
                              1,
                              theU,
                              theV,
                              theBasisSurf,
                              theNu,
                              theNv,
                              aOscInfo.AlongU,
                              aOscInfo.AlongV,
                              aOscSurf,
                              aDerNUV,
                              aDerSurf))
        return false;
    }
    else
    {
      occ::handle<Geom_BSplineSurface> aDummy;
      if (!ComputeDerivatives(aMaxOrder,
                              1,
                              theU,
                              theV,
                              theBasisSurf,
                              theNu,
                              theNv,
                              false,
                              false,
                              aDummy,
                              aDerNUV,
                              aDerSurf))
        return false;
    }

    // Compute normal with CSLib
    CSLib::Normal(aMaxOrder,
                  aDerNUV,
                  THE_D1_MAGNITUDE_TOL,
                  theU,
                  theV,
                  aUMin,
                  aUMax,
                  aVMin,
                  aVMax,
                  aNStatus,
                  aNormal,
                  aOrderU,
                  aOrderV);

    if (aNStatus == CSLib_Defined)
    {
      const double aSign = theOffset * aOscInfo.Sign();

      // Compute DN result: basis DN + offset * DNNormal
      gp_Vec aBasisDN = theBasisSurf->EvalDN(theU, theV, theNu, theNv);
      theResult       = aBasisDN;
      theResult.Add(CSLib::DNNormal(theNu, theNv, aDerNUV, aOrderU, aOrderV).Multiplied(aSign));
      return true;
    }

    // Try shifting point towards center - returns false when center is overpassed
    if (!ShiftPoint(aUStart,
                    aVStart,
                    theU,
                    theV,
                    aUMin,
                    aUMax,
                    aVMin,
                    aVMax,
                    isUPer,
                    isVPer,
                    aD1U,
                    aD1V))
    {
      return false;
    }
  }
}

//! Template function for DN evaluation with retry mechanism for singular points.
//! Computes D1 internally and calls the pre-computed overload.
//!
//! @tparam BasisSurfType type of basis surface (must have D1 and DN methods)
//! @tparam OscSurfQueryType type providing osculating surface query
//! @param[in] theU U parameter
//! @param[in] theV V parameter
//! @param[in] theNu derivative order in U
//! @param[in] theNv derivative order in V
//! @param[in] theBasisSurf basis surface adaptor
//! @param[in] theOffset offset distance
//! @param[in] theOscQuery osculating surface query object (may be null)
//! @param[out] theResult computed derivative vector
//! @return true if calculation succeeded, false if failed at singular point
template <class BasisSurfType, class OscSurfQueryType>
bool EvaluateDN(double                  theU,
                double                  theV,
                int                     theNu,
                int                     theNv,
                const BasisSurfType&    theBasisSurf,
                double                  theOffset,
                const OscSurfQueryType& theOscQuery,
                gp_Vec&                 theResult)
{
  Geom_Surface::ResD1 aBasisD1 = theBasisSurf->EvalD1(theU, theV);
  return EvaluateDN(theU,
                    theV,
                    theNu,
                    theNv,
                    theBasisSurf,
                    theOffset,
                    theOscQuery,
                    theResult,
                    aBasisD1.D1U,
                    aBasisD1.D1V);
}

} // namespace Geom_OffsetSurfaceUtils

#endif // _Geom_OffsetSurfaceUtils_HeaderFile
