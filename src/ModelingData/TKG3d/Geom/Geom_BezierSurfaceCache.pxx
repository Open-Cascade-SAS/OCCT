// Copyright (c) 2025 OPEN CASCADE SAS
//
// This file is part of Open CASCADE Technology software library.
//
// This library is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License version 2.1 as published
// by the Free Software Foundation, with special exception defined in the file
// OCCT_LGPL_EXCEPTION.txt. Consult the file LICENSE_LGPL_21.txt included in OCCT
// distribution for complete text of the license and disclaimer of any warranty.
//
// Alternatively, this file may be used under the terms of Open CASCADE
// commercial license or contractual agreement.

#ifndef _Geom_BezierSurfaceCache_pxx_HeaderFile
#define _Geom_BezierSurfaceCache_pxx_HeaderFile

#include <BSplCLib.hxx>
#include <BSplSLib_Cache.hxx>
#include <gp_Pnt.hxx>
#include <gp_Vec.hxx>
#include <NCollection_Array1.hxx>
#include <NCollection_Array2.hxx>
#include <Standard_DefineAlloc.hxx>

#include <atomic>
#include <mutex>

//! Private cache class for Bezier surface coefficients.
//! Uses BSplSLib_Cache internally for exact compatibility with BSpline cache formulas.
//! Stores Taylor expansion coefficients for the single span [0,1]x[0,1].
//! NOT a Standard_Transient - owned by Geom_BezierSurface via unique_ptr.
//!
//! Thread-safety:
//! - Uses std::mutex for exclusive access during build
//! - Atomic validity flag for lock-free validity check
//!
//! Key optimizations:
//! - Single span, simple validity check
//! - Lazy building on first evaluation
class Geom_BezierSurfaceCache
{
public:
  DEFINE_STANDARD_ALLOC

  //! Constructor - stores parameters for lazy BSplSLib_Cache creation
  //! @param theUDegree surface degree in U direction
  //! @param theVDegree surface degree in V direction
  //! @param theIsRational whether surface is rational
  Geom_BezierSurfaceCache(int theUDegree, int theVDegree, bool theIsRational)
      : myUDegree(theUDegree),
        myVDegree(theVDegree),
        myIsRational(theIsRational),
        myIsValid(false)
  {
    // BSplSLib_Cache will be created lazily in Build() when we have actual data
  }

  //! Copy constructor - copies parameters, cache will be rebuilt lazily
  //! @param theOther cache to copy from
  Geom_BezierSurfaceCache(const Geom_BezierSurfaceCache& theOther)
      : myUDegree(theOther.myUDegree),
        myVDegree(theOther.myVDegree),
        myIsRational(theOther.myIsRational),
        myIsValid(false)
  {
  }

  //! Check if coefficients are computed
  bool IsValid() const noexcept { return myIsValid.load(std::memory_order_acquire); }

  //! Build coefficients (thread-safe)
  //! Uses BSplSLib_Cache::BuildCache for exact compatibility with BSpline formulas.
  //! @param thePoles poles array
  //! @param theWeights optional weights for rational surfaces
  void Build(const NCollection_Array2<gp_Pnt>& thePoles,
             const NCollection_Array2<double>* theWeights)
  {
    if (IsValid())
    {
      return;
    }

    std::lock_guard<std::mutex> aLock(myMutex);

    if (myIsValid.load(std::memory_order_relaxed))
    {
      return;
    }

    NCollection_Array1<double> aUFlatKnots(BSplCLib::FlatBezierKnots(myUDegree),
                                           1,
                                           2 * (myUDegree + 1));
    NCollection_Array1<double> aVFlatKnots(BSplCLib::FlatBezierKnots(myVDegree),
                                           1,
                                           2 * (myVDegree + 1));

    if (myCache.IsNull())
    {
      myCache = new BSplSLib_Cache(myUDegree,
                                   false,
                                   aUFlatKnots,
                                   myVDegree,
                                   false,
                                   aVFlatKnots,
                                   theWeights);
    }

    myCache->BuildCache(0.5, 0.5, aUFlatKnots, aVFlatKnots, thePoles, theWeights);
    myIsValid.store(true, std::memory_order_release);
  }

  //! Evaluate D0 using cached coefficients
  //! @param theU U parameter in [0, 1] range
  //! @param theV V parameter in [0, 1] range
  //! @param thePoint output point
  void D0(double theU, double theV, gp_Pnt& thePoint) const { myCache->D0(theU, theV, thePoint); }

  //! Evaluate D1 using cached coefficients
  //! @param theU U parameter in [0, 1] range
  //! @param theV V parameter in [0, 1] range
  //! @param thePoint output point
  //! @param theD1U output U derivative
  //! @param theD1V output V derivative
  void D1(double theU, double theV, gp_Pnt& thePoint, gp_Vec& theD1U, gp_Vec& theD1V) const
  {
    myCache->D1(theU, theV, thePoint, theD1U, theD1V);
  }

  //! Evaluate D2 using cached coefficients
  //! @param theU U parameter in [0, 1] range
  //! @param theV V parameter in [0, 1] range
  //! @param thePoint output point
  //! @param theD1U output U derivative
  //! @param theD1V output V derivative
  //! @param theD2U output second U derivative
  //! @param theD2V output second V derivative
  //! @param theD2UV output mixed derivative
  void D2(double  theU,
          double  theV,
          gp_Pnt& thePoint,
          gp_Vec& theD1U,
          gp_Vec& theD1V,
          gp_Vec& theD2U,
          gp_Vec& theD2V,
          gp_Vec& theD2UV) const
  {
    myCache->D2(theU, theV, thePoint, theD1U, theD1V, theD2U, theD2V, theD2UV);
  }

  //! Invalidate the cache (for geometry modification)
  //! Resets both validity and the internal cache to allow recreation with new data
  void Invalidate()
  {
    myIsValid.store(false, std::memory_order_release);
    myCache.Nullify(); // Reset cache so it can be recreated with correct rationality
  }

  //! Returns U degree
  int UDegree() const noexcept { return myUDegree; }

  //! Returns V degree
  int VDegree() const noexcept { return myVDegree; }

  //! Returns whether cache is for rational surface
  bool IsRational() const noexcept { return myIsRational; }

private:
  // Assignment is prohibited (mutex is not movable)
  Geom_BezierSurfaceCache& operator=(const Geom_BezierSurfaceCache&) = delete;

private:
  int  myUDegree;    //!< surface degree in U direction
  int  myVDegree;    //!< surface degree in V direction
  bool myIsRational; //!< whether surface is rational

  //! Internal BSplSLib_Cache for evaluation
  occ::handle<BSplSLib_Cache> myCache;

  //! Validity flag (atomic for lock-free checking)
  std::atomic<bool> myIsValid;

  //! Mutex for building (only needed during build, not read)
  mutable std::mutex myMutex;
};

#endif // _Geom_BezierSurfaceCache_pxx_HeaderFile
