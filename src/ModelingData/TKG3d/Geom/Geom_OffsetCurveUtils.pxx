// Copyright (c) 2015-2025 OPEN CASCADE SAS
//
// This file is part of Open CASCADE Technology software library.
//
// This library is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License version 2.1 as published
// by the Free Software Foundation, with special exception defined in the file
// OCCT_LGPL_EXCEPTION.txt. Consult the file LICENSE_LGPL_21.txt included in OCCT
// distribution for complete text of the license and disclaimer of any warranty.
//
// Alternatively, this file may be used under the terms of Open CASCADE
// commercial license or contractual agreement.

#ifndef _Geom_OffsetCurveUtils_HeaderFile
#define _Geom_OffsetCurveUtils_HeaderFile

#include <Geom_Curve.hxx>
#include <gp.hxx>
#include <gp_Dir.hxx>
#include <gp_Pnt.hxx>
#include <gp_Vec.hxx>
#include <gp_XYZ.hxx>
#include <Standard_NullValue.hxx>

#include <cmath>
#include <optional>

//! Internal helper namespace for 3D offset curve calculations.
//! Provides static inline functions to compute offset curve point and derivatives
//! from basis curve derivatives.
//!
//! These functions are used by Geom_OffsetCurve, GeomAdaptor_Curve, and GeomGridEval.
//!
//! Mathematical basis:
//! P(u) = p(u) + Offset * N / ||N||
//! where N = p'(u) ^ Direction is the local normal direction
namespace Geom_OffsetCurveUtils
{

//! Calculates D0 (point) for 3D offset curve.
//! Core version that works with gp_XYZ direction vector (must be normalized).
//! @param[in,out] theValue on input: basis curve point; on output: offset point
//! @param[in] theD1 first derivative of basis curve at the point
//! @param[in] theDirXYZ offset reference direction as XYZ (must be unit vector)
//! @param[in] theOffset offset distance value
//! @param[in] theTolerance tolerance for singularity check (default: gp::Resolution())
//! @return true if successful, false if normal vector has zero magnitude
inline bool CalculateD0(gp_Pnt&       theValue,
                        const gp_Vec& theD1,
                        const gp_XYZ& theDirXYZ,
                        double        theOffset,
                        double        theTolerance = gp::Resolution())
{
  gp_XYZ Ndir = (theD1.XYZ()).Crossed(theDirXYZ);
  double R    = Ndir.Modulus();
  if (R <= theTolerance)
  {
    return false;
  }

  Ndir.Multiply(theOffset / R);
  theValue.ChangeCoord().Add(Ndir);
  return true;
}

//! Calculates D0 and D1 for 3D offset curve.
//! Core version that works with gp_XYZ direction vector (must be normalized).
//! @param[in,out] theValue on input: basis curve point; on output: offset point
//! @param[in,out] theD1 on input: first derivative of basis; on output: offset curve D1
//! @param[in] theD2 second derivative of basis curve
//! @param[in] theDirXYZ offset reference direction as XYZ (must be unit vector)
//! @param[in] theOffset offset distance value
//! @param[in] theTolerance tolerance for singularity check (default: gp::Resolution())
//! @return true if successful, false if computation failed
inline bool CalculateD1(gp_Pnt&       theValue,
                        gp_Vec&       theD1,
                        const gp_Vec& theD2,
                        const gp_XYZ& theDirXYZ,
                        double        theOffset,
                        double        theTolerance = gp::Resolution())
{
  // P(u) = p(u) + Offset * Ndir / R
  // with R = || p' ^ V|| and Ndir = P' ^ direction (local normal direction)

  // P'(u) = p'(u) + (Offset / R**2) * (DNdir/DU * R -  Ndir * (DR/R))

  gp_XYZ Ndir  = (theD1.XYZ()).Crossed(theDirXYZ);
  gp_XYZ DNdir = (theD2.XYZ()).Crossed(theDirXYZ);
  double R2    = Ndir.SquareModulus();
  double R     = std::sqrt(R2);
  double R3    = R * R2;
  double Dr    = Ndir.Dot(DNdir);
  if (R3 <= theTolerance)
  {
    if (R2 <= theTolerance)
    {
      return false;
    }
    // We try another computation but the stability is not very good.
    DNdir.Multiply(R);
    DNdir.Subtract(Ndir.Multiplied(Dr / R));
    DNdir.Multiply(theOffset / R2);
  }
  else
  {
    // Same computation as IICURV in EUCLID-IS because the stability is better
    DNdir.Multiply(theOffset / R);
    DNdir.Subtract(Ndir.Multiplied(theOffset * Dr / R3));
  }

  Ndir.Multiply(theOffset / R);
  // P(u)
  theValue.ChangeCoord().Add(Ndir);
  // P'(u)
  theD1.Add(gp_Vec(DNdir));
  return true;
}

//! Calculates D0, D1, D2 for 3D offset curve.
//! Core version that works with gp_XYZ direction vector (must be normalized).
//! @param[in,out] theValue on input: basis curve point; on output: offset point
//! @param[in,out] theD1 on input: first derivative of basis; on output: offset curve D1
//! @param[in,out] theD2 on input: second derivative of basis; on output: offset curve D2
//! @param[in] theD3 third derivative of basis curve
//! @param[in] theDirXYZ offset reference direction as XYZ (must be unit vector)
//! @param[in] theOffset offset distance value
//! @param[in] theIsDirChange flag indicating direction change at singular point
//! @param[in] theTolerance tolerance for singularity check (default: gp::Resolution())
//! @return true if successful, false if computation failed
inline bool CalculateD2(gp_Pnt&       theValue,
                        gp_Vec&       theD1,
                        gp_Vec&       theD2,
                        const gp_Vec& theD3,
                        const gp_XYZ& theDirXYZ,
                        double        theOffset,
                        bool          theIsDirChange,
                        double        theTolerance = gp::Resolution())
{
  // P(u) = p(u) + Offset * Ndir / R
  // with R = || p' ^ V|| and Ndir = P' ^ direction (local normal direction)

  // P'(u) = p'(u) + (Offset / R**2) * (DNdir/DU * R -  Ndir * (DR/R))

  // P"(u) = p"(u) + (Offset / R) * (D2Ndir/DU - DNdir * (2.0 * Dr/ R**2) +
  //         Ndir * ( (3.0 * Dr**2 / R**4) - (D2r / R**2)))

  gp_XYZ Ndir   = (theD1.XYZ()).Crossed(theDirXYZ);
  gp_XYZ DNdir  = (theD2.XYZ()).Crossed(theDirXYZ);
  gp_XYZ D2Ndir = (theD3.XYZ()).Crossed(theDirXYZ);
  double R2     = Ndir.SquareModulus();
  double R      = std::sqrt(R2);
  double R3     = R2 * R;
  double R4     = R2 * R2;
  double R5     = R3 * R2;
  double Dr     = Ndir.Dot(DNdir);
  double D2r    = Ndir.Dot(D2Ndir) + DNdir.Dot(DNdir);

  if (R5 <= theTolerance)
  {
    if (R4 <= theTolerance)
    {
      return false;
    }
    // We try another computation but the stability is not very good
    // dixit ISG.
    //  V2 = P" (U) :
    R4 = R2 * R2;
    D2Ndir.Subtract(DNdir.Multiplied(2.0 * Dr / R2));
    D2Ndir.Add(Ndir.Multiplied(((3.0 * Dr * Dr) / R4) - (D2r / R2)));
    D2Ndir.Multiply(theOffset / R);

    // V1 = P' (U) :
    DNdir.Multiply(R);
    DNdir.Subtract(Ndir.Multiplied(Dr / R));
    DNdir.Multiply(theOffset / R2);
  }
  else
  {
    // Same computation as IICURV in EUCLID-IS because the stability is better.
    // V2 = P" (U) :
    D2Ndir.Multiply(theOffset / R);
    D2Ndir.Subtract(DNdir.Multiplied(2.0 * theOffset * Dr / R3));
    D2Ndir.Add(Ndir.Multiplied(theOffset * (((3.0 * Dr * Dr) / R5) - (D2r / R3))));

    // V1 = P' (U) :
    DNdir.Multiply(theOffset / R);
    DNdir.Subtract(Ndir.Multiplied(theOffset * Dr / R3));
  }

  Ndir.Multiply(theOffset / R);
  // P(u)
  theValue.ChangeCoord().Add(Ndir);
  // P'(u) :
  theD1.Add(gp_Vec(DNdir));
  // P"(u) :
  if (theIsDirChange)
  {
    theD2.Reverse();
  }
  theD2.Add(gp_Vec(D2Ndir));
  return true;
}

//! Calculates D0, D1, D2, D3 for 3D offset curve.
//! Core version that works with gp_XYZ direction vector (must be normalized).
//! @param[in,out] theValue on input: basis curve point; on output: offset point
//! @param[in,out] theD1 on input: first derivative of basis; on output: offset curve D1
//! @param[in,out] theD2 on input: second derivative of basis; on output: offset curve D2
//! @param[in,out] theD3 on input: third derivative of basis; on output: offset curve D3
//! @param[in] theD4 fourth derivative of basis curve
//! @param[in] theDirXYZ offset reference direction as XYZ (must be unit vector)
//! @param[in] theOffset offset distance value
//! @param[in] theIsDirChange flag indicating direction change at singular point
//! @param[in] theTolerance tolerance for singularity check (default: gp::Resolution())
//! @return true if successful, false if computation failed
inline bool CalculateD3(gp_Pnt&       theValue,
                        gp_Vec&       theD1,
                        gp_Vec&       theD2,
                        gp_Vec&       theD3,
                        const gp_Vec& theD4,
                        const gp_XYZ& theDirXYZ,
                        double        theOffset,
                        bool          theIsDirChange,
                        double        theTolerance = gp::Resolution())
{
  // P(u) = p(u) + Offset * Ndir / R
  // with R = || p' ^ V|| and Ndir = P' ^ direction (local normal direction)

  // P'(u) = p'(u) + (Offset / R**2) * (DNdir/DU * R -  Ndir * (DR/R))

  // P"(u) = p"(u) + (Offset / R) * (D2Ndir/DU - DNdir * (2.0 * Dr/ R**2) +
  //         Ndir * ( (3.0 * Dr**2 / R**4) - (D2r / R**2)))

  // P"'(u) = p"'(u) + (Offset / R) * (D3Ndir - (3.0 * Dr/R**2) * D2Ndir -
  //          (3.0 * D2r / R2) * DNdir + (3.0 * Dr * Dr / R4) * DNdir -
  //          (D3r/R2) * Ndir + (6.0 * Dr * Dr / R4) * Ndir +
  //          (6.0 * Dr * D2r / R4) * Ndir - (15.0 * Dr* Dr* Dr /R6) * Ndir

  gp_XYZ       Ndir   = (theD1.XYZ()).Crossed(theDirXYZ);
  gp_XYZ       DNdir  = (theD2.XYZ()).Crossed(theDirXYZ);
  gp_XYZ       D2Ndir = (theD3.XYZ()).Crossed(theDirXYZ);
  gp_XYZ       D3Ndir = (theD4.XYZ()).Crossed(theDirXYZ);
  const double R2     = Ndir.SquareModulus();
  const double R      = std::sqrt(R2);
  const double R3     = R2 * R;
  double       R4     = R2 * R2;
  const double R5     = R3 * R2;
  const double R6     = R3 * R3;
  const double R7     = R5 * R2;
  const double Dr     = Ndir.Dot(DNdir);
  const double D2r    = Ndir.Dot(D2Ndir) + DNdir.Dot(DNdir);
  const double D3r    = Ndir.Dot(D3Ndir) + 3.0 * DNdir.Dot(D2Ndir);
  if (R7 <= theTolerance)
  {
    if (R6 <= theTolerance)
    {
      return false;
    }
    // V3 = P"' (U) :
    D3Ndir.Subtract(D2Ndir.Multiplied(3.0 * Dr / R2));
    D3Ndir.Subtract(DNdir.Multiplied(3.0 * ((D2r / R2) + (Dr * Dr / R4))));
    D3Ndir.Add(
      Ndir.Multiplied(6.0 * Dr * Dr / R4 + 6.0 * Dr * D2r / R4 - 15.0 * Dr * Dr * Dr / R6 - D3r));
    D3Ndir.Multiply(theOffset / R);
    // V2 = P" (U) :
    R4 = R2 * R2;
    D2Ndir.Subtract(DNdir.Multiplied(2.0 * Dr / R2));
    D2Ndir.Subtract(Ndir.Multiplied((3.0 * Dr * Dr / R4) - (D2r / R2)));
    D2Ndir.Multiply(theOffset / R);
    // V1 = P' (U) :
    DNdir.Multiply(R);
    DNdir.Subtract(Ndir.Multiplied(Dr / R));
    DNdir.Multiply(theOffset / R2);
  }
  else
  {
    // V3 = P"' (U) :
    D3Ndir.Divide(R);
    D3Ndir.Subtract(D2Ndir.Multiplied(3.0 * Dr / R3));
    D3Ndir.Subtract(DNdir.Multiplied((3.0 * ((D2r / R3) + (Dr * Dr) / R5))));
    D3Ndir.Add(
      Ndir.Multiplied(6.0 * Dr * Dr / R5 + 6.0 * Dr * D2r / R5 - 15.0 * Dr * Dr * Dr / R7 - D3r));
    D3Ndir.Multiply(theOffset);
    // V2 = P" (U) :
    D2Ndir.Divide(R);
    D2Ndir.Subtract(DNdir.Multiplied(2.0 * Dr / R3));
    D2Ndir.Subtract(Ndir.Multiplied((3.0 * Dr * Dr / R5) - (D2r / R3)));
    D2Ndir.Multiply(theOffset);
    // V1 = P' (U) :
    DNdir.Multiply(theOffset / R);
    DNdir.Subtract(Ndir.Multiplied(theOffset * Dr / R3));
  }

  Ndir.Multiply(theOffset / R);
  // P(u)
  theValue.ChangeCoord().Add(Ndir);
  // P'(u) :
  theD1.Add(gp_Vec(DNdir));
  // P"(u)
  theD2.Add(gp_Vec(D2Ndir));
  // P"'(u)
  if (theIsDirChange)
  {
    theD3.Reverse();
  }
  theD3.Add(gp_Vec(D3Ndir));
  return true;
}

//! Adjusts derivatives at singular points where the first derivative is nearly zero.
//! Uses Taylor series approximation to find a valid tangent direction.
//! Uses EvalDN/EvalD0 to avoid exceptions.
//! @tparam CurveType type supporting EvalD0, EvalDN methods (Geom_Curve or adaptor)
//! @param[in] theCurve basis curve for derivative evaluation
//! @param[in] theMaxDerivative maximum derivative order to compute (3 or 4)
//! @param[in] theU parameter value
//! @param[in,out] theD1 first derivative (will be adjusted)
//! @param[in,out] theD2 second derivative (will be adjusted)
//! @param[in,out] theD3 third derivative (will be adjusted)
//! @param[in,out] theD4 fourth derivative (will be adjusted if theMaxDerivative >= 4)
//! @param[out] theIsDirectionChange true if direction change detected
//! @return true if evaluation succeeded, false if any evaluation failed
template <typename CurveType>
bool AdjustDerivative(const CurveType& theCurve,
                      int              theMaxDerivative,
                      double           theU,
                      gp_Vec&          theD1,
                      gp_Vec&          theD2,
                      gp_Vec&          theD3,
                      gp_Vec&          theD4,
                      bool&            theIsDirectionChange)
{
  static const double aTol           = gp::Resolution();
  static const double aMinStep       = 1e-7;
  static const int    aMaxDerivOrder = 3;

  theIsDirectionChange     = false;
  const double anUinfium   = theCurve.FirstParameter();
  const double anUsupremum = theCurve.LastParameter();

  static const double DivisionFactor = 1.e-3;
  double              du;
  if ((anUsupremum >= RealLast()) || (anUinfium <= RealFirst()))
  {
    du = 0.0;
  }
  else
  {
    du = anUsupremum - anUinfium;
  }

  const double aDelta = std::max(du * DivisionFactor, aMinStep);

  // Derivative is approximated by Taylor-series
  int    anIndex = 1; // Derivative order
  gp_Vec V;

  do
  {
    auto aVOpt = theCurve.EvalDN(theU, ++anIndex);
    if (!aVOpt)
      return false;
    V = *aVOpt;
  } while ((V.SquareMagnitude() <= aTol) && anIndex < aMaxDerivOrder);

  double u;

  if (theU - anUinfium < aDelta)
  {
    u = theU + aDelta;
  }
  else
  {
    u = theU - aDelta;
  }

  auto aP1Opt = theCurve.EvalD0(std::min(theU, u));
  auto aP2Opt = theCurve.EvalD0(std::max(theU, u));
  if (!aP1Opt || !aP2Opt)
    return false;

  gp_Vec V1(*aP1Opt, *aP2Opt);
  theIsDirectionChange = V.Dot(V1) < 0.0;
  const double aSign   = theIsDirectionChange ? -1.0 : 1.0;

  theD1             = V * aSign;
  gp_Vec* aDeriv[3] = {&theD2, &theD3, &theD4};
  for (int i = 1; i < theMaxDerivative; i++)
  {
    auto aDNOpt = theCurve.EvalDN(theU, anIndex + i);
    if (!aDNOpt)
      return false;
    *(aDeriv[i - 1]) = *aDNOpt * aSign;
  }

  return true;
}

//! Template function for D0 evaluation of offset curve.
//! Gets D1 from basis curve and computes offset point.
//!
//! @tparam BasisCurveType type of basis curve (must have D1 method)
//! @param[in] theU parameter value
//! @param[in] theBasisCurve basis curve
//! @param[in] theDir offset reference direction
//! @param[in] theOffset offset distance
//! @param[out] theValue computed offset point
//! @return true if evaluation succeeded, false if normal is undefined
template <typename BasisCurveType>
bool EvaluateD0(double                theU,
                const BasisCurveType& theBasisCurve,
                const gp_Dir&         theDir,
                double                theOffset,
                gp_Pnt&               theValue)
{
  auto aD1Opt = theBasisCurve->EvalD1(theU);
  if (!aD1Opt)
    return false;
  theValue = aD1Opt->Point;
  return CalculateD0(theValue, aD1Opt->D1, theDir.XYZ(), theOffset);
}

//! Template function for D1 evaluation of offset curve.
//! Gets D2 from basis curve and computes offset point and first derivative.
//!
//! @tparam BasisCurveType type of basis curve (must have D2 method)
//! @param[in] theU parameter value
//! @param[in] theBasisCurve basis curve
//! @param[in] theDir offset reference direction
//! @param[in] theOffset offset distance
//! @param[out] theValue computed offset point
//! @param[out] theD1 computed first derivative
//! @return true if evaluation succeeded, false if computation failed
template <typename BasisCurveType>
bool EvaluateD1(double                theU,
                const BasisCurveType& theBasisCurve,
                const gp_Dir&         theDir,
                double                theOffset,
                gp_Pnt&               theValue,
                gp_Vec&               theD1)
{
  auto aD2Opt = theBasisCurve->EvalD2(theU);
  if (!aD2Opt)
    return false;
  theValue = aD2Opt->Point;
  theD1    = aD2Opt->D1;
  return CalculateD1(theValue, theD1, aD2Opt->D2, theDir.XYZ(), theOffset);
}

//! Template function for D2 evaluation of offset curve.
//! Gets D3 from basis curve and computes offset point and derivatives.
//! Handles singular points where first derivative is nearly zero.
//!
//! @tparam BasisCurveType type of basis curve (must have D3 and DN methods)
//! @param[in] theU parameter value
//! @param[in] theBasisCurve basis curve
//! @param[in] theDir offset reference direction
//! @param[in] theOffset offset distance
//! @param[out] theValue computed offset point
//! @param[out] theD1 computed first derivative
//! @param[out] theD2 computed second derivative
//! @return true if evaluation succeeded, false if computation failed
template <typename BasisCurveType>
bool EvaluateD2(double                theU,
                const BasisCurveType& theBasisCurve,
                const gp_Dir&         theDir,
                double                theOffset,
                gp_Pnt&               theValue,
                gp_Vec&               theD1,
                gp_Vec&               theD2)
{
  auto aD3Opt = theBasisCurve->EvalD3(theU);
  if (!aD3Opt)
    return false;
  theValue   = aD3Opt->Point;
  theD1      = aD3Opt->D1;
  theD2      = aD3Opt->D2;
  gp_Vec aD3 = aD3Opt->D3;

  bool isDirectionChange = false;
  if (theD1.SquareMagnitude() <= gp::Resolution())
  {
    gp_Vec aDummyD4;
    if (!AdjustDerivative(*theBasisCurve, 3, theU, theD1, theD2, aD3, aDummyD4, isDirectionChange))
      return false;
  }

  return CalculateD2(theValue, theD1, theD2, aD3, theDir.XYZ(), theOffset, isDirectionChange);
}

//! Template function for D3 evaluation of offset curve.
//! Gets D3 and D4 from basis curve and computes offset point and derivatives.
//! Handles singular points where first derivative is nearly zero.
//!
//! @tparam BasisCurveType type of basis curve (must have D3 and DN methods)
//! @param[in] theU parameter value
//! @param[in] theBasisCurve basis curve
//! @param[in] theDir offset reference direction
//! @param[in] theOffset offset distance
//! @param[out] theValue computed offset point
//! @param[out] theD1 computed first derivative
//! @param[out] theD2 computed second derivative
//! @param[out] theD3 computed third derivative
//! @return true if evaluation succeeded, false if computation failed
template <typename BasisCurveType>
bool EvaluateD3(double                theU,
                const BasisCurveType& theBasisCurve,
                const gp_Dir&         theDir,
                double                theOffset,
                gp_Pnt&               theValue,
                gp_Vec&               theD1,
                gp_Vec&               theD2,
                gp_Vec&               theD3)
{
  auto aD3Opt = theBasisCurve->EvalD3(theU);
  if (!aD3Opt)
    return false;
  theValue = aD3Opt->Point;
  theD1    = aD3Opt->D1;
  theD2    = aD3Opt->D2;
  theD3    = aD3Opt->D3;

  auto aD4Opt = theBasisCurve->EvalDN(theU, 4);
  if (!aD4Opt)
    return false;
  gp_Vec aD4 = *aD4Opt;

  bool isDirectionChange = false;
  if (theD1.SquareMagnitude() <= gp::Resolution())
  {
    if (!AdjustDerivative(*theBasisCurve, 4, theU, theD1, theD2, theD3, aD4, isDirectionChange))
      return false;
  }

  return CalculateD3(theValue,
                     theD1,
                     theD2,
                     theD3,
                     aD4,
                     theDir.XYZ(),
                     theOffset,
                     isDirectionChange);
}

//! Template function for DN evaluation of offset curve.
//! Handles derivatives up to order 3 using D1/D2/D3 methods.
//! For derivatives > 3, returns the basis curve derivative directly
//! (offset contribution is negligible for high-order derivatives).
//!
//! @tparam BasisCurveType type of basis curve (must have D1, D2, D3, DN methods)
//! @param[in] theU parameter value
//! @param[in] theBasisCurve basis curve
//! @param[in] theDir offset reference direction
//! @param[in] theOffset offset distance
//! @param[in] theN derivative order (must be >= 1)
//! @param[out] theDN computed N-th derivative
//! @return true if evaluation succeeded, false if computation failed
template <typename BasisCurveType>
bool EvaluateDN(double                theU,
                const BasisCurveType& theBasisCurve,
                const gp_Dir&         theDir,
                double                theOffset,
                int                   theN,
                gp_Vec&               theDN)
{
  gp_Pnt aPnt;
  gp_Vec aDummy;
  switch (theN)
  {
    case 1:
      return EvaluateD1(theU, theBasisCurve, theDir, theOffset, aPnt, theDN);
    case 2:
      return EvaluateD2(theU, theBasisCurve, theDir, theOffset, aPnt, aDummy, theDN);
    case 3:
      return EvaluateD3(theU, theBasisCurve, theDir, theOffset, aPnt, aDummy, aDummy, theDN);
    default: {
      // For derivatives > 3, return basis curve derivative (no offset contribution)
      auto aDNOpt = theBasisCurve->EvalDN(theU, theN);
      if (!aDNOpt)
        return false;
      theDN = *aDNOpt;
      return true;
    }
  }
}

} // namespace Geom_OffsetCurveUtils

#endif // _Geom_OffsetCurveUtils_HeaderFile
