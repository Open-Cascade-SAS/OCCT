// Copyright (c) 2025 OPEN CASCADE SAS
//
// This file is part of Open CASCADE Technology software library.
//
// This library is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License version 2.1 as published
// by the Free Software Foundation, with special exception defined in the file
// OCCT_LGPL_EXCEPTION.txt. Consult the file LICENSE_LGPL_21.txt included in OCCT
// distribution for complete text of the license and disclaimer of any warranty.
//
// Alternatively, this file may be used under the terms of Open CASCADE
// commercial license or contractual agreement.

#ifndef _Geom_BSplineSurfaceCache_Headerfile
#define _Geom_BSplineSurfaceCache_Headerfile

#include <BSplCLib.hxx>
#include <BSplSLib.hxx>
#include <gp_Pnt.hxx>
#include <gp_Vec.hxx>
#include <NCollection_Array1.hxx>
#include <NCollection_Array2.hxx>
#include <NCollection_HArray2.hxx>
#include <NCollection_LocalArray.hxx>
#include <PLib.hxx>
#include <Standard_DefineAlloc.hxx>

#include <atomic>
#include <cmath>
#include <shared_mutex>

//! Private cache class for BSpline surface span coefficients.
//! Stores Taylor expansion coefficients for ALL span cells in contiguous memory.
//! NOT a Standard_Transient - owned by Geom_BSplineSurface via unique_ptr.
//!
//! Thread-safety:
//! - Uses std::shared_mutex for concurrent read access
//! - Multiple threads can read different (or same) spans concurrently
//! - Span building acquires exclusive lock only for that operation
//!
//! Key optimizations:
//! - All span coefficients in ONE NCollection_Array1<double> for cache locality
//! - O(1) access to any span cell's coefficients by (U,V) span indices
//! - On-demand span building with shared_mutex protection
//! - Fast span location: O(1) for sequential access, O(log N) worst case
//! - Stores span boundaries and flat knot indices for quick lookup
class Geom_BSplineSurfaceCache
{
public:
  DEFINE_STANDARD_ALLOC

  //! Result of span location operation for one direction
  struct SpanInfo1D
  {
    int    SpanIdx;     //!< Span index (0-based)
    int    FlatKnotIdx; //!< Flat knot index for BuildCache
    double LocalParam;  //!< Local parameter in [-1, 1] range (surface convention)
    double SpanHalfLen; //!< Half-length of the span (for derivative scaling)
  };

  //! Result of 2D span location operation
  struct SpanInfo
  {
    SpanInfo1D U; //!< U direction span info
    SpanInfo1D V; //!< V direction span info
  };

  //! Constructor - allocates storage for all span cells
  //! @param theUDegree    degree along U axis
  //! @param theVDegree    degree along V axis
  //! @param theIsRational whether surface is rational
  //! @param theUPeriodic  whether surface is periodic in U
  //! @param theVPeriodic  whether surface is periodic in V
  //! @param theUKnots     U knot vector (unique knots)
  //! @param theUMults     U knot multiplicities
  //! @param theVKnots     V knot vector (unique knots)
  //! @param theVMults     V knot multiplicities
  Geom_BSplineSurfaceCache(int                               theUDegree,
                           int                               theVDegree,
                           bool                              theIsRational,
                           bool                              theUPeriodic,
                           bool                              theVPeriodic,
                           const NCollection_Array1<double>& theUKnots,
                           const NCollection_Array1<int>&    theUMults,
                           const NCollection_Array1<double>& theVKnots,
                           const NCollection_Array1<int>&    theVMults)
      : myUDegree(theUDegree),
        myVDegree(theVDegree),
        myIsRational(theIsRational),
        myUPeriodic(theUPeriodic),
        myVPeriodic(theVPeriodic),
        myNbUSpans(theUKnots.Length() - 1),
        myNbVSpans(theVKnots.Length() - 1),
        myRowLength(theIsRational ? 4 : 3),
        myCoeffsPerSpan((std::max(theUDegree, theVDegree) + 1) * myRowLength
                        * (std::min(theUDegree, theVDegree) + 1)),
        myCoeffs(1, myNbUSpans * myNbVSpans * myCoeffsPerSpan),
        mySpanValid(1, myNbUSpans * myNbVSpans),
        myUSpanStart(1, myNbUSpans),
        myUSpanHalfLen(1, myNbUSpans),
        myUFlatKnotIdx(1, myNbUSpans),
        myVSpanStart(1, myNbVSpans),
        myVSpanHalfLen(1, myNbVSpans),
        myVFlatKnotIdx(1, myNbVSpans),
        myLastUSpanIdx(0),
        myLastVSpanIdx(0)
  {
    myUFirstParam = theUKnots.Value(theUKnots.Lower());
    myULastParam  = theUKnots.Value(theUKnots.Upper());
    myVFirstParam = theVKnots.Value(theVKnots.Lower());
    myVLastParam  = theVKnots.Value(theVKnots.Upper());

    for (int i = 1; i <= myNbUSpans; ++i)
    {
      const double aStart           = theUKnots.Value(theUKnots.Lower() + i - 1);
      const double aEnd             = theUKnots.Value(theUKnots.Lower() + i);
      const double aHalfLen         = 0.5 * (aEnd - aStart);
      myUSpanStart.ChangeValue(i)   = aStart + aHalfLen;
      myUSpanHalfLen.ChangeValue(i) = aHalfLen;
      myUFlatKnotIdx.ChangeValue(i) = BSplCLib::FlatIndex(theUDegree, i, theUMults, theUPeriodic);
    }

    for (int i = 1; i <= myNbVSpans; ++i)
    {
      const double aStart           = theVKnots.Value(theVKnots.Lower() + i - 1);
      const double aEnd             = theVKnots.Value(theVKnots.Lower() + i);
      const double aHalfLen         = 0.5 * (aEnd - aStart);
      myVSpanStart.ChangeValue(i)   = aStart + aHalfLen;
      myVSpanHalfLen.ChangeValue(i) = aHalfLen;
      myVFlatKnotIdx.ChangeValue(i) = BSplCLib::FlatIndex(theVDegree, i, theVMults, theVPeriodic);
    }

    for (int i = 1; i <= myNbUSpans * myNbVSpans; ++i)
    {
      mySpanValid.ChangeValue(i) = false;
    }
  }

  //! Copy constructor - creates a deep copy with shared_lock on source
  Geom_BSplineSurfaceCache(const Geom_BSplineSurfaceCache& theOther)
      : myUDegree(theOther.myUDegree),
        myVDegree(theOther.myVDegree),
        myIsRational(theOther.myIsRational),
        myUPeriodic(theOther.myUPeriodic),
        myVPeriodic(theOther.myVPeriodic),
        myNbUSpans(theOther.myNbUSpans),
        myNbVSpans(theOther.myNbVSpans),
        myRowLength(theOther.myRowLength),
        myCoeffsPerSpan(theOther.myCoeffsPerSpan),
        myUFirstParam(theOther.myUFirstParam),
        myULastParam(theOther.myULastParam),
        myVFirstParam(theOther.myVFirstParam),
        myVLastParam(theOther.myVLastParam),
        myCoeffs(1, theOther.myNbUSpans * theOther.myNbVSpans * theOther.myCoeffsPerSpan),
        mySpanValid(1, theOther.myNbUSpans * theOther.myNbVSpans),
        myUSpanStart(1, theOther.myNbUSpans),
        myUSpanHalfLen(1, theOther.myNbUSpans),
        myUFlatKnotIdx(1, theOther.myNbUSpans),
        myVSpanStart(1, theOther.myNbVSpans),
        myVSpanHalfLen(1, theOther.myNbVSpans),
        myVFlatKnotIdx(1, theOther.myNbVSpans),
        myLastUSpanIdx(0),
        myLastVSpanIdx(0)
  {
    std::shared_lock<std::shared_mutex> aLock(theOther.myMutex);
    for (int i = 1; i <= myCoeffs.Length(); ++i)
    {
      myCoeffs.ChangeValue(i) = theOther.myCoeffs.Value(i);
    }
    for (int i = 1; i <= myNbUSpans; ++i)
    {
      myUSpanStart.ChangeValue(i)   = theOther.myUSpanStart.Value(i);
      myUSpanHalfLen.ChangeValue(i) = theOther.myUSpanHalfLen.Value(i);
      myUFlatKnotIdx.ChangeValue(i) = theOther.myUFlatKnotIdx.Value(i);
    }
    for (int i = 1; i <= myNbVSpans; ++i)
    {
      myVSpanStart.ChangeValue(i)   = theOther.myVSpanStart.Value(i);
      myVSpanHalfLen.ChangeValue(i) = theOther.myVSpanHalfLen.Value(i);
      myVFlatKnotIdx.ChangeValue(i) = theOther.myVFlatKnotIdx.Value(i);
    }
    const int aNbCells = myNbUSpans * myNbVSpans;
    for (int i = 1; i <= aNbCells; ++i)
    {
      mySpanValid.ChangeValue(i) = theOther.mySpanValid.Value(i);
    }
    myLastUSpanIdx.store(theOther.myLastUSpanIdx.load(std::memory_order_relaxed),
                         std::memory_order_relaxed);
    myLastVSpanIdx.store(theOther.myLastVSpanIdx.load(std::memory_order_relaxed),
                         std::memory_order_relaxed);
  }

  //! Check if span cell coefficients are computed
  //! @param theUSpanIdx U span index (0-based)
  //! @param theVSpanIdx V span index (0-based)
  bool IsSpanValid(int theUSpanIdx, int theVSpanIdx) const noexcept
  {
    return mySpanValid.Value(theUSpanIdx * myNbVSpans + theVSpanIdx + 1);
  }

  //! Build coefficients for span cell if not already built (thread-safe)
  //! @param theUSpanIdx    U span index (0-based)
  //! @param theVSpanIdx    V span index (0-based)
  //! @param theUFlatKnotIdx flat knot index in U direction
  //! @param theVFlatKnotIdx flat knot index in V direction
  //! @param theUFlatKnots  flat knots in U direction
  //! @param theVFlatKnots  flat knots in V direction
  //! @param thePoles       poles array
  //! @param theWeights     weights array (can be nullptr for non-rational)
  void BuildSpan(int                               theUSpanIdx,
                 int                               theVSpanIdx,
                 int                               theUFlatKnotIdx,
                 int                               theVFlatKnotIdx,
                 const NCollection_Array1<double>& theUFlatKnots,
                 const NCollection_Array1<double>& theVFlatKnots,
                 const NCollection_Array2<gp_Pnt>& thePoles,
                 const NCollection_Array2<double>* theWeights)
  {
    const int aCellIdx = theUSpanIdx * myNbVSpans + theVSpanIdx + 1;
    {
      std::shared_lock<std::shared_mutex> aReadLock(myMutex);
      if (mySpanValid.Value(aCellIdx))
      {
        return;
      }
    }

    std::unique_lock<std::shared_mutex> aWriteLock(myMutex);
    if (mySpanValid.Value(aCellIdx))
    {
      return;
    }

    const double aUMid     = myUSpanStart.Value(theUSpanIdx + 1);
    const double aUHalfLen = myUSpanHalfLen.Value(theUSpanIdx + 1);
    const double aVMid     = myVSpanStart.Value(theVSpanIdx + 1);
    const double aVHalfLen = myVSpanHalfLen.Value(theVSpanIdx + 1);

    const int                                aMaxDeg = std::max(myUDegree, myVDegree);
    const int                                aMinDeg = std::min(myUDegree, myVDegree);
    occ::handle<NCollection_HArray2<double>> aTempCache =
      new NCollection_HArray2<double>(1, aMaxDeg + 1, 1, myRowLength * (aMinDeg + 1));

    BSplSLib::BuildCache(aUMid,
                         aVMid,
                         aUHalfLen,
                         aVHalfLen,
                         myUPeriodic,
                         myVPeriodic,
                         myUDegree,
                         myVDegree,
                         theUFlatKnotIdx,
                         theVFlatKnotIdx,
                         theUFlatKnots,
                         theVFlatKnots,
                         thePoles,
                         theWeights,
                         aTempCache->ChangeArray2());

    const int     aOffset = (theUSpanIdx * myNbVSpans + theVSpanIdx) * myCoeffsPerSpan;
    const double* aSrc    = &aTempCache->Value(1, 1);
    double*       aDst    = &myCoeffs.ChangeValue(1) + aOffset;
    for (int i = 0; i < myCoeffsPerSpan; ++i)
    {
      aDst[i] = aSrc[i];
    }
    mySpanValid.ChangeValue(aCellIdx) = true;
  }

  //! Locate span for given (U, V) parameters
  //! @param theU U parameter
  //! @param theV V parameter
  //! @return SpanInfo with span indices, flat knot indices, local parameters, and half-lengths
  SpanInfo LocateSpan(double theU, double theV) const
  {
    SpanInfo aResult;
    aResult.U = locateSpan1D(theU,
                             myUPeriodic,
                             myUFirstParam,
                             myULastParam,
                             myNbUSpans,
                             myUSpanStart,
                             myUSpanHalfLen,
                             myUFlatKnotIdx,
                             myLastUSpanIdx);
    aResult.V = locateSpan1D(theV,
                             myVPeriodic,
                             myVFirstParam,
                             myVLastParam,
                             myNbVSpans,
                             myVSpanStart,
                             myVSpanHalfLen,
                             myVFlatKnotIdx,
                             myLastVSpanIdx);
    return aResult;
  }

  //! Evaluate point on surface using cached span coefficients
  //! @param theUSpanIdx U span index (0-based)
  //! @param theVSpanIdx V span index (0-based)
  //! @param theLocalU   local U parameter in [-1, 1]
  //! @param theLocalV   local V parameter in [-1, 1]
  //! @param thePoint    output point
  void D0(int     theUSpanIdx,
          int     theVSpanIdx,
          double  theLocalU,
          double  theLocalV,
          gp_Pnt& thePoint) const
  {
    std::shared_lock<std::shared_mutex> aLock(myMutex);

    const double* aCoeffs    = spanCoeffs(theUSpanIdx, theVSpanIdx);
    const int     aDimension = myIsRational ? 4 : 3;
    const int     aMaxDeg    = std::max(myUDegree, myVDegree);
    const int     aMinDeg    = std::min(myUDegree, myVDegree);
    const int     aCacheCols = myRowLength * (aMinDeg + 1);

    const bool   isMaxU    = (myUDegree > myVDegree);
    const double aMinParam = isMaxU ? theLocalV : theLocalU;
    const double aMaxParam = isMaxU ? theLocalU : theLocalV;

    NCollection_LocalArray<double> aTransientCoeffs(aCacheCols);
    double                         aPoint[4] = {};

    PLib::NoDerivativeEvalPolynomial(aMaxParam,
                                     aMaxDeg,
                                     aCacheCols,
                                     aMaxDeg * aCacheCols,
                                     const_cast<double&>(aCoeffs[0]),
                                     aTransientCoeffs[0]);
    PLib::NoDerivativeEvalPolynomial(aMinParam,
                                     aMinDeg,
                                     aDimension,
                                     aDimension * aMinDeg,
                                     aTransientCoeffs[0],
                                     aPoint[0]);

    thePoint.SetCoord(aPoint[0], aPoint[1], aPoint[2]);
    if (myIsRational)
    {
      thePoint.ChangeCoord().Divide(aPoint[3]);
    }
  }

  //! Evaluate point and first derivatives using cached span coefficients
  //! @param theUSpanIdx  U span index (0-based)
  //! @param theVSpanIdx  V span index (0-based)
  //! @param theLocalU    local U parameter in [-1, 1]
  //! @param theLocalV    local V parameter in [-1, 1]
  //! @param theUHalfLen  U span half-length for derivative scaling
  //! @param theVHalfLen  V span half-length for derivative scaling
  //! @param thePoint     output point
  //! @param theD1U       output first derivative in U
  //! @param theD1V       output first derivative in V
  void D1(int     theUSpanIdx,
          int     theVSpanIdx,
          double  theLocalU,
          double  theLocalV,
          double  theUHalfLen,
          double  theVHalfLen,
          gp_Pnt& thePoint,
          gp_Vec& theD1U,
          gp_Vec& theD1V) const
  {
    std::shared_lock<std::shared_mutex> aLock(myMutex);

    double aPntDeriv[16] = {};
    evaluatePolynomials(theUSpanIdx, theVSpanIdx, theLocalU, theLocalV, 1, 1, aPntDeriv);

    const int aDimension = 3;
    thePoint.SetCoord(aPntDeriv[0], aPntDeriv[1], aPntDeriv[2]);

    if (myUDegree > myVDegree)
    {
      theD1V.SetCoord(aPntDeriv[aDimension], aPntDeriv[aDimension + 1], aPntDeriv[aDimension + 2]);
      theD1U.SetCoord(aPntDeriv[aDimension << 1],
                      aPntDeriv[(aDimension << 1) + 1],
                      aPntDeriv[(aDimension << 1) + 2]);
    }
    else
    {
      theD1U.SetCoord(aPntDeriv[aDimension], aPntDeriv[aDimension + 1], aPntDeriv[aDimension + 2]);
      theD1V.SetCoord(aPntDeriv[aDimension << 1],
                      aPntDeriv[(aDimension << 1) + 1],
                      aPntDeriv[(aDimension << 1) + 2]);
    }

    theD1U.Divide(theUHalfLen);
    theD1V.Divide(theVHalfLen);
  }

  //! Evaluate point and derivatives up to second order using cached span coefficients
  //! @param theUSpanIdx  U span index (0-based)
  //! @param theVSpanIdx  V span index (0-based)
  //! @param theLocalU    local U parameter in [-1, 1]
  //! @param theLocalV    local V parameter in [-1, 1]
  //! @param theUHalfLen  U span half-length for derivative scaling
  //! @param theVHalfLen  V span half-length for derivative scaling
  //! @param thePoint     output point
  //! @param theD1U       output first derivative in U
  //! @param theD1V       output first derivative in V
  //! @param theD2U       output second derivative in U
  //! @param theD2V       output second derivative in V
  //! @param theD2UV      output mixed second derivative
  void D2(int     theUSpanIdx,
          int     theVSpanIdx,
          double  theLocalU,
          double  theLocalV,
          double  theUHalfLen,
          double  theVHalfLen,
          gp_Pnt& thePoint,
          gp_Vec& theD1U,
          gp_Vec& theD1V,
          gp_Vec& theD2U,
          gp_Vec& theD2V,
          gp_Vec& theD2UV) const
  {
    std::shared_lock<std::shared_mutex> aLock(myMutex);

    double aPntDeriv[36] = {};
    evaluatePolynomials(theUSpanIdx, theVSpanIdx, theLocalU, theLocalV, 2, 2, aPntDeriv);

    const int aDimension = 3;
    const int aShift     = aDimension;
    const int aShift2    = aDimension << 1;
    const int aShift3    = aShift2 + aDimension;
    const int aShift4    = aShift3 + aDimension;
    const int aShift6    = 6 * aDimension;

    thePoint.SetCoord(aPntDeriv[0], aPntDeriv[1], aPntDeriv[2]);

    if (myUDegree > myVDegree)
    {
      theD1V.SetCoord(aPntDeriv[aShift], aPntDeriv[aShift + 1], aPntDeriv[aShift + 2]);
      theD2V.SetCoord(aPntDeriv[aShift2], aPntDeriv[aShift2 + 1], aPntDeriv[aShift2 + 2]);
      theD1U.SetCoord(aPntDeriv[aShift3], aPntDeriv[aShift3 + 1], aPntDeriv[aShift3 + 2]);
      theD2UV.SetCoord(aPntDeriv[aShift4], aPntDeriv[aShift4 + 1], aPntDeriv[aShift4 + 2]);
      theD2U.SetCoord(aPntDeriv[aShift6], aPntDeriv[aShift6 + 1], aPntDeriv[aShift6 + 2]);
    }
    else
    {
      theD1U.SetCoord(aPntDeriv[aShift], aPntDeriv[aShift + 1], aPntDeriv[aShift + 2]);
      theD2U.SetCoord(aPntDeriv[aShift2], aPntDeriv[aShift2 + 1], aPntDeriv[aShift2 + 2]);
      theD1V.SetCoord(aPntDeriv[aShift3], aPntDeriv[aShift3 + 1], aPntDeriv[aShift3 + 2]);
      theD2UV.SetCoord(aPntDeriv[aShift4], aPntDeriv[aShift4 + 1], aPntDeriv[aShift4 + 2]);
      theD2V.SetCoord(aPntDeriv[aShift6], aPntDeriv[aShift6 + 1], aPntDeriv[aShift6 + 2]);
    }

    const double aUHalfLen2 = theUHalfLen * theUHalfLen;
    const double aVHalfLen2 = theVHalfLen * theVHalfLen;
    theD1U.Divide(theUHalfLen);
    theD1V.Divide(theVHalfLen);
    theD2U.Divide(aUHalfLen2);
    theD2V.Divide(aVHalfLen2);
    theD2UV.Divide(theUHalfLen * theVHalfLen);
  }

  //! Invalidate all spans (for geometry modification)
  void Invalidate()
  {
    std::unique_lock<std::shared_mutex> aLock(myMutex);
    const int                           aNbCells = myNbUSpans * myNbVSpans;
    for (int i = 1; i <= aNbCells; ++i)
    {
      mySpanValid.ChangeValue(i) = false;
    }
  }

  // Copying assignment is prohibited
  Geom_BSplineSurfaceCache& operator=(const Geom_BSplineSurfaceCache&) = delete;

private:
  //! Get pointer to span cell coefficients
  const double* spanCoeffs(int theUSpanIdx, int theVSpanIdx) const noexcept
  {
    const int aOffset = (theUSpanIdx * myNbVSpans + theVSpanIdx) * myCoeffsPerSpan;
    return &myCoeffs.Value(1) + aOffset;
  }

  //! Locate span in one direction with fast path optimization
  SpanInfo1D locateSpan1D(double                            theParam,
                          bool                              thePeriodic,
                          double                            theFirstParam,
                          double                            theLastParam,
                          int                               theNbSpans,
                          const NCollection_Array1<double>& theSpanStart,
                          const NCollection_Array1<double>& theSpanHalfLen,
                          const NCollection_Array1<int>&    theFlatKnotIdx,
                          std::atomic<int>&                 theLastSpanIdx) const
  {
    double aParam = theParam;
    if (thePeriodic)
    {
      const double aPeriod = theLastParam - theFirstParam;
      if (aParam < theFirstParam)
      {
        const double aScale = std::trunc((theFirstParam - aParam) / aPeriod);
        aParam += aPeriod * (aScale + 1.0);
      }
      else if (aParam > theLastParam)
      {
        const double aScale = std::trunc((aParam - theLastParam) / aPeriod);
        aParam -= aPeriod * (aScale + 1.0);
      }
    }

    int aHintIdx = theLastSpanIdx.load(std::memory_order_relaxed);
    if (aHintIdx >= 0 && aHintIdx < theNbSpans)
    {
      const double aMid     = theSpanStart.Value(aHintIdx + 1);
      const double aHalfLen = theSpanHalfLen.Value(aHintIdx + 1);
      const double aStart   = aMid - aHalfLen;
      const double aEnd     = aMid + aHalfLen;

      if (aParam >= aStart && (aParam < aEnd || (aHintIdx == theNbSpans - 1 && aParam <= aEnd)))
      {
        return {aHintIdx, theFlatKnotIdx.Value(aHintIdx + 1), (aParam - aMid) / aHalfLen, aHalfLen};
      }
      if (aHintIdx < theNbSpans - 1)
      {
        const double aNextMid     = theSpanStart.Value(aHintIdx + 2);
        const double aNextHalfLen = theSpanHalfLen.Value(aHintIdx + 2);
        const double aNextStart   = aNextMid - aNextHalfLen;
        const double aNextEnd     = aNextMid + aNextHalfLen;
        if (aParam >= aNextStart
            && (aParam < aNextEnd || (aHintIdx + 1 == theNbSpans - 1 && aParam <= aNextEnd)))
        {
          const int aSpanIdx = aHintIdx + 1;
          theLastSpanIdx.store(aSpanIdx, std::memory_order_relaxed);
          return {aSpanIdx,
                  theFlatKnotIdx.Value(aSpanIdx + 1),
                  (aParam - aNextMid) / aNextHalfLen,
                  aNextHalfLen};
        }
      }
      if (aHintIdx > 0)
      {
        const double aPrevMid     = theSpanStart.Value(aHintIdx);
        const double aPrevHalfLen = theSpanHalfLen.Value(aHintIdx);
        const double aPrevStart   = aPrevMid - aPrevHalfLen;
        const double aPrevEnd     = aPrevMid + aPrevHalfLen;
        if (aParam >= aPrevStart && aParam < aPrevEnd)
        {
          const int aSpanIdx = aHintIdx - 1;
          theLastSpanIdx.store(aSpanIdx, std::memory_order_relaxed);
          return {aSpanIdx,
                  theFlatKnotIdx.Value(aSpanIdx + 1),
                  (aParam - aPrevMid) / aPrevHalfLen,
                  aPrevHalfLen};
        }
      }
    }

    int aLow = 0, aHigh = theNbSpans - 1;
    while (aLow <= aHigh)
    {
      const int    aMid     = (aLow + aHigh) / 2;
      const double aSpanMid = theSpanStart.Value(aMid + 1);
      const double aHalfLen = theSpanHalfLen.Value(aMid + 1);
      const double aStart   = aSpanMid - aHalfLen;
      const double aEnd     = aSpanMid + aHalfLen;

      if (aParam < aStart)
      {
        aHigh = aMid - 1;
      }
      else if (aParam >= aEnd && aMid < theNbSpans - 1)
      {
        aLow = aMid + 1;
      }
      else
      {
        // Found the span
        theLastSpanIdx.store(aMid, std::memory_order_relaxed);
        return {aMid, theFlatKnotIdx.Value(aMid + 1), (aParam - aSpanMid) / aHalfLen, aHalfLen};
      }
    }

    if (aParam <= theFirstParam)
    {
      theLastSpanIdx.store(0, std::memory_order_relaxed);
      const double aHalfLen = theSpanHalfLen.Value(1);
      return {0, theFlatKnotIdx.Value(1), -1.0, aHalfLen};
    }
    else
    {
      const int    aLastIdx = theNbSpans - 1;
      const double aHalfLen = theSpanHalfLen.Value(theNbSpans);
      theLastSpanIdx.store(aLastIdx, std::memory_order_relaxed);
      return {aLastIdx, theFlatKnotIdx.Value(theNbSpans), 1.0, aHalfLen};
    }
  }

  //! Evaluate polynomials and their derivatives (helper for D1/D2)
  void evaluatePolynomials(int     theUSpanIdx,
                           int     theVSpanIdx,
                           double  theLocalU,
                           double  theLocalV,
                           int     theUDerivMax,
                           int     theVDerivMax,
                           double* theResultArray) const
  {
    const double* aCoeffs    = spanCoeffs(theUSpanIdx, theVSpanIdx);
    const int     aDimension = myIsRational ? 4 : 3;
    const int     aMinDeg    = std::min(myUDegree, myVDegree);
    const int     aCacheCols = myRowLength * (aMinDeg + 1);

    const bool isMaxU     = (myUDegree > myVDegree);
    const auto aMinParam  = isMaxU ? theLocalV : theLocalU;
    const auto aMaxParam  = isMaxU ? theLocalU : theLocalV;
    const int  aMaxDeriv  = isMaxU ? theUDerivMax : theVDerivMax;
    const int  aMinDeriv  = isMaxU ? theVDerivMax : theUDerivMax;
    const int  aRowStride = (aMinDeriv + 1) * aDimension;

    NCollection_LocalArray<double> aTransientCoeffs(
      std::max((aMaxDeriv + 1) * aCacheCols, (aMinDeriv + 1) * aDimension));

    PLib::EvalPolynomial(aMaxParam,
                         aMaxDeriv,
                         isMaxU ? myUDegree : myVDegree,
                         aCacheCols,
                         const_cast<double&>(aCoeffs[0]),
                         aTransientCoeffs[0]);
    PLib::EvalPolynomial(aMinParam,
                         aMinDeriv,
                         isMaxU ? myVDegree : myUDegree,
                         aDimension,
                         aTransientCoeffs[0],
                         theResultArray[0]);

    if (aMaxDeriv > 0)
    {
      const int aDeriv = myIsRational ? aMinDeriv : std::min(aMinDeriv, 1);
      PLib::EvalPolynomial(aMinParam,
                           aDeriv,
                           isMaxU ? myVDegree : myUDegree,
                           aDimension,
                           aTransientCoeffs[aCacheCols],
                           theResultArray[aRowStride]);

      if (aMaxDeriv > 1)
      {
        const int aDeriv2 = myIsRational ? aMinDeriv : 0;
        if (aDeriv2 == 0)
        {
          PLib::NoDerivativeEvalPolynomial(aMinParam,
                                           isMaxU ? myVDegree : myUDegree,
                                           aDimension,
                                           (isMaxU ? myVDegree : myUDegree) * aDimension,
                                           aTransientCoeffs[aCacheCols << 1],
                                           theResultArray[aRowStride << 1]);
        }
        else
        {
          PLib::EvalPolynomial(aMinParam,
                               aDeriv2,
                               isMaxU ? myVDegree : myUDegree,
                               aDimension,
                               aTransientCoeffs[aCacheCols << 1],
                               theResultArray[aRowStride << 1]);
        }
      }
    }

    if (myIsRational)
    {
      const int                      aResultSize = (theUDerivMax + 1) * (theVDerivMax + 1) * 3;
      NCollection_LocalArray<double> aTempStorage(aResultSize);

      if (isMaxU)
      {
        BSplSLib::RationalDerivative(theUDerivMax,
                                     theVDerivMax,
                                     theUDerivMax,
                                     theVDerivMax,
                                     theResultArray[0],
                                     aTempStorage[0]);
      }
      else
      {
        BSplSLib::RationalDerivative(theVDerivMax,
                                     theUDerivMax,
                                     theVDerivMax,
                                     theUDerivMax,
                                     theResultArray[0],
                                     aTempStorage[0]);
      }

      for (int i = 0; i < aResultSize; ++i)
      {
        theResultArray[i] = aTempStorage[i];
      }
    }
  }

private:
  int  myUDegree;       //!< degree in U direction
  int  myVDegree;       //!< degree in V direction
  bool myIsRational;    //!< whether surface is rational
  bool myUPeriodic;     //!< whether surface is periodic in U
  bool myVPeriodic;     //!< whether surface is periodic in V
  int  myNbUSpans;      //!< number of spans in U direction
  int  myNbVSpans;      //!< number of spans in V direction
  int  myRowLength;     //!< 3 for non-rational, 4 for rational
  int  myCoeffsPerSpan; //!< coefficients per span cell

  double myUFirstParam; //!< first valid U parameter
  double myULastParam;  //!< last valid U parameter
  double myVFirstParam; //!< first valid V parameter
  double myVLastParam;  //!< last valid V parameter

  //! Contiguous storage for ALL span cell coefficients (1-based indexing)
  NCollection_Array1<double> myCoeffs;

  //! Per-span validity flags (1-based indexing, linearized 2D grid)
  NCollection_Array1<bool> mySpanValid;

  //! U direction span lookup tables (1-based indexing)
  NCollection_Array1<double> myUSpanStart;   //!< midpoint parameter for each U span
  NCollection_Array1<double> myUSpanHalfLen; //!< half-length of each U span
  NCollection_Array1<int>    myUFlatKnotIdx; //!< flat knot index for each U span

  //! V direction span lookup tables (1-based indexing)
  NCollection_Array1<double> myVSpanStart;   //!< midpoint parameter for each V span
  NCollection_Array1<double> myVSpanHalfLen; //!< half-length of each V span
  NCollection_Array1<int>    myVFlatKnotIdx; //!< flat knot index for each V span

  //! Last used span indices for O(1) fast path (atomic for thread-safe hint)
  mutable std::atomic<int> myLastUSpanIdx;
  mutable std::atomic<int> myLastVSpanIdx;

  //! Shared mutex for thread-safe access (readers don't block each other)
  mutable std::shared_mutex myMutex;
};

#endif
