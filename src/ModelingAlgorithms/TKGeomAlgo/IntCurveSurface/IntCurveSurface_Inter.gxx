// Created on: 1993-04-09
// Created by: Laurent BUCHARD
// Copyright (c) 1993-1999 Matra Datavision
// Copyright (c) 1999-2014 OPEN CASCADE SAS
//
// This file is part of Open CASCADE Technology software library.
//
// This library is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License version 2.1 as published
// by the Free Software Foundation, with special exception defined in the file
// OCCT_LGPL_EXCEPTION.txt. Consult the file LICENSE_LGPL_21.txt included in OCCT
// distribution for complete text of the license and disclaimer of any warranty.
//
// Alternatively, this file may be used under the terms of Open CASCADE
// commercial license or contractual agreement.

// #ifndef OCCT_DEBUG
// #define No_Standard_RangeError
// #define No_Standard_OutOfRange
// #endif

#define TOLTANGENCY 0.00000001
#define TOLERANCE_ANGULAIRE 1.e-12 // 0.00000001
#define TOLERANCE 0.00000001

#define NBSAMPLESONCIRCLE 32
#define NBSAMPLESONELLIPSE 32
#define NBSAMPLESONPARAB 16
#define NBSAMPLESONHYPR 32

#include <ElSLib.hxx>
#include <Intf_SectionPoint.hxx>
#include <Intf_TangentZone.hxx>
#include <Intf_Tool.hxx>
#include <math_FunctionSetRoot.hxx>
#include <IntCurveSurface_IntersectionPoint.hxx>
#include <IntCurveSurface_IntersectionSegment.hxx>
#include <IntAna_IntConicQuad.hxx>
#include <IntAna_Quadric.hxx>
#include <gp_Vec.hxx>
#include <gp_Dir.hxx>
#include <Precision.hxx>
#include <IntAna_IntLinTorus.hxx>

#include <GeomAbs_Shape.hxx>
#include <GeomAbs_CurveType.hxx>
#include <TColStd_Array1OfReal.hxx>
#include <TColgp_Array1OfPnt.hxx>
#include <gp_Pnt.hxx>
#include <gp_Pln.hxx>
#include <gp_Lin.hxx>
#include <GProp_PEquation.hxx>
#include <GProp_PGProps.hxx>
#include <GProp_PrincipalProps.hxx>
#include <Extrema_ExtElC.hxx>
#include <Extrema_POnCurv.hxx>

#include <ProjLib_Plane.hxx>
#include <IntAna2d_AnaIntersection.hxx>
#include <gp_Lin2d.hxx>
#include <IntAna2d_IntPoint.hxx>
#include <gp_Parab2d.hxx>
#include <IntAna2d_Conic.hxx>
#include <gp_Hypr2d.hxx>
#include <Adaptor3d_Curve.hxx>
#include <Adaptor3d_Surface.hxx>

#include <TColgp_Array2OfPnt.hxx>
#include <TColStd_HArray1OfReal.hxx>
#include <Adaptor3d_TopolTool.hxx>
#include <ElCLib.hxx>

#include "IntCurveSurface_InterUtils.pxx"

//=================================================================================================

IntCurveSurface_Inter::IntCurveSurface_Inter() {}

//=================================================================================================

void IntCurveSurface_Inter::DoSurface(const TheSurface&   surface,
                                      const Standard_Real u0,
                                      const Standard_Real u1,
                                      const Standard_Real v0,
                                      const Standard_Real v1,
                                      TColgp_Array2OfPnt& pntsOnSurface,
                                      Bnd_Box&            boxSurface,
                                      Standard_Real&      gap)
{
  IntCurveSurface_InterUtils::DoSurface<TheSurface, TheSurfaceTool>(surface,
                                                                    u0,
                                                                    u1,
                                                                    v0,
                                                                    v1,
                                                                    pntsOnSurface,
                                                                    boxSurface,
                                                                    gap);
}

//=================================================================================================

void IntCurveSurface_Inter::DoNewBounds(const TheSurface&           surface,
                                        const Standard_Real         u0,
                                        const Standard_Real         u1,
                                        const Standard_Real         v0,
                                        const Standard_Real         v1,
                                        const TColgp_Array2OfPnt&   pntsOnSurface,
                                        const TColStd_Array1OfReal& X,
                                        const TColStd_Array1OfReal& Y,
                                        const TColStd_Array1OfReal& Z,
                                        TColStd_Array1OfReal&       Bounds)
{
  IntCurveSurface_InterUtils::DoNewBounds<TheSurface, TheSurfaceTool>(surface,
                                                                      u0,
                                                                      u1,
                                                                      v0,
                                                                      v1,
                                                                      pntsOnSurface,
                                                                      X,
                                                                      Y,
                                                                      Z,
                                                                      Bounds);
}

//=======================================================================
// function : Perform
// purpose  : Decompose la surface si besoin est
//=======================================================================
void IntCurveSurface_Inter::Perform(const TheCurve& curve, const TheSurface& surface)
{
  ResetFields();
  done                    = Standard_True;
  Standard_Integer NbUOnS = TheSurfaceTool::NbUIntervals(surface, GeomAbs_C2);
  Standard_Integer NbVOnS = TheSurfaceTool::NbVIntervals(surface, GeomAbs_C2);
  Standard_Real    U0, U1, V0, V1;

  if (NbUOnS > 1)
  {
    TColStd_Array1OfReal TabU(1, NbUOnS + 1);
    TheSurfaceTool::UIntervals(surface, TabU, GeomAbs_C2);
    for (Standard_Integer iu = 1; iu <= NbUOnS; iu++)
    {
      U0 = TabU.Value(iu);
      U1 = TabU.Value(iu + 1);
      if (NbVOnS > 1)
      {
        TColStd_Array1OfReal TabV(1, NbVOnS + 1);
        TheSurfaceTool::VIntervals(surface, TabV, GeomAbs_C2);
        for (Standard_Integer iv = 1; iv <= NbVOnS; iv++)
        {
          // More than one interval on U and V param space.
          V0 = TabV.Value(iv);
          V1 = TabV.Value(iv + 1);
          Perform(curve, surface, U0, V0, U1, V1);
        }
      }
      else
      {
        // More than one interval only on U param space.
        V0 = TheSurfaceTool::FirstVParameter(surface);
        V1 = TheSurfaceTool::LastVParameter(surface);
        Perform(curve, surface, U0, V0, U1, V1);
      }
    }
  }
  else if (NbVOnS > 1)
  {
    // More than one interval only on V param space.
    U0 = TheSurfaceTool::FirstUParameter(surface);
    U1 = TheSurfaceTool::LastUParameter(surface);
    TColStd_Array1OfReal TabV(1, NbVOnS + 1);
    TheSurfaceTool::VIntervals(surface, TabV, GeomAbs_C2);
    for (Standard_Integer iv = 1; iv <= NbVOnS; iv++)
    {
      V0 = TabV.Value(iv);
      V1 = TabV.Value(iv + 1);
      Perform(curve, surface, U0, V0, U1, V1);
    }
  }
  else
  {
    // One interval on U and V param space.
    V0 = TheSurfaceTool::FirstVParameter(surface);
    V1 = TheSurfaceTool::LastVParameter(surface);
    U0 = TheSurfaceTool::FirstUParameter(surface);
    U1 = TheSurfaceTool::LastUParameter(surface);

    Perform(curve, surface, U0, V0, U1, V1);
  }
}

//=================================================================================================

void IntCurveSurface_Inter::Perform(const TheCurve&     curve,
                                    const TheSurface&   surface,
                                    const Standard_Real U1,
                                    const Standard_Real V1,
                                    const Standard_Real U2,
                                    const Standard_Real V2)
{
  // Protection from double type overflow.
  // This may happen inside square magnitude computation based on normal,
  // which was computed on bound parameters (bug26525).
  Standard_Real UU1 = U1, UU2 = U2, VV1 = V1, VV2 = V2;
  if (U1 < -1.0e50)
    UU1 = -1.0e50;
  if (U2 > 1.0e50)
    UU2 = 1.0e50;
  if (V1 < -1.0e50)
    VV1 = -1.0e50;
  if (V2 > 1.0e50)
    VV2 = 1.0e50;

  GeomAbs_CurveType CurveType = TheCurveTool::GetType(curve);

  switch (CurveType)
  {
    case GeomAbs_Line: {
      PerformConicSurf(TheCurveTool::Line(curve), curve, surface, UU1, VV1, UU2, VV2);
      break;
    }
    case GeomAbs_Circle: {
      PerformConicSurf(TheCurveTool::Circle(curve), curve, surface, UU1, VV1, UU2, VV2);
      break;
    }
    case GeomAbs_Ellipse: {
      PerformConicSurf(TheCurveTool::Ellipse(curve), curve, surface, UU1, VV1, UU2, VV2);
      break;
    }
    case GeomAbs_Parabola: {
      PerformConicSurf(TheCurveTool::Parabola(curve), curve, surface, UU1, VV1, UU2, VV2);
      break;
    }
    case GeomAbs_Hyperbola: {
      PerformConicSurf(TheCurveTool::Hyperbola(curve), curve, surface, UU1, VV1, UU2, VV2);
      break;
    }
    default: {
      Standard_Integer    nbIntervalsOnCurve = TheCurveTool::NbIntervals(curve, GeomAbs_C2);
      GeomAbs_SurfaceType SurfaceType        = TheSurfaceTool::GetType(surface);
      if ((SurfaceType != GeomAbs_Plane) && (SurfaceType != GeomAbs_Cylinder)
          && (SurfaceType != GeomAbs_Cone) && (SurfaceType != GeomAbs_Sphere))
      {

        if (nbIntervalsOnCurve > 1)
        {
          TColStd_Array1OfReal TabW(1, nbIntervalsOnCurve + 1);
          TheCurveTool::Intervals(curve, TabW, GeomAbs_C2);
          for (Standard_Integer i = 1; i <= nbIntervalsOnCurve; i++)
          {
            Standard_Real u1, u2;
            u1 = TabW.Value(i);
            u2 = TabW.Value(i + 1);

            Handle(TColStd_HArray1OfReal) aPars;
            Standard_Real                 defl  = 0.1;
            Standard_Integer              NbMin = 10;
            TheCurveTool::SamplePars(curve, u1, u2, defl, NbMin, aPars);

            // 	    IntCurveSurface_ThePolygon
            // polygon(curve,u1,u2,TheCurveTool::NbSamples(curve,u1,u2));
            IntCurveSurface_ThePolygon polygon(curve, aPars->Array1());
            InternalPerform(curve, polygon, surface, UU1, VV1, UU2, VV2);
          }
        }
        else
        {
          Standard_Real u1, u2;
          u1 = TheCurveTool::FirstParameter(curve);
          u2 = TheCurveTool::LastParameter(curve);

          Handle(TColStd_HArray1OfReal) aPars;
          Standard_Real                 defl  = 0.1;
          Standard_Integer              NbMin = 10;
          TheCurveTool::SamplePars(curve, u1, u2, defl, NbMin, aPars);

          // 	  IntCurveSurface_ThePolygon polygon(curve,TheCurveTool::NbSamples(curve,u1,u2));
          IntCurveSurface_ThePolygon polygon(curve, aPars->Array1());
          InternalPerform(curve, polygon, surface, UU1, VV1, UU2, VV2);
        }
      }
      else
      { //-- la surface est une quadrique
        InternalPerformCurveQuadric(curve, surface);
      }
    }
  }
}

//=================================================================================================

void IntCurveSurface_Inter::Perform(const TheCurve&                   curve,
                                    const IntCurveSurface_ThePolygon& polygon,
                                    const TheSurface&                 surface)
{
  ResetFields();
  done = Standard_True;
  Standard_Real u1, v1, u2, v2;
  u1 = TheSurfaceTool::FirstUParameter(surface);
  v1 = TheSurfaceTool::FirstVParameter(surface);
  u2 = TheSurfaceTool::LastUParameter(surface);
  v2 = TheSurfaceTool::LastVParameter(surface);
  Standard_Integer nbsu, nbsv;
  nbsu = TheSurfaceTool::NbSamplesU(surface, u1, u2);
  nbsv = TheSurfaceTool::NbSamplesV(surface, v1, v2);
  if (nbsu > 40)
    nbsu = 40;
  if (nbsv > 40)
    nbsv = 40;
  IntCurveSurface_ThePolyhedron polyhedron(surface, nbsu, nbsv, u1, v1, u2, v2);
  Perform(curve, polygon, surface, polyhedron);
}

//=================================================================================================

void IntCurveSurface_Inter::Perform(const TheCurve&                      curve,
                                    const TheSurface&                    surface,
                                    const IntCurveSurface_ThePolyhedron& polyhedron)
{
  ResetFields();
  done                          = Standard_True;
  Standard_Real              u1 = TheCurveTool::FirstParameter(curve);
  Standard_Real              u2 = TheCurveTool::LastParameter(curve);
  IntCurveSurface_ThePolygon polygon(curve, TheCurveTool::NbSamples(curve, u1, u2));
  Perform(curve, polygon, surface, polyhedron);
}

//=================================================================================================

void IntCurveSurface_Inter::Perform(const TheCurve&                      curve,
                                    const IntCurveSurface_ThePolygon&    polygon,
                                    const TheSurface&                    surface,
                                    const IntCurveSurface_ThePolyhedron& polyhedron)
{
  ResetFields();
  done = Standard_True;
  Standard_Real u1, v1, u2, v2;
  u1 = TheSurfaceTool::FirstUParameter(surface);
  v1 = TheSurfaceTool::FirstVParameter(surface);
  u2 = TheSurfaceTool::LastUParameter(surface);
  v2 = TheSurfaceTool::LastVParameter(surface);
  InternalPerform(curve, polygon, surface, polyhedron, u1, v1, u2, v2);
}

//=================================================================================================

void IntCurveSurface_Inter::Perform(const TheCurve&                      curve,
                                    const IntCurveSurface_ThePolygon&    polygon,
                                    const TheSurface&                    surface,
                                    const IntCurveSurface_ThePolyhedron& polyhedron,
                                    Bnd_BoundSortBox&                    BndBSB)
{
  ResetFields();
  done = Standard_True;
  Standard_Real u1, v1, u2, v2;
  u1 = TheSurfaceTool::FirstUParameter(surface);
  v1 = TheSurfaceTool::FirstVParameter(surface);
  u2 = TheSurfaceTool::LastUParameter(surface);
  v2 = TheSurfaceTool::LastVParameter(surface);
  InternalPerform(curve, polygon, surface, polyhedron, u1, v1, u2, v2, BndBSB);
}

//=======================================================================
// function : InternalPerform
// purpose  : C a l c u l   d u   p o i n t   a p p r o c h e
//==              p u i s   d u   p o i n t   E x a c t
//=======================================================================
void IntCurveSurface_Inter::InternalPerform(const TheCurve&                      curve,
                                            const IntCurveSurface_ThePolygon&    polygon,
                                            const TheSurface&                    surface,
                                            const IntCurveSurface_ThePolyhedron& polyhedron,
                                            const Standard_Real                  u0,
                                            const Standard_Real                  v0,
                                            const Standard_Real                  u1,
                                            const Standard_Real                  v1,
                                            Bnd_BoundSortBox&                    BSB)
{
  IntCurveSurface_TheInterference interference(polygon, polyhedron, BSB);
  IntCurveSurface_TheCSFunction   theicsfunction(surface, curve);
  IntCurveSurface_TheExactInter   intersectionExacte(theicsfunction, TOLTANGENCY);
  math_FunctionSetRoot            rsnld(intersectionExacte.Function());

  //  Standard_Real    u,v,w,winit;
  Standard_Real    u, v, w;
  gp_Pnt           P;
  Standard_Real    winf            = polygon.InfParameter();
  Standard_Real    wsup            = polygon.SupParameter();
  Standard_Integer NbSectionPoints = interference.NbSectionPoints();
  Standard_Integer NbTangentZones  = interference.NbTangentZones();

  //-- Les interferences renvoient parfois de nombreuses fois (>20) les memes points

  Standard_Integer i, NbStartPoints = NbSectionPoints;
  for (i = 1; i <= NbTangentZones; i++)
  {
    const Intf_TangentZone& TZ     = interference.ZoneValue(i);
    Standard_Integer        nbpnts = TZ.NumberOfPoints();
    NbStartPoints += nbpnts;
  }

  if (NbStartPoints)
  {
    Standard_Real*   TabU       = new Standard_Real[NbStartPoints + 1];
    Standard_Real*   TabV       = new Standard_Real[NbStartPoints + 1];
    Standard_Real*   TabW       = new Standard_Real[NbStartPoints + 1];
    Standard_Integer IndexPoint = 0;

    for (i = 1; i <= NbSectionPoints; i++)
    {
      const Intf_SectionPoint& SP = interference.PntValue(i);
      IntCurveSurface_InterUtils::SectionPointToParameters<IntCurveSurface_ThePolyhedron,
                                                           IntCurveSurface_ThePolygon>(SP,
                                                                                       polyhedron,
                                                                                       polygon,
                                                                                       u,
                                                                                       v,
                                                                                       w);
      TabU[IndexPoint] = u;
      TabV[IndexPoint] = v;
      TabW[IndexPoint] = w;
      IndexPoint++;
    }
    for (i = 1; i <= NbTangentZones; i++)
    {
      const Intf_TangentZone& TZ     = interference.ZoneValue(i);
      Standard_Integer        nbpnts = TZ.NumberOfPoints();
      for (Standard_Integer j = 1; j <= nbpnts; j++)
      {
        const Intf_SectionPoint& SP = TZ.GetPoint(j);
        IntCurveSurface_InterUtils::SectionPointToParameters<IntCurveSurface_ThePolyhedron,
                                                             IntCurveSurface_ThePolygon>(SP,
                                                                                         polyhedron,
                                                                                         polygon,
                                                                                         u,
                                                                                         v,
                                                                                         w);
        TabU[IndexPoint] = u;
        TabV[IndexPoint] = v;
        TabW[IndexPoint] = w;
        IndexPoint++;
      }
    }

    //-- Tri
    Standard_Real su = 0, sv = 0, sw = 0, ptol;
    ptol = 10 * Precision::PConfusion();

    //-- Tri suivant la variable W
    Standard_Boolean Triok;
    do
    {
      Triok = Standard_True;
      Standard_Integer im1;
      for (i = 1, im1 = 0; i < NbStartPoints; im1++, i++)
      {
        if (TabW[i] < TabW[im1])
        {
          Standard_Real t = TabW[i];
          TabW[i]         = TabW[im1];
          TabW[im1]       = t;
          t               = TabU[i];
          TabU[i]         = TabU[im1];
          TabU[im1]       = t;
          t               = TabV[i];
          TabV[i]         = TabV[im1];
          TabV[im1]       = t;
          Triok           = Standard_False;
        }
      }
    } while (Triok == Standard_False);

    //-- On trie pour des meme W suivant U
    do
    {
      Triok = Standard_True;
      Standard_Integer im1;
      for (i = 1, im1 = 0; i < NbStartPoints; im1++, i++)
      {
        // modified by NIZHNY-MKK  Mon Oct  3 17:38:49 2005
        // 	if(std::abs(TabW[i]-TabW[im1])<ptol) {
        if ((TabW[i] - TabW[im1]) < ptol)
        {
          TabW[i] = TabW[im1];
          if (TabU[i] < TabU[im1])
          {
            Standard_Real t = TabU[i];
            TabU[i]         = TabU[im1];
            TabU[im1]       = t;
            t               = TabV[i];
            TabV[i]         = TabV[im1];
            TabV[im1]       = t;
            Triok           = Standard_False;
          }
        }
      }
    } while (Triok == Standard_False);

    //-- On trie pour des meme U et W suivant V
    do
    {
      Triok = Standard_True;
      Standard_Integer im1;
      for (i = 1, im1 = 0; i < NbStartPoints; im1++, i++)
      {
        // modified by NIZHNY-MKK  Mon Oct  3 17:38:52 2005
        // 	if((std::abs(TabW[i]-TabW[im1])<ptol) && (std::abs(TabU[i]-TabU[im1])<ptol)) {
        if (((TabW[i] - TabW[im1]) < ptol) && ((TabU[i] - TabU[im1]) < ptol))
        {
          TabU[i] = TabU[im1];
          if (TabV[i] < TabV[im1])
          {
            Standard_Real t = TabV[i];
            TabV[i]         = TabV[im1];
            TabV[im1]       = t;
            Triok           = Standard_False;
          }
        }
      }
    } while (Triok == Standard_False);

    for (i = 0; i < NbStartPoints; i++)
    {
      u = TabU[i];
      v = TabV[i];
      w = TabW[i];
      if (i == 0)
      {
        su = u - 1;
      }
      if (std::abs(u - su) > ptol || std::abs(v - sv) > ptol || std::abs(w - sw) > ptol)
      {
        intersectionExacte.Perform(u, v, w, rsnld, u0, u1, v0, v1, winf, wsup);
        if (intersectionExacte.IsDone())
        {
          if (!intersectionExacte.IsEmpty())
          {
            P = intersectionExacte.Point();
            w = intersectionExacte.ParameterOnCurve();
            intersectionExacte.ParameterOnSurface(u, v);
            AppendPoint(curve, w, surface, u, v);
          }
        }
      }
      su = TabU[i];
      sv = TabV[i];
      sw = TabW[i];
    }
    delete[] TabW;
    delete[] TabV;
    delete[] TabU;
  }
}

//=================================================================================================

void IntCurveSurface_Inter::InternalPerform(const TheCurve&                      curve,
                                            const IntCurveSurface_ThePolygon&    polygon,
                                            const TheSurface&                    surface,
                                            const IntCurveSurface_ThePolyhedron& polyhedron,
                                            const Standard_Real                  u0,
                                            const Standard_Real                  v0,
                                            const Standard_Real                  u1,
                                            const Standard_Real                  v1)
{
  IntCurveSurface_TheInterference interference(polygon, polyhedron);
  IntCurveSurface_TheCSFunction   theicsfunction(surface, curve);
  IntCurveSurface_TheExactInter   intersectionExacte(theicsfunction, TOLTANGENCY);
  math_FunctionSetRoot            rsnld(intersectionExacte.Function());

  //  Standard_Real    u,v,w,winit;
  Standard_Real    u, v, w;
  gp_Pnt           P;
  Standard_Real    winf            = polygon.InfParameter();
  Standard_Real    wsup            = polygon.SupParameter();
  Standard_Integer NbSectionPoints = interference.NbSectionPoints();
  Standard_Integer NbTangentZones  = interference.NbTangentZones();

  //-- Les interferences renvoient parfois de nombreuses fois (>20) les memes points

  Standard_Integer i, NbStartPoints = NbSectionPoints;
  for (i = 1; i <= NbTangentZones; i++)
  {
    const Intf_TangentZone& TZ     = interference.ZoneValue(i);
    Standard_Integer        nbpnts = TZ.NumberOfPoints();
    NbStartPoints += nbpnts;
  }

  if (NbStartPoints)
  {
    Standard_Real*   TabU       = new Standard_Real[NbStartPoints + 1];
    Standard_Real*   TabV       = new Standard_Real[NbStartPoints + 1];
    Standard_Real*   TabW       = new Standard_Real[NbStartPoints + 1];
    Standard_Integer IndexPoint = 0;

    for (i = 1; i <= NbSectionPoints; i++)
    {
      const Intf_SectionPoint& SP = interference.PntValue(i);
      IntCurveSurface_InterUtils::SectionPointToParameters<IntCurveSurface_ThePolyhedron,
                                                           IntCurveSurface_ThePolygon>(SP,
                                                                                       polyhedron,
                                                                                       polygon,
                                                                                       u,
                                                                                       v,
                                                                                       w);
      TabU[IndexPoint] = u;
      TabV[IndexPoint] = v;
      TabW[IndexPoint] = w;
      IndexPoint++;
    }
    for (i = 1; i <= NbTangentZones; i++)
    {
      const Intf_TangentZone& TZ     = interference.ZoneValue(i);
      Standard_Integer        nbpnts = TZ.NumberOfPoints();
      for (Standard_Integer j = 1; j <= nbpnts; j++)
      {
        const Intf_SectionPoint& SP = TZ.GetPoint(j);
        IntCurveSurface_InterUtils::SectionPointToParameters<IntCurveSurface_ThePolyhedron,
                                                             IntCurveSurface_ThePolygon>(SP,
                                                                                         polyhedron,
                                                                                         polygon,
                                                                                         u,
                                                                                         v,
                                                                                         w);
        TabU[IndexPoint] = u;
        TabV[IndexPoint] = v;
        TabW[IndexPoint] = w;
        IndexPoint++;
      }
    }

    //-- Tri
    Standard_Real su = 0, sv = 0, sw = 0, ptol;
    ptol = 10 * Precision::PConfusion();

    //-- Tri suivant la variable W
    Standard_Boolean Triok;
    do
    {
      Triok = Standard_True;
      Standard_Integer im1;
      for (i = 1, im1 = 0; i < NbStartPoints; im1++, i++)
      {
        if (TabW[i] < TabW[im1])
        {
          Standard_Real t = TabW[i];
          TabW[i]         = TabW[im1];
          TabW[im1]       = t;
          t               = TabU[i];
          TabU[i]         = TabU[im1];
          TabU[im1]       = t;
          t               = TabV[i];
          TabV[i]         = TabV[im1];
          TabV[im1]       = t;
          Triok           = Standard_False;
        }
      }
    } while (Triok == Standard_False);

    //-- On trie pour des meme W suivant U
    do
    {
      Triok = Standard_True;
      Standard_Integer im1;
      for (i = 1, im1 = 0; i < NbStartPoints; im1++, i++)
      {
        // modified by NIZHNY-MKK  Mon Oct  3 17:38:56 2005
        // 	if(std::abs(TabW[i]-TabW[im1])<ptol) {
        if ((TabW[i] - TabW[im1]) < ptol)
        {
          TabW[i] = TabW[im1];
          if (TabU[i] < TabU[im1])
          {
            Standard_Real t = TabU[i];
            TabU[i]         = TabU[im1];
            TabU[im1]       = t;
            t               = TabV[i];
            TabV[i]         = TabV[im1];
            TabV[im1]       = t;
            Triok           = Standard_False;
          }
        }
      }
    } while (Triok == Standard_False);

    //-- On trie pour des meme U et W suivant V
    do
    {
      Triok = Standard_True;
      Standard_Integer im1;
      for (i = 1, im1 = 0; i < NbStartPoints; im1++, i++)
      {
        // modified by NIZHNY-MKK  Mon Oct  3 17:38:58 2005
        // 	if((std::abs(TabW[i]-TabW[im1])<ptol) && (std::abs(TabU[i]-TabU[im1])<ptol)) {
        if (((TabW[i] - TabW[im1]) < ptol) && ((TabU[i] - TabU[im1]) < ptol))
        {
          TabU[i] = TabU[im1];
          if (TabV[i] < TabV[im1])
          {
            Standard_Real t = TabV[i];
            TabV[i]         = TabV[im1];
            TabV[im1]       = t;
            Triok           = Standard_False;
          }
        }
      }
    } while (Triok == Standard_False);

    for (i = 0; i < NbStartPoints; i++)
    {
      u = TabU[i];
      v = TabV[i];
      w = TabW[i];
      if (i == 0)
      {
        su = u - 1;
      }
      if (std::abs(u - su) > ptol || std::abs(v - sv) > ptol || std::abs(w - sw) > ptol)
      {
        intersectionExacte.Perform(u, v, w, rsnld, u0, u1, v0, v1, winf, wsup);
        if (intersectionExacte.IsDone())
        {
          if (!intersectionExacte.IsEmpty())
          {
            P = intersectionExacte.Point();
            w = intersectionExacte.ParameterOnCurve();
            intersectionExacte.ParameterOnSurface(u, v);
            AppendPoint(curve, w, surface, u, v);
          }
        }
      }
      su = TabU[i];
      sv = TabV[i];
      sw = TabW[i];
    }
    delete[] TabW;
    delete[] TabV;
    delete[] TabU;
  }
}

//=================================================================================================

void IntCurveSurface_Inter::InternalPerformCurveQuadric(const TheCurve&   curve,
                                                        const TheSurface& surface)
{
  IntCurveSurface_TheQuadCurvExactInter QuadCurv(surface, curve);
  if (QuadCurv.IsDone())
  {
    Standard_Integer NbRoots = QuadCurv.NbRoots();
    Standard_Real    u, v, w;
    for (Standard_Integer i = 1; i <= NbRoots; i++)
    {
      w = QuadCurv.Root(i);
      IntCurveSurface_InterUtils::ComputeParamsOnQuadric<TheSurface, TheSurfaceTool>(
        surface,
        TheCurveTool::Value(curve, w),
        u,
        v);
      AppendPoint(curve, w, surface, u, v);
    }
    //-- Intervals non traites .............................................
  }
}

//=================================================================================================

void IntCurveSurface_Inter::InternalPerform(const TheCurve&                   curve,
                                            const IntCurveSurface_ThePolygon& polygon,
                                            const TheSurface&                 surface,
                                            const Standard_Real               U1,
                                            const Standard_Real               V1,
                                            const Standard_Real               U2,
                                            const Standard_Real               V2)
{
  GeomAbs_SurfaceType SurfaceType = TheSurfaceTool::GetType(surface);
  if ((SurfaceType != GeomAbs_Plane) && (SurfaceType != GeomAbs_Cylinder)
      && (SurfaceType != GeomAbs_Cone) && (SurfaceType != GeomAbs_Sphere))
  {
    if (SurfaceType != GeomAbs_BSplineSurface)
    {
      Standard_Integer nbsu, nbsv;
      nbsu = TheSurfaceTool::NbSamplesU(surface, U1, U2);
      nbsv = TheSurfaceTool::NbSamplesV(surface, V1, V2);
      if (nbsu > 40)
        nbsu = 40;
      if (nbsv > 40)
        nbsv = 40;
      IntCurveSurface_ThePolyhedron polyhedron(surface, nbsu, nbsv, U1, V1, U2, V2);
      InternalPerform(curve, polygon, surface, polyhedron, U1, V1, U2, V2);
    }
    else
    {
      Handle(Adaptor3d_Surface) aS         = TheSurfaceTool::UTrim(surface, U1, U2, 1.e-9);
      aS                                   = aS->VTrim(V1, V2, 1.e-9);
      Handle(Adaptor3d_TopolTool) aTopTool = new Adaptor3d_TopolTool(aS);
      Standard_Real               defl     = 0.1;
      aTopTool->SamplePnts(defl, 10, 10);

      Standard_Integer     nbpu = aTopTool->NbSamplesU();
      Standard_Integer     nbpv = aTopTool->NbSamplesV();
      TColStd_Array1OfReal Upars(1, nbpu), Vpars(1, nbpv);
      aTopTool->UParameters(Upars);
      aTopTool->VParameters(Vpars);

      IntCurveSurface_ThePolyhedron polyhedron(surface, Upars, Vpars);
      InternalPerform(curve, polygon, surface, polyhedron, U1, V1, U2, V2);
    }
  }
  else
  {
    IntCurveSurface_TheQuadCurvExactInter QuadCurv(surface, curve);
    if (QuadCurv.IsDone())
    {
      Standard_Integer NbRoots = QuadCurv.NbRoots();
      Standard_Real    u, v, w;
      for (Standard_Integer i = 1; i <= NbRoots; i++)
      {
        w = QuadCurv.Root(i);
        IntCurveSurface_InterUtils::ComputeParamsOnQuadric<TheSurface, TheSurfaceTool>(
          surface,
          TheCurveTool::Value(curve, w),
          u,
          v);
        AppendPoint(curve, w, surface, u, v);
      }
      //-- Intervalles non traites .............................................
    }
  } //-- Fin : la Surface  est une quadrique
}

//=================================================================================================

void IntCurveSurface_Inter::PerformConicSurf(const gp_Lin&       Line,
                                             const TheCurve&     curve,
                                             const TheSurface&   surface,
                                             const Standard_Real U1,
                                             const Standard_Real V1,
                                             const Standard_Real U2,
                                             const Standard_Real V2)
{

  GeomAbs_SurfaceType SurfaceType    = TheSurfaceTool::GetType(surface);
  Standard_Boolean    isAnaProcessed = Standard_True;
  switch (SurfaceType)
  {
    case GeomAbs_Plane: {
      IntAna_IntConicQuad LinPlane(Line, TheSurfaceTool::Plane(surface), TOLERANCE_ANGULAIRE);
      AppendIntAna(curve, surface, LinPlane);
      break;
    }
    case GeomAbs_Cylinder: {
      IntAna_IntConicQuad LinCylinder(Line, TheSurfaceTool::Cylinder(surface));
      AppendIntAna(curve, surface, LinCylinder);
      break;
    }
    case GeomAbs_Sphere: {
      IntAna_IntConicQuad LinSphere(Line, TheSurfaceTool::Sphere(surface));
      AppendIntAna(curve, surface, LinSphere);
      break;
    }
    case GeomAbs_Torus: {
      IntAna_IntLinTorus intlintorus(Line, TheSurfaceTool::Torus(surface));
      if (intlintorus.IsDone())
      {
        Standard_Integer nbp = intlintorus.NbPoints();
        Standard_Real    fi, theta, w;
        for (Standard_Integer i = 1; i <= nbp; i++)
        {
          const gp_Pnt aDebPnt(intlintorus.Value(i));
          (void)aDebPnt;
          w = intlintorus.ParamOnLine(i);
          intlintorus.ParamOnTorus(i, fi, theta);
          AppendPoint(curve, w, surface, fi, theta);
        }
      }
      else
        isAnaProcessed = Standard_False;
      break;
    }
    case GeomAbs_Cone: {
      constexpr Standard_Real correction = 1.E+5 * Precision::Angular();
      gp_Cone                 cn         = TheSurfaceTool::Cone(surface);
      if (std::abs(cn.SemiAngle()) < M_PI / 2.0 - correction)
      {
        IntAna_IntConicQuad LinCone(Line, cn);
        AppendIntAna(curve, surface, LinCone);
      }
      else
        isAnaProcessed = Standard_False;
      break;
    }
    default:
      isAnaProcessed = Standard_False;
  }
  if (!isAnaProcessed)
  {
    Standard_Integer nbsu, nbsv;
    nbsu = TheSurfaceTool::NbSamplesU(surface, U1, U2);
    nbsv = TheSurfaceTool::NbSamplesV(surface, V1, V2);

    Standard_Boolean U1inf = Precision::IsInfinite(U1);
    Standard_Boolean U2inf = Precision::IsInfinite(U2);
    Standard_Boolean V1inf = Precision::IsInfinite(V1);
    Standard_Boolean V2inf = Precision::IsInfinite(V2);

    Standard_Real U1new = U1, U2new = U2, V1new = V1, V2new = V2;

    Standard_Boolean NoIntersection = Standard_False;

    if (U1inf || U2inf || V1inf || V2inf)
    {

      if (SurfaceType == GeomAbs_SurfaceOfExtrusion)
      {

        IntCurveSurface_InterUtils::EstLimForInfExtr<TheSurface, TheSurfaceTool>(Line,
                                                                                 surface,
                                                                                 Standard_False,
                                                                                 nbsu,
                                                                                 U1inf,
                                                                                 U2inf,
                                                                                 V1inf,
                                                                                 V2inf,
                                                                                 U1new,
                                                                                 U2new,
                                                                                 V1new,
                                                                                 V2new,
                                                                                 NoIntersection);
      }
      else if (SurfaceType == GeomAbs_SurfaceOfRevolution)
      {

        IntCurveSurface_InterUtils::EstLimForInfRevl<TheSurface, TheSurfaceTool>(Line,
                                                                                 surface,
                                                                                 U1inf,
                                                                                 U2inf,
                                                                                 V1inf,
                                                                                 V2inf,
                                                                                 U1new,
                                                                                 U2new,
                                                                                 V1new,
                                                                                 V2new,
                                                                                 NoIntersection);
      }
      else if (SurfaceType == GeomAbs_OffsetSurface)
      {

        IntCurveSurface_InterUtils::EstLimForInfOffs<TheSurface, TheSurfaceTool>(Line,
                                                                                 surface,
                                                                                 nbsu,
                                                                                 U1inf,
                                                                                 U2inf,
                                                                                 V1inf,
                                                                                 V2inf,
                                                                                 U1new,
                                                                                 U2new,
                                                                                 V1new,
                                                                                 V2new,
                                                                                 NoIntersection);
      }
      else
      {

        IntCurveSurface_InterUtils::EstLimForInfSurf(U1new, U2new, V1new, V2new);
      }
    }

    if (NoIntersection)
      return;

    // modified by NIZHNY-OFV  Mon Aug 20 14:56:47 2001 (60963 begin)
    if (nbsu < 20)
      nbsu = 20;
    if (nbsv < 20)
      nbsv = 20;
    // modified by NIZHNY-OFV  Mon Aug 20 14:57:06 2001 (60963 end)
    IntCurveSurface_ThePolyhedron polyhedron(surface, nbsu, nbsv, U1new, V1new, U2new, V2new);
    Intf_Tool                     bndTool;
    Bnd_Box                       boxLine;
    bndTool.LinBox(Line, polyhedron.Bounding(), boxLine);
    for (Standard_Integer nbseg = 1; nbseg <= bndTool.NbSegments(); nbseg++)
    {
      Standard_Real pinf = bndTool.BeginParam(nbseg);
      Standard_Real psup = bndTool.EndParam(nbseg);
      if ((psup - pinf) < 1e-10)
      {
        pinf -= 1e-10;
        psup += 1e-10;
      }
      IntCurveSurface_ThePolygon polygon(curve, pinf, psup, 2);
      InternalPerform(curve, polygon, surface, polyhedron, U1new, V1new, U2new, V2new);
    }
  }
}

//=================================================================================================

void IntCurveSurface_Inter::PerformConicSurf(const gp_Circ&      Circle,
                                             const TheCurve&     curve,
                                             const TheSurface&   surface,
                                             const Standard_Real U1,
                                             const Standard_Real V1,
                                             const Standard_Real U2,
                                             const Standard_Real V2)
{

  GeomAbs_SurfaceType SurfaceType = TheSurfaceTool::GetType(surface);
  switch (SurfaceType)
  {
    case GeomAbs_Plane: {
      IntAna_IntConicQuad CircPlane(Circle,
                                    TheSurfaceTool::Plane(surface),
                                    TOLERANCE_ANGULAIRE,
                                    TOLERANCE);
      AppendIntAna(curve, surface, CircPlane);
      break;
    }
    case GeomAbs_Cylinder: {
      IntAna_IntConicQuad CircCylinder(Circle, TheSurfaceTool::Cylinder(surface));
      AppendIntAna(curve, surface, CircCylinder);
      break;
    }
    case GeomAbs_Cone: {
      IntAna_IntConicQuad CircCone(Circle, TheSurfaceTool::Cone(surface));
      AppendIntAna(curve, surface, CircCone);
      break;
    }
    case GeomAbs_Sphere: {
      IntAna_IntConicQuad CircSphere(Circle, TheSurfaceTool::Sphere(surface));
      AppendIntAna(curve, surface, CircSphere);
      break;
    }
    default: {
      IntCurveSurface_ThePolygon polygon(curve, NBSAMPLESONCIRCLE);
      InternalPerform(curve, polygon, surface, U1, V1, U2, V2);
    }
  }
}

//=================================================================================================

void IntCurveSurface_Inter::PerformConicSurf(const gp_Elips&     Ellipse,
                                             const TheCurve&     curve,
                                             const TheSurface&   surface,
                                             const Standard_Real U1,
                                             const Standard_Real V1,
                                             const Standard_Real U2,
                                             const Standard_Real V2)
{

  GeomAbs_SurfaceType SurfaceType = TheSurfaceTool::GetType(surface);
  switch (SurfaceType)
  {
    case GeomAbs_Plane: {
      IntAna_IntConicQuad EllipsePlane(Ellipse,
                                       TheSurfaceTool::Plane(surface),
                                       TOLERANCE_ANGULAIRE,
                                       TOLERANCE);
      AppendIntAna(curve, surface, EllipsePlane);
      break;
    }
    case GeomAbs_Cylinder: {
      IntAna_IntConicQuad EllipseCylinder(Ellipse, TheSurfaceTool::Cylinder(surface));
      AppendIntAna(curve, surface, EllipseCylinder);
      break;
    }
    case GeomAbs_Cone: {
      IntAna_IntConicQuad EllipseCone(Ellipse, TheSurfaceTool::Cone(surface));
      AppendIntAna(curve, surface, EllipseCone);
      break;
    }
    case GeomAbs_Sphere: {
      IntAna_IntConicQuad EllipseSphere(Ellipse, TheSurfaceTool::Sphere(surface));
      AppendIntAna(curve, surface, EllipseSphere);
      break;
    }
    default: {
      IntCurveSurface_ThePolygon polygon(curve, NBSAMPLESONELLIPSE);
      InternalPerform(curve, polygon, surface, U1, V1, U2, V2);
    }
  }
}

//=================================================================================================

void IntCurveSurface_Inter::PerformConicSurf(const gp_Parab&     Parab,
                                             const TheCurve&     curve,
                                             const TheSurface&   surface,
                                             const Standard_Real U1,
                                             const Standard_Real V1,
                                             const Standard_Real U2,
                                             const Standard_Real V2)
{

  GeomAbs_SurfaceType SurfaceType = TheSurfaceTool::GetType(surface);
  switch (SurfaceType)
  {
    case GeomAbs_Plane: {
      IntAna_IntConicQuad ParabPlane(Parab, TheSurfaceTool::Plane(surface), TOLERANCE_ANGULAIRE);
      AppendIntAna(curve, surface, ParabPlane);
      break;
    }
    case GeomAbs_Cylinder: {
      IntAna_IntConicQuad ParabCylinder(Parab, TheSurfaceTool::Cylinder(surface));
      AppendIntAna(curve, surface, ParabCylinder);
      break;
    }
    case GeomAbs_Cone: {
      IntAna_IntConicQuad ParabCone(Parab, TheSurfaceTool::Cone(surface));
      AppendIntAna(curve, surface, ParabCone);
      break;
    }
    case GeomAbs_Sphere: {
      IntAna_IntConicQuad ParabSphere(Parab, TheSurfaceTool::Sphere(surface));
      AppendIntAna(curve, surface, ParabSphere);
      break;
    }
    default: {
      Standard_Integer nbsu, nbsv;
      nbsu = TheSurfaceTool::NbSamplesU(surface, U1, U2);
      nbsv = TheSurfaceTool::NbSamplesV(surface, V1, V2);
      if (nbsu > 40)
        nbsu = 40;
      if (nbsv > 40)
        nbsv = 40;
      IntCurveSurface_ThePolyhedron polyhedron(surface, nbsu, nbsv, U1, V1, U2, V2);
      Intf_Tool                     bndTool;
      Bnd_Box                       boxParab;
      bndTool.ParabBox(Parab, polyhedron.Bounding(), boxParab);
      for (Standard_Integer nbseg = 1; nbseg <= bndTool.NbSegments(); nbseg++)
      {
        IntCurveSurface_ThePolygon polygon(curve,
                                           bndTool.BeginParam(nbseg),
                                           bndTool.EndParam(nbseg),
                                           NBSAMPLESONPARAB);
        InternalPerform(curve, polygon, surface, polyhedron, U1, V1, U2, V2);
      }
    }
  }
}

//=================================================================================================

void IntCurveSurface_Inter::PerformConicSurf(const gp_Hypr&      Hypr,
                                             const TheCurve&     curve,
                                             const TheSurface&   surface,
                                             const Standard_Real U1,
                                             const Standard_Real V1,
                                             const Standard_Real U2,
                                             const Standard_Real V2)
{

  GeomAbs_SurfaceType SurfaceType = TheSurfaceTool::GetType(surface);
  switch (SurfaceType)
  {
    case GeomAbs_Plane: {
      IntAna_IntConicQuad HyprPlane(Hypr, TheSurfaceTool::Plane(surface), TOLERANCE_ANGULAIRE);
      AppendIntAna(curve, surface, HyprPlane);
      break;
    }
    case GeomAbs_Cylinder: {
      IntAna_IntConicQuad HyprCylinder(Hypr, TheSurfaceTool::Cylinder(surface));
      AppendIntAna(curve, surface, HyprCylinder);
      break;
    }
    case GeomAbs_Cone: {
      IntAna_IntConicQuad HyprCone(Hypr, TheSurfaceTool::Cone(surface));
      AppendIntAna(curve, surface, HyprCone);
      break;
    }
    case GeomAbs_Sphere: {
      IntAna_IntConicQuad HyprSphere(Hypr, TheSurfaceTool::Sphere(surface));
      AppendIntAna(curve, surface, HyprSphere);
      break;
    }
    default: {
      Standard_Integer nbsu, nbsv;
      nbsu = TheSurfaceTool::NbSamplesU(surface, U1, U2);
      nbsv = TheSurfaceTool::NbSamplesV(surface, V1, V2);
      if (nbsu > 40)
        nbsu = 40;
      if (nbsv > 40)
        nbsv = 40;
      IntCurveSurface_ThePolyhedron polyhedron(surface, nbsu, nbsv, U1, V1, U2, V2);
      Intf_Tool                     bndTool;
      Bnd_Box                       boxHypr;
      bndTool.HyprBox(Hypr, polyhedron.Bounding(), boxHypr);
      for (Standard_Integer nbseg = 1; nbseg <= bndTool.NbSegments(); nbseg++)
      {
        IntCurveSurface_ThePolygon polygon(curve,
                                           bndTool.BeginParam(nbseg),
                                           bndTool.EndParam(nbseg),
                                           NBSAMPLESONHYPR);
        InternalPerform(curve, polygon, surface, polyhedron, U1, V1, U2, V2);
      }
    }
  }
}

//=================================================================================================

void IntCurveSurface_Inter::AppendIntAna(const TheCurve&            curve,
                                         const TheSurface&          surface,
                                         const IntAna_IntConicQuad& intana_ConicQuad)
{
  if (intana_ConicQuad.IsDone())
  {
    if (intana_ConicQuad.IsInQuadric())
    {
      //-- std::cout<<" Courbe Dans la Quadrique !!! Non Traite !!!"<<std::endl;
      myIsParallel = Standard_True;
    }
    else if (intana_ConicQuad.IsParallel())
    {
      //-- std::cout<<" Courbe // a la Quadrique !!! Non Traite !!!"<<std::endl;
      myIsParallel = Standard_True;
    }
    else
    {
      Standard_Integer nbp = intana_ConicQuad.NbPoints();
      Standard_Real    u, v, w;
      for (Standard_Integer i = 1; i <= nbp; i++)
      {
        gp_Pnt P(intana_ConicQuad.Point(i));
        w = intana_ConicQuad.ParamOnConic(i);
        IntCurveSurface_InterUtils::ComputeParamsOnQuadric<TheSurface, TheSurfaceTool>(surface,
                                                                                       P,
                                                                                       u,
                                                                                       v);
        AppendPoint(curve, w, surface, u, v);
      }
    }
  }
  else
  {
    //-- std::cout<<" IntAna Conic Quad Not Done  "<<std::endl;
  }
}

//=================================================================================================

void IntCurveSurface_Inter::AppendPoint(const TheCurve&     curve,
                                        const Standard_Real lw,
                                        const TheSurface&   surface,
                                        const Standard_Real su,
                                        const Standard_Real sv)
{

  Standard_Real W0 = TheCurveTool::FirstParameter(curve);
  Standard_Real W1 = TheCurveTool::LastParameter(curve);
  Standard_Real U0 = TheSurfaceTool::FirstUParameter(surface);
  Standard_Real U1 = TheSurfaceTool::LastUParameter(surface);
  Standard_Real V0 = TheSurfaceTool::FirstVParameter(surface);
  Standard_Real V1 = TheSurfaceTool::LastVParameter(surface);
  //-- Test si la courbe est periodique
  Standard_Real w = lw, u = su, v = sv;

  GeomAbs_CurveType aCType = TheCurveTool::GetType(curve);

  if (TheCurveTool::IsPeriodic(curve) || aCType == GeomAbs_Circle || aCType == GeomAbs_Ellipse)
  {
    w = ElCLib::InPeriod(w, W0, W0 + TheCurveTool::Period(curve));
  }

  if ((W0 - w) >= TOLTANGENCY || (w - W1) >= TOLTANGENCY)
    return;

  GeomAbs_SurfaceType aSType = TheSurfaceTool::GetType(surface);
  if (TheSurfaceTool::IsUPeriodic(surface) || aSType == GeomAbs_Cylinder || aSType == GeomAbs_Cone
      || aSType == GeomAbs_Sphere)
  {
    u = ElCLib::InPeriod(u, U0, U0 + TheSurfaceTool::UPeriod(surface));
  }

  if (TheSurfaceTool::IsVPeriodic(surface))
  {
    v = ElCLib::InPeriod(v, V0, V0 + TheSurfaceTool::VPeriod(surface));
  }

  if ((U0 - u) >= TOLTANGENCY || (u - U1) >= TOLTANGENCY)
    return;
  if ((V0 - v) >= TOLTANGENCY || (v - V1) >= TOLTANGENCY)
    return;

  IntCurveSurface_TransitionOnCurve TransOnCurve;
  IntCurveSurface_InterUtils::
    ComputeTransitions<TheCurve, TheCurveTool, TheSurface, TheSurfaceTool>(curve,
                                                                           w,
                                                                           TransOnCurve,
                                                                           surface,
                                                                           u,
                                                                           v);
  gp_Pnt                            P(TheCurveTool::Value(curve, w));
  IntCurveSurface_IntersectionPoint IP(P, u, v, w, TransOnCurve);
  Append(IP); //-- invoque la methode de IntCurveSurface_Intersection.
}

//=================================================================================================

void IntCurveSurface_Inter::AppendSegment(const TheCurve&,
                                          const Standard_Real,
                                          const Standard_Real,
                                          const TheSurface&)
{
  // std::cout<<" !!! Not Yet Implemented
  // IntCurveSurface_Inter::Append(const IntCurveSurf ...)"<<std::endl;
}
