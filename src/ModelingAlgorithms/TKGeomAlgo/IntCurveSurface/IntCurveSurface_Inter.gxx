// Created on: 1993-04-09
// Created by: Laurent BUCHARD
// Copyright (c) 1993-1999 Matra Datavision
// Copyright (c) 1999-2014 OPEN CASCADE SAS
//
// This file is part of Open CASCADE Technology software library.
//
// This library is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License version 2.1 as published
// by the Free Software Foundation, with special exception defined in the file
// OCCT_LGPL_EXCEPTION.txt. Consult the file LICENSE_LGPL_21.txt included in OCCT
// distribution for complete text of the license and disclaimer of any warranty.
//
// Alternatively, this file may be used under the terms of Open CASCADE
// commercial license or contractual agreement.

// #ifndef OCCT_DEBUG
// #define No_Standard_RangeError
// #define No_Standard_OutOfRange
// #endif

#define TOLTANGENCY 0.00000001
#define TOLERANCE_ANGULAIRE 1.e-12 // 0.00000001
#define TOLERANCE 0.00000001

#define NBSAMPLESONCIRCLE 32
#define NBSAMPLESONELLIPSE 32
#define NBSAMPLESONPARAB 16
#define NBSAMPLESONHYPR 32

#include <ElSLib.hxx>
#include <Intf_SectionPoint.hxx>
#include <Intf_TangentZone.hxx>
#include <Intf_Tool.hxx>
#include <math_FunctionSetRoot.hxx>
#include <IntCurveSurface_IntersectionPoint.hxx>
#include <IntCurveSurface_IntersectionSegment.hxx>
#include <IntAna_IntConicQuad.hxx>
#include <IntAna_Quadric.hxx>
#include <gp_Vec.hxx>
#include <gp_Dir.hxx>
#include <Precision.hxx>
#include <IntAna_IntLinTorus.hxx>

#include <GeomAbs_Shape.hxx>
#include <GeomAbs_CurveType.hxx>
#include <TColStd_Array1OfReal.hxx>
#include <TColgp_Array1OfPnt.hxx>
#include <gp_Pnt.hxx>
#include <gp_Pln.hxx>
#include <gp_Lin.hxx>
#include <GProp_PEquation.hxx>
#include <GProp_PGProps.hxx>
#include <GProp_PrincipalProps.hxx>
#include <Extrema_ExtElC.hxx>
#include <Extrema_POnCurv.hxx>

#include <ProjLib_Plane.hxx>
#include <IntAna2d_AnaIntersection.hxx>
#include <gp_Lin2d.hxx>
#include <IntAna2d_IntPoint.hxx>
#include <gp_Parab2d.hxx>
#include <IntAna2d_Conic.hxx>
#include <gp_Hypr2d.hxx>
#include <Adaptor3d_Curve.hxx>
#include <Adaptor3d_Surface.hxx>

#include <TColgp_Array2OfPnt.hxx>
#include <TColStd_HArray1OfReal.hxx>
#include <Adaptor3d_TopolTool.hxx>
#include <ElCLib.hxx>

#include "IntCurveSurface_InterUtils.pxx"

//=================================================================================================

IntCurveSurface_Inter::IntCurveSurface_Inter() {}

//=================================================================================================

void IntCurveSurface_Inter::DoSurface(const TheSurface&   surface,
                                      const Standard_Real u0,
                                      const Standard_Real u1,
                                      const Standard_Real v0,
                                      const Standard_Real v1,
                                      TColgp_Array2OfPnt& pntsOnSurface,
                                      Bnd_Box&            boxSurface,
                                      Standard_Real&      gap)
{
  IntCurveSurface_InterUtils::DoSurface<TheSurface, TheSurfaceTool>(surface,
                                                                    u0,
                                                                    u1,
                                                                    v0,
                                                                    v1,
                                                                    pntsOnSurface,
                                                                    boxSurface,
                                                                    gap);
}

//=================================================================================================

void IntCurveSurface_Inter::DoNewBounds(const TheSurface&           surface,
                                        const Standard_Real         u0,
                                        const Standard_Real         u1,
                                        const Standard_Real         v0,
                                        const Standard_Real         v1,
                                        const TColgp_Array2OfPnt&   pntsOnSurface,
                                        const TColStd_Array1OfReal& X,
                                        const TColStd_Array1OfReal& Y,
                                        const TColStd_Array1OfReal& Z,
                                        TColStd_Array1OfReal&       Bounds)
{
  IntCurveSurface_InterUtils::DoNewBounds<TheSurface, TheSurfaceTool>(surface,
                                                                      u0,
                                                                      u1,
                                                                      v0,
                                                                      v1,
                                                                      pntsOnSurface,
                                                                      X,
                                                                      Y,
                                                                      Z,
                                                                      Bounds);
}

//=======================================================================
// function : Perform
// purpose  : Decompose la surface si besoin est
//=======================================================================
void IntCurveSurface_Inter::Perform(const TheCurve& curve, const TheSurface& surface)
{
  ResetFields();
  done                    = Standard_True;
  Standard_Integer NbUOnS = TheSurfaceTool::NbUIntervals(surface, GeomAbs_C2);
  Standard_Integer NbVOnS = TheSurfaceTool::NbVIntervals(surface, GeomAbs_C2);
  Standard_Real    U0, U1, V0, V1;

  if (NbUOnS > 1)
  {
    TColStd_Array1OfReal TabU(1, NbUOnS + 1);
    TheSurfaceTool::UIntervals(surface, TabU, GeomAbs_C2);
    for (Standard_Integer iu = 1; iu <= NbUOnS; iu++)
    {
      U0 = TabU.Value(iu);
      U1 = TabU.Value(iu + 1);
      if (NbVOnS > 1)
      {
        TColStd_Array1OfReal TabV(1, NbVOnS + 1);
        TheSurfaceTool::VIntervals(surface, TabV, GeomAbs_C2);
        for (Standard_Integer iv = 1; iv <= NbVOnS; iv++)
        {
          // More than one interval on U and V param space.
          V0 = TabV.Value(iv);
          V1 = TabV.Value(iv + 1);
          Perform(curve, surface, U0, V0, U1, V1);
        }
      }
      else
      {
        // More than one interval only on U param space.
        V0 = TheSurfaceTool::FirstVParameter(surface);
        V1 = TheSurfaceTool::LastVParameter(surface);
        Perform(curve, surface, U0, V0, U1, V1);
      }
    }
  }
  else if (NbVOnS > 1)
  {
    // More than one interval only on V param space.
    U0 = TheSurfaceTool::FirstUParameter(surface);
    U1 = TheSurfaceTool::LastUParameter(surface);
    TColStd_Array1OfReal TabV(1, NbVOnS + 1);
    TheSurfaceTool::VIntervals(surface, TabV, GeomAbs_C2);
    for (Standard_Integer iv = 1; iv <= NbVOnS; iv++)
    {
      V0 = TabV.Value(iv);
      V1 = TabV.Value(iv + 1);
      Perform(curve, surface, U0, V0, U1, V1);
    }
  }
  else
  {
    // One interval on U and V param space.
    V0 = TheSurfaceTool::FirstVParameter(surface);
    V1 = TheSurfaceTool::LastVParameter(surface);
    U0 = TheSurfaceTool::FirstUParameter(surface);
    U1 = TheSurfaceTool::LastUParameter(surface);

    Perform(curve, surface, U0, V0, U1, V1);
  }
}

//=================================================================================================

void IntCurveSurface_Inter::Perform(const TheCurve&     curve,
                                    const TheSurface&   surface,
                                    const Standard_Real U1,
                                    const Standard_Real V1,
                                    const Standard_Real U2,
                                    const Standard_Real V2)
{
  // Protection from double type overflow.
  // This may happen inside square magnitude computation based on normal,
  // which was computed on bound parameters (bug26525).
  Standard_Real UU1 = U1, UU2 = U2, VV1 = V1, VV2 = V2;
  if (U1 < -1.0e50)
    UU1 = -1.0e50;
  if (U2 > 1.0e50)
    UU2 = 1.0e50;
  if (V1 < -1.0e50)
    VV1 = -1.0e50;
  if (V2 > 1.0e50)
    VV2 = 1.0e50;

  GeomAbs_CurveType CurveType = TheCurveTool::GetType(curve);

  switch (CurveType)
  {
    case GeomAbs_Line: {
      PerformConicSurf(TheCurveTool::Line(curve), curve, surface, UU1, VV1, UU2, VV2);
      break;
    }
    case GeomAbs_Circle: {
      PerformConicSurf(TheCurveTool::Circle(curve), curve, surface, UU1, VV1, UU2, VV2);
      break;
    }
    case GeomAbs_Ellipse: {
      PerformConicSurf(TheCurveTool::Ellipse(curve), curve, surface, UU1, VV1, UU2, VV2);
      break;
    }
    case GeomAbs_Parabola: {
      PerformConicSurf(TheCurveTool::Parabola(curve), curve, surface, UU1, VV1, UU2, VV2);
      break;
    }
    case GeomAbs_Hyperbola: {
      PerformConicSurf(TheCurveTool::Hyperbola(curve), curve, surface, UU1, VV1, UU2, VV2);
      break;
    }
    default: {
      Standard_Integer    nbIntervalsOnCurve = TheCurveTool::NbIntervals(curve, GeomAbs_C2);
      GeomAbs_SurfaceType SurfaceType        = TheSurfaceTool::GetType(surface);
      if ((SurfaceType != GeomAbs_Plane) && (SurfaceType != GeomAbs_Cylinder)
          && (SurfaceType != GeomAbs_Cone) && (SurfaceType != GeomAbs_Sphere))
      {

        if (nbIntervalsOnCurve > 1)
        {
          TColStd_Array1OfReal TabW(1, nbIntervalsOnCurve + 1);
          TheCurveTool::Intervals(curve, TabW, GeomAbs_C2);
          for (Standard_Integer i = 1; i <= nbIntervalsOnCurve; i++)
          {
            Standard_Real u1, u2;
            u1 = TabW.Value(i);
            u2 = TabW.Value(i + 1);

            Handle(TColStd_HArray1OfReal) aPars;
            Standard_Real                 defl  = 0.1;
            Standard_Integer              NbMin = 10;
            TheCurveTool::SamplePars(curve, u1, u2, defl, NbMin, aPars);

            // 	    IntCurveSurface_ThePolygon
            // polygon(curve,u1,u2,TheCurveTool::NbSamples(curve,u1,u2));
            IntCurveSurface_ThePolygon polygon(curve, aPars->Array1());
            InternalPerform(curve, polygon, surface, UU1, VV1, UU2, VV2);
          }
        }
        else
        {
          Standard_Real u1, u2;
          u1 = TheCurveTool::FirstParameter(curve);
          u2 = TheCurveTool::LastParameter(curve);

          Handle(TColStd_HArray1OfReal) aPars;
          Standard_Real                 defl  = 0.1;
          Standard_Integer              NbMin = 10;
          TheCurveTool::SamplePars(curve, u1, u2, defl, NbMin, aPars);

          // 	  IntCurveSurface_ThePolygon polygon(curve,TheCurveTool::NbSamples(curve,u1,u2));
          IntCurveSurface_ThePolygon polygon(curve, aPars->Array1());
          InternalPerform(curve, polygon, surface, UU1, VV1, UU2, VV2);
        }
      }
      else
      { //-- la surface est une quadrique
        InternalPerformCurveQuadric(curve, surface);
      }
    }
  }
}

//=================================================================================================

void IntCurveSurface_Inter::Perform(const TheCurve&                   curve,
                                    const IntCurveSurface_ThePolygon& polygon,
                                    const TheSurface&                 surface)
{
  ResetFields();
  done = Standard_True;
  Standard_Real u1, v1, u2, v2;
  u1 = TheSurfaceTool::FirstUParameter(surface);
  v1 = TheSurfaceTool::FirstVParameter(surface);
  u2 = TheSurfaceTool::LastUParameter(surface);
  v2 = TheSurfaceTool::LastVParameter(surface);
  Standard_Integer nbsu, nbsv;
  nbsu = TheSurfaceTool::NbSamplesU(surface, u1, u2);
  nbsv = TheSurfaceTool::NbSamplesV(surface, v1, v2);
  if (nbsu > 40)
    nbsu = 40;
  if (nbsv > 40)
    nbsv = 40;
  IntCurveSurface_ThePolyhedron polyhedron(surface, nbsu, nbsv, u1, v1, u2, v2);
  Perform(curve, polygon, surface, polyhedron);
}

//=================================================================================================

void IntCurveSurface_Inter::Perform(const TheCurve&                      curve,
                                    const TheSurface&                    surface,
                                    const IntCurveSurface_ThePolyhedron& polyhedron)
{
  ResetFields();
  done                          = Standard_True;
  Standard_Real              u1 = TheCurveTool::FirstParameter(curve);
  Standard_Real              u2 = TheCurveTool::LastParameter(curve);
  IntCurveSurface_ThePolygon polygon(curve, TheCurveTool::NbSamples(curve, u1, u2));
  Perform(curve, polygon, surface, polyhedron);
}

//=================================================================================================

void IntCurveSurface_Inter::Perform(const TheCurve&                      curve,
                                    const IntCurveSurface_ThePolygon&    polygon,
                                    const TheSurface&                    surface,
                                    const IntCurveSurface_ThePolyhedron& polyhedron)
{
  ResetFields();
  done = Standard_True;
  Standard_Real u1, v1, u2, v2;
  u1 = TheSurfaceTool::FirstUParameter(surface);
  v1 = TheSurfaceTool::FirstVParameter(surface);
  u2 = TheSurfaceTool::LastUParameter(surface);
  v2 = TheSurfaceTool::LastVParameter(surface);
  InternalPerform(curve, polygon, surface, polyhedron, u1, v1, u2, v2);
}

//=================================================================================================

void IntCurveSurface_Inter::Perform(const TheCurve&                      curve,
                                    const IntCurveSurface_ThePolygon&    polygon,
                                    const TheSurface&                    surface,
                                    const IntCurveSurface_ThePolyhedron& polyhedron,
                                    Bnd_BoundSortBox&                    BndBSB)
{
  ResetFields();
  done = Standard_True;
  Standard_Real u1, v1, u2, v2;
  u1 = TheSurfaceTool::FirstUParameter(surface);
  v1 = TheSurfaceTool::FirstVParameter(surface);
  u2 = TheSurfaceTool::LastUParameter(surface);
  v2 = TheSurfaceTool::LastVParameter(surface);
  InternalPerform(curve, polygon, surface, polyhedron, u1, v1, u2, v2, BndBSB);
}

//=======================================================================
// function : InternalPerform
// purpose  : C a l c u l   d u   p o i n t   a p p r o c h e
//==              p u i s   d u   p o i n t   E x a c t
//=======================================================================
void IntCurveSurface_Inter::InternalPerform(const TheCurve&                      curve,
                                            const IntCurveSurface_ThePolygon&    polygon,
                                            const TheSurface&                    surface,
                                            const IntCurveSurface_ThePolyhedron& polyhedron,
                                            const Standard_Real                  u0,
                                            const Standard_Real                  v0,
                                            const Standard_Real                  u1,
                                            const Standard_Real                  v1,
                                            Bnd_BoundSortBox&                    BSB)
{
  IntCurveSurface_TheInterference interference(polygon, polyhedron, BSB);
  IntCurveSurface_TheCSFunction   theicsfunction(surface, curve);
  IntCurveSurface_TheExactInter   intersectionExacte(theicsfunction, TOLTANGENCY);
  math_FunctionSetRoot            rsnld(intersectionExacte.Function());

  Standard_Real winf = polygon.InfParameter();
  Standard_Real wsup = polygon.SupParameter();

  IntCurveSurface_InterUtils::SortedStartPoints aStartPoints;
  IntCurveSurface_InterUtils::CollectInterferencePoints<IntCurveSurface_TheInterference,
                                                         IntCurveSurface_ThePolyhedron,
                                                         IntCurveSurface_ThePolygon>(interference,
                                                                                      polyhedron,
                                                                                      polygon,
                                                                                      aStartPoints);
  IntCurveSurface_InterUtils::SortStartPoints(aStartPoints);

  NCollection_Vector<IntCurveSurface_IntersectionPoint> aResultPoints;
  IntCurveSurface_InterUtils::ProcessSortedPoints<IntCurveSurface_TheExactInter,
                                                   TheCurve,
                                                   TheCurveTool,
                                                   TheSurface,
                                                   TheSurfaceTool>(intersectionExacte,
                                                                   rsnld,
                                                                   aStartPoints,
                                                                   u0,
                                                                   u1,
                                                                   v0,
                                                                   v1,
                                                                   winf,
                                                                   wsup,
                                                                   curve,
                                                                   surface,
                                                                   aResultPoints);

  for (const IntCurveSurface_IntersectionPoint& aPoint : aResultPoints)
  {
    Append(aPoint);
  }
}

//=================================================================================================

void IntCurveSurface_Inter::InternalPerform(const TheCurve&                      curve,
                                            const IntCurveSurface_ThePolygon&    polygon,
                                            const TheSurface&                    surface,
                                            const IntCurveSurface_ThePolyhedron& polyhedron,
                                            const Standard_Real                  u0,
                                            const Standard_Real                  v0,
                                            const Standard_Real                  u1,
                                            const Standard_Real                  v1)
{
  IntCurveSurface_TheInterference interference(polygon, polyhedron);
  IntCurveSurface_TheCSFunction   theicsfunction(surface, curve);
  IntCurveSurface_TheExactInter   intersectionExacte(theicsfunction, TOLTANGENCY);
  math_FunctionSetRoot            rsnld(intersectionExacte.Function());

  Standard_Real winf = polygon.InfParameter();
  Standard_Real wsup = polygon.SupParameter();

  IntCurveSurface_InterUtils::SortedStartPoints aStartPoints;
  IntCurveSurface_InterUtils::CollectInterferencePoints<IntCurveSurface_TheInterference,
                                                         IntCurveSurface_ThePolyhedron,
                                                         IntCurveSurface_ThePolygon>(interference,
                                                                                      polyhedron,
                                                                                      polygon,
                                                                                      aStartPoints);
  IntCurveSurface_InterUtils::SortStartPoints(aStartPoints);

  NCollection_Vector<IntCurveSurface_IntersectionPoint> aResultPoints;
  IntCurveSurface_InterUtils::ProcessSortedPoints<IntCurveSurface_TheExactInter,
                                                   TheCurve,
                                                   TheCurveTool,
                                                   TheSurface,
                                                   TheSurfaceTool>(intersectionExacte,
                                                                   rsnld,
                                                                   aStartPoints,
                                                                   u0,
                                                                   u1,
                                                                   v0,
                                                                   v1,
                                                                   winf,
                                                                   wsup,
                                                                   curve,
                                                                   surface,
                                                                   aResultPoints);

  for (const IntCurveSurface_IntersectionPoint& aPoint : aResultPoints)
  {
    Append(aPoint);
  }
}

//=================================================================================================

void IntCurveSurface_Inter::InternalPerformCurveQuadric(const TheCurve&   curve,
                                                        const TheSurface& surface)
{
  NCollection_Vector<IntCurveSurface_IntersectionPoint> aPoints;

  IntCurveSurface_InterUtils::PerformCurveQuadric<IntCurveSurface_TheQuadCurvExactInter,
                                                   TheCurve,
                                                   TheCurveTool,
                                                   TheSurface,
                                                   TheSurfaceTool>(curve, surface, aPoints);

  for (const IntCurveSurface_IntersectionPoint& aPoint : aPoints)
  {
    Append(aPoint);
  }
}

//=================================================================================================

void IntCurveSurface_Inter::InternalPerform(const TheCurve&                   curve,
                                            const IntCurveSurface_ThePolygon& polygon,
                                            const TheSurface&                 surface,
                                            const Standard_Real               U1,
                                            const Standard_Real               V1,
                                            const Standard_Real               U2,
                                            const Standard_Real               V2)
{
  GeomAbs_SurfaceType SurfaceType = TheSurfaceTool::GetType(surface);
  if ((SurfaceType != GeomAbs_Plane) && (SurfaceType != GeomAbs_Cylinder)
      && (SurfaceType != GeomAbs_Cone) && (SurfaceType != GeomAbs_Sphere))
  {
    if (SurfaceType != GeomAbs_BSplineSurface)
    {
      Standard_Integer nbsu, nbsv;
      nbsu = TheSurfaceTool::NbSamplesU(surface, U1, U2);
      nbsv = TheSurfaceTool::NbSamplesV(surface, V1, V2);
      if (nbsu > 40)
        nbsu = 40;
      if (nbsv > 40)
        nbsv = 40;
      IntCurveSurface_ThePolyhedron polyhedron(surface, nbsu, nbsv, U1, V1, U2, V2);
      InternalPerform(curve, polygon, surface, polyhedron, U1, V1, U2, V2);
    }
    else
    {
      Handle(Adaptor3d_Surface) aS         = TheSurfaceTool::UTrim(surface, U1, U2, 1.e-9);
      aS                                   = aS->VTrim(V1, V2, 1.e-9);
      Handle(Adaptor3d_TopolTool) aTopTool = new Adaptor3d_TopolTool(aS);
      Standard_Real               defl     = 0.1;
      aTopTool->SamplePnts(defl, 10, 10);

      Standard_Integer     nbpu = aTopTool->NbSamplesU();
      Standard_Integer     nbpv = aTopTool->NbSamplesV();
      TColStd_Array1OfReal Upars(1, nbpu), Vpars(1, nbpv);
      aTopTool->UParameters(Upars);
      aTopTool->VParameters(Vpars);

      IntCurveSurface_ThePolyhedron polyhedron(surface, Upars, Vpars);
      InternalPerform(curve, polygon, surface, polyhedron, U1, V1, U2, V2);
    }
  }
  else
  {
    NCollection_Vector<IntCurveSurface_IntersectionPoint> aPoints;

    IntCurveSurface_InterUtils::PerformCurveQuadric<IntCurveSurface_TheQuadCurvExactInter,
                                                     TheCurve,
                                                     TheCurveTool,
                                                     TheSurface,
                                                     TheSurfaceTool>(curve, surface, aPoints);

    for (const IntCurveSurface_IntersectionPoint& aPoint : aPoints)
    {
      Append(aPoint);
    }
  } //-- Fin : la Surface  est une quadrique
}

//=================================================================================================

void IntCurveSurface_Inter::PerformConicSurf(const gp_Lin&       Line,
                                             const TheCurve&     curve,
                                             const TheSurface&   surface,
                                             const Standard_Real U1,
                                             const Standard_Real V1,
                                             const Standard_Real U2,
                                             const Standard_Real V2)
{

  GeomAbs_SurfaceType SurfaceType    = TheSurfaceTool::GetType(surface);
  Standard_Boolean    isAnaProcessed = Standard_True;
  switch (SurfaceType)
  {
    case GeomAbs_Plane: {
      IntAna_IntConicQuad LinPlane(Line, TheSurfaceTool::Plane(surface), TOLERANCE_ANGULAIRE);
      AppendIntAna(curve, surface, LinPlane);
      break;
    }
    case GeomAbs_Cylinder: {
      IntAna_IntConicQuad LinCylinder(Line, TheSurfaceTool::Cylinder(surface));
      AppendIntAna(curve, surface, LinCylinder);
      break;
    }
    case GeomAbs_Sphere: {
      IntAna_IntConicQuad LinSphere(Line, TheSurfaceTool::Sphere(surface));
      AppendIntAna(curve, surface, LinSphere);
      break;
    }
    case GeomAbs_Torus: {
      NCollection_Vector<IntCurveSurface_IntersectionPoint> aPoints;
      if (IntCurveSurface_InterUtils::
            ProcessLinTorus<TheCurve, TheCurveTool, TheSurface, TheSurfaceTool>(Line,
                                                                                curve,
                                                                                surface,
                                                                                aPoints))
      {
        for (const IntCurveSurface_IntersectionPoint& aPoint : aPoints)
        {
          Append(aPoint);
        }
      }
      else
        isAnaProcessed = Standard_False;
      break;
    }
    case GeomAbs_Cone: {
      constexpr Standard_Real correction = 1.E+5 * Precision::Angular();
      gp_Cone                 cn         = TheSurfaceTool::Cone(surface);
      if (std::abs(cn.SemiAngle()) < M_PI / 2.0 - correction)
      {
        IntAna_IntConicQuad LinCone(Line, cn);
        AppendIntAna(curve, surface, LinCone);
      }
      else
        isAnaProcessed = Standard_False;
      break;
    }
    default:
      isAnaProcessed = Standard_False;
  }
  if (!isAnaProcessed)
  {
    Standard_Integer nbsu, nbsv;
    nbsu = TheSurfaceTool::NbSamplesU(surface, U1, U2);
    nbsv = TheSurfaceTool::NbSamplesV(surface, V1, V2);

    Standard_Boolean U1inf = Precision::IsInfinite(U1);
    Standard_Boolean U2inf = Precision::IsInfinite(U2);
    Standard_Boolean V1inf = Precision::IsInfinite(V1);
    Standard_Boolean V2inf = Precision::IsInfinite(V2);

    Standard_Real U1new = U1, U2new = U2, V1new = V1, V2new = V2;

    Standard_Boolean NoIntersection = Standard_False;

    if (U1inf || U2inf || V1inf || V2inf)
    {

      if (SurfaceType == GeomAbs_SurfaceOfExtrusion)
      {

        IntCurveSurface_InterUtils::EstLimForInfExtr<TheSurface, TheSurfaceTool>(Line,
                                                                                 surface,
                                                                                 Standard_False,
                                                                                 nbsu,
                                                                                 U1inf,
                                                                                 U2inf,
                                                                                 V1inf,
                                                                                 V2inf,
                                                                                 U1new,
                                                                                 U2new,
                                                                                 V1new,
                                                                                 V2new,
                                                                                 NoIntersection);
      }
      else if (SurfaceType == GeomAbs_SurfaceOfRevolution)
      {

        IntCurveSurface_InterUtils::EstLimForInfRevl<TheSurface, TheSurfaceTool>(Line,
                                                                                 surface,
                                                                                 U1inf,
                                                                                 U2inf,
                                                                                 V1inf,
                                                                                 V2inf,
                                                                                 U1new,
                                                                                 U2new,
                                                                                 V1new,
                                                                                 V2new,
                                                                                 NoIntersection);
      }
      else if (SurfaceType == GeomAbs_OffsetSurface)
      {

        IntCurveSurface_InterUtils::EstLimForInfOffs<TheSurface, TheSurfaceTool>(Line,
                                                                                 surface,
                                                                                 nbsu,
                                                                                 U1inf,
                                                                                 U2inf,
                                                                                 V1inf,
                                                                                 V2inf,
                                                                                 U1new,
                                                                                 U2new,
                                                                                 V1new,
                                                                                 V2new,
                                                                                 NoIntersection);
      }
      else
      {

        IntCurveSurface_InterUtils::EstLimForInfSurf(U1new, U2new, V1new, V2new);
      }
    }

    if (NoIntersection)
      return;

    // modified by NIZHNY-OFV  Mon Aug 20 14:56:47 2001 (60963 begin)
    if (nbsu < 20)
      nbsu = 20;
    if (nbsv < 20)
      nbsv = 20;
    // modified by NIZHNY-OFV  Mon Aug 20 14:57:06 2001 (60963 end)
    IntCurveSurface_ThePolyhedron polyhedron(surface, nbsu, nbsv, U1new, V1new, U2new, V2new);
    Intf_Tool                     bndTool;
    Bnd_Box                       boxLine;
    bndTool.LinBox(Line, polyhedron.Bounding(), boxLine);
    for (Standard_Integer nbseg = 1; nbseg <= bndTool.NbSegments(); nbseg++)
    {
      Standard_Real pinf = bndTool.BeginParam(nbseg);
      Standard_Real psup = bndTool.EndParam(nbseg);
      if ((psup - pinf) < 1e-10)
      {
        pinf -= 1e-10;
        psup += 1e-10;
      }
      IntCurveSurface_ThePolygon polygon(curve, pinf, psup, 2);
      InternalPerform(curve, polygon, surface, polyhedron, U1new, V1new, U2new, V2new);
    }
  }
}

//=================================================================================================

void IntCurveSurface_Inter::PerformConicSurf(const gp_Circ&      Circle,
                                             const TheCurve&     curve,
                                             const TheSurface&   surface,
                                             const Standard_Real U1,
                                             const Standard_Real V1,
                                             const Standard_Real U2,
                                             const Standard_Real V2)
{

  GeomAbs_SurfaceType SurfaceType = TheSurfaceTool::GetType(surface);
  switch (SurfaceType)
  {
    case GeomAbs_Plane: {
      IntAna_IntConicQuad CircPlane(Circle,
                                    TheSurfaceTool::Plane(surface),
                                    TOLERANCE_ANGULAIRE,
                                    TOLERANCE);
      AppendIntAna(curve, surface, CircPlane);
      break;
    }
    case GeomAbs_Cylinder: {
      IntAna_IntConicQuad CircCylinder(Circle, TheSurfaceTool::Cylinder(surface));
      AppendIntAna(curve, surface, CircCylinder);
      break;
    }
    case GeomAbs_Cone: {
      IntAna_IntConicQuad CircCone(Circle, TheSurfaceTool::Cone(surface));
      AppendIntAna(curve, surface, CircCone);
      break;
    }
    case GeomAbs_Sphere: {
      IntAna_IntConicQuad CircSphere(Circle, TheSurfaceTool::Sphere(surface));
      AppendIntAna(curve, surface, CircSphere);
      break;
    }
    default: {
      IntCurveSurface_ThePolygon polygon(curve, NBSAMPLESONCIRCLE);
      InternalPerform(curve, polygon, surface, U1, V1, U2, V2);
    }
  }
}

//=================================================================================================

void IntCurveSurface_Inter::PerformConicSurf(const gp_Elips&     Ellipse,
                                             const TheCurve&     curve,
                                             const TheSurface&   surface,
                                             const Standard_Real U1,
                                             const Standard_Real V1,
                                             const Standard_Real U2,
                                             const Standard_Real V2)
{

  GeomAbs_SurfaceType SurfaceType = TheSurfaceTool::GetType(surface);
  switch (SurfaceType)
  {
    case GeomAbs_Plane: {
      IntAna_IntConicQuad EllipsePlane(Ellipse,
                                       TheSurfaceTool::Plane(surface),
                                       TOLERANCE_ANGULAIRE,
                                       TOLERANCE);
      AppendIntAna(curve, surface, EllipsePlane);
      break;
    }
    case GeomAbs_Cylinder: {
      IntAna_IntConicQuad EllipseCylinder(Ellipse, TheSurfaceTool::Cylinder(surface));
      AppendIntAna(curve, surface, EllipseCylinder);
      break;
    }
    case GeomAbs_Cone: {
      IntAna_IntConicQuad EllipseCone(Ellipse, TheSurfaceTool::Cone(surface));
      AppendIntAna(curve, surface, EllipseCone);
      break;
    }
    case GeomAbs_Sphere: {
      IntAna_IntConicQuad EllipseSphere(Ellipse, TheSurfaceTool::Sphere(surface));
      AppendIntAna(curve, surface, EllipseSphere);
      break;
    }
    default: {
      IntCurveSurface_ThePolygon polygon(curve, NBSAMPLESONELLIPSE);
      InternalPerform(curve, polygon, surface, U1, V1, U2, V2);
    }
  }
}

//=================================================================================================

void IntCurveSurface_Inter::PerformConicSurf(const gp_Parab&     Parab,
                                             const TheCurve&     curve,
                                             const TheSurface&   surface,
                                             const Standard_Real U1,
                                             const Standard_Real V1,
                                             const Standard_Real U2,
                                             const Standard_Real V2)
{

  GeomAbs_SurfaceType SurfaceType = TheSurfaceTool::GetType(surface);
  switch (SurfaceType)
  {
    case GeomAbs_Plane: {
      IntAna_IntConicQuad ParabPlane(Parab, TheSurfaceTool::Plane(surface), TOLERANCE_ANGULAIRE);
      AppendIntAna(curve, surface, ParabPlane);
      break;
    }
    case GeomAbs_Cylinder: {
      IntAna_IntConicQuad ParabCylinder(Parab, TheSurfaceTool::Cylinder(surface));
      AppendIntAna(curve, surface, ParabCylinder);
      break;
    }
    case GeomAbs_Cone: {
      IntAna_IntConicQuad ParabCone(Parab, TheSurfaceTool::Cone(surface));
      AppendIntAna(curve, surface, ParabCone);
      break;
    }
    case GeomAbs_Sphere: {
      IntAna_IntConicQuad ParabSphere(Parab, TheSurfaceTool::Sphere(surface));
      AppendIntAna(curve, surface, ParabSphere);
      break;
    }
    default: {
      Standard_Integer nbsu, nbsv;
      nbsu = TheSurfaceTool::NbSamplesU(surface, U1, U2);
      nbsv = TheSurfaceTool::NbSamplesV(surface, V1, V2);
      if (nbsu > 40)
        nbsu = 40;
      if (nbsv > 40)
        nbsv = 40;
      IntCurveSurface_ThePolyhedron polyhedron(surface, nbsu, nbsv, U1, V1, U2, V2);
      Intf_Tool                     bndTool;
      Bnd_Box                       boxParab;
      bndTool.ParabBox(Parab, polyhedron.Bounding(), boxParab);
      for (Standard_Integer nbseg = 1; nbseg <= bndTool.NbSegments(); nbseg++)
      {
        IntCurveSurface_ThePolygon polygon(curve,
                                           bndTool.BeginParam(nbseg),
                                           bndTool.EndParam(nbseg),
                                           NBSAMPLESONPARAB);
        InternalPerform(curve, polygon, surface, polyhedron, U1, V1, U2, V2);
      }
    }
  }
}

//=================================================================================================

void IntCurveSurface_Inter::PerformConicSurf(const gp_Hypr&      Hypr,
                                             const TheCurve&     curve,
                                             const TheSurface&   surface,
                                             const Standard_Real U1,
                                             const Standard_Real V1,
                                             const Standard_Real U2,
                                             const Standard_Real V2)
{

  GeomAbs_SurfaceType SurfaceType = TheSurfaceTool::GetType(surface);
  switch (SurfaceType)
  {
    case GeomAbs_Plane: {
      IntAna_IntConicQuad HyprPlane(Hypr, TheSurfaceTool::Plane(surface), TOLERANCE_ANGULAIRE);
      AppendIntAna(curve, surface, HyprPlane);
      break;
    }
    case GeomAbs_Cylinder: {
      IntAna_IntConicQuad HyprCylinder(Hypr, TheSurfaceTool::Cylinder(surface));
      AppendIntAna(curve, surface, HyprCylinder);
      break;
    }
    case GeomAbs_Cone: {
      IntAna_IntConicQuad HyprCone(Hypr, TheSurfaceTool::Cone(surface));
      AppendIntAna(curve, surface, HyprCone);
      break;
    }
    case GeomAbs_Sphere: {
      IntAna_IntConicQuad HyprSphere(Hypr, TheSurfaceTool::Sphere(surface));
      AppendIntAna(curve, surface, HyprSphere);
      break;
    }
    default: {
      Standard_Integer nbsu, nbsv;
      nbsu = TheSurfaceTool::NbSamplesU(surface, U1, U2);
      nbsv = TheSurfaceTool::NbSamplesV(surface, V1, V2);
      if (nbsu > 40)
        nbsu = 40;
      if (nbsv > 40)
        nbsv = 40;
      IntCurveSurface_ThePolyhedron polyhedron(surface, nbsu, nbsv, U1, V1, U2, V2);
      Intf_Tool                     bndTool;
      Bnd_Box                       boxHypr;
      bndTool.HyprBox(Hypr, polyhedron.Bounding(), boxHypr);
      for (Standard_Integer nbseg = 1; nbseg <= bndTool.NbSegments(); nbseg++)
      {
        IntCurveSurface_ThePolygon polygon(curve,
                                           bndTool.BeginParam(nbseg),
                                           bndTool.EndParam(nbseg),
                                           NBSAMPLESONHYPR);
        InternalPerform(curve, polygon, surface, polyhedron, U1, V1, U2, V2);
      }
    }
  }
}

//=================================================================================================

void IntCurveSurface_Inter::AppendIntAna(const TheCurve&            curve,
                                         const TheSurface&          surface,
                                         const IntAna_IntConicQuad& intana_ConicQuad)
{
  Standard_Boolean                                       aIsParallel = Standard_False;
  NCollection_Vector<IntCurveSurface_IntersectionPoint>  aPoints;

  if (IntCurveSurface_InterUtils::
        ProcessIntAna<TheCurve, TheCurveTool, TheSurface, TheSurfaceTool>(curve,
                                                                          surface,
                                                                          intana_ConicQuad,
                                                                          aIsParallel,
                                                                          aPoints))
  {
    if (aIsParallel)
    {
      myIsParallel = Standard_True;
    }
    else
    {
      for (const IntCurveSurface_IntersectionPoint& aPoint : aPoints)
      {
        Append(aPoint);
      }
    }
  }
}

//=================================================================================================

void IntCurveSurface_Inter::AppendPoint(const TheCurve&     curve,
                                        const Standard_Real lw,
                                        const TheSurface&   surface,
                                        const Standard_Real su,
                                        const Standard_Real sv)
{
  IntCurveSurface_IntersectionPoint aPoint;
  if (IntCurveSurface_InterUtils::
        ComputeAppendPoint<TheCurve, TheCurveTool, TheSurface, TheSurfaceTool>(curve,
                                                                               lw,
                                                                               surface,
                                                                               su,
                                                                               sv,
                                                                               aPoint))
  {
    Append(aPoint);
  }
}

//=================================================================================================

void IntCurveSurface_Inter::AppendSegment(const TheCurve&,
                                          const Standard_Real,
                                          const Standard_Real,
                                          const TheSurface&)
{
  // std::cout<<" !!! Not Yet Implemented
  // IntCurveSurface_Inter::Append(const IntCurveSurf ...)"<<std::endl;
}
