// Copyright (c) 1993-1999 Matra Datavision
// Copyright (c) 1999-2014 OPEN CASCADE SAS
//
// This file is part of Open CASCADE Technology software library.
//
// This library is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License version 2.1 as published
// by the Free Software Foundation, with special exception defined in the file
// OCCT_LGPL_EXCEPTION.txt. Consult the file LICENSE_LGPL_21.txt included in OCCT
// distribution for complete text of the license and disclaimer of any warranty.
//
// Alternatively, this file may be used under the terms of Open CASCADE
// commercial license or contractual agreement.

#ifndef IntCurveSurface_QuadricCurveExactInterUtils_HeaderFile
#define IntCurveSurface_QuadricCurveExactInterUtils_HeaderFile

#include <GeomAbs_SurfaceType.hxx>
#include <IntSurf_Quadric.hxx>
#include <TColStd_Array1OfReal.hxx>
#include <TColStd_SequenceOfReal.hxx>
#include <math_FunctionAllRoots.hxx>
#include <math_FunctionSample.hxx>

namespace IntCurveSurface_QuadricCurveExactInterUtils
{

//! Tolerance values for root finding
constexpr double EPSX    = 0.00000000000001;
constexpr double EPSDIST = 0.00000001;
constexpr double EPSNUL  = 0.00000001;

//! Performs intersection of a curve with a quadric surface.
//! @tparam SurfaceType The surface type (Handle(Adaptor3d_Surface) or Standard_Address)
//! @tparam SurfaceTool The surface tool class
//! @tparam CurveType The curve type (Handle(Adaptor3d_Curve) or gp_Lin)
//! @tparam CurveTool The curve tool class
//! @tparam QuadCurvFuncType The quadric curve function class
//! @param theSurface [in] The quadric surface
//! @param theCurve [in] The curve to intersect
//! @param thePnts [out] Sequence of intersection parameter values (roots)
//! @param theIntv [out] Sequence of interval boundaries (pairs of start/end)
//! @param theNbPnts [out] Number of intersection points (-1 if failed)
//! @param theNbIntv [out] Number of intersection intervals (-1 if failed)
template <typename SurfaceType,
          typename SurfaceTool,
          typename CurveType,
          typename CurveTool,
          typename QuadCurvFuncType>
void PerformIntersection(const SurfaceType&      theSurface,
                         const CurveType&        theCurve,
                         TColStd_SequenceOfReal& thePnts,
                         TColStd_SequenceOfReal& theIntv,
                         int&                    theNbPnts,
                         int&                    theNbIntv)
{
  theNbPnts = -1;
  theNbIntv = -1;

  GeomAbs_SurfaceType aQuadricType = SurfaceTool::GetType(theSurface);
  IntSurf_Quadric     aQuadric;

  switch (aQuadricType)
  {
    case GeomAbs_Plane: {
      aQuadric.SetValue(SurfaceTool::Plane(theSurface));
      break;
    }
    case GeomAbs_Cylinder: {
      aQuadric.SetValue(SurfaceTool::Cylinder(theSurface));
      break;
    }
    case GeomAbs_Cone: {
      aQuadric.SetValue(SurfaceTool::Cone(theSurface));
      break;
    }
    case GeomAbs_Sphere: {
      aQuadric.SetValue(SurfaceTool::Sphere(theSurface));
      break;
    }
    default: {
      break;
    }
  }

  int                  aNbIntervals = CurveTool::NbIntervals(theCurve, GeomAbs_C1);
  TColStd_Array1OfReal anIntervals(1, aNbIntervals + 1);
  int                  ii;

  CurveTool::Intervals(theCurve, anIntervals, GeomAbs_C1);

  for (ii = 1; ii <= aNbIntervals; ii++)
  {
    double U1 = anIntervals.Value(ii);
    double U2 = anIntervals.Value(ii + 1);

    math_FunctionSample aSample(U1, U2, CurveTool::NbSamples(theCurve, U1, U2));
    QuadCurvFuncType    aFunction(aQuadric, theCurve);
    math_FunctionAllRoots aRoots(aFunction, aSample, EPSX, EPSDIST, EPSNUL);

    if (aRoots.IsDone())
    {
      int aNbPoints    = aRoots.NbPoints();
      int aNbRootIntv = aRoots.NbIntervals();

      for (int i = 1; i <= aNbPoints; i++)
      {
        thePnts.Append(aRoots.GetPoint(i));
      }

      double a, b;
      for (int i = 1; i <= aNbRootIntv; i++)
      {
        aRoots.GetInterval(i, a, b);
        theIntv.Append(a);
        theIntv.Append(b);
      }
    }
    else
    {
      break;
    }
  }

  if (ii > aNbIntervals)
  {
    theNbPnts = thePnts.Length();
    theNbIntv = theIntv.Length() / 2;
  }
}

} // namespace IntCurveSurface_QuadricCurveExactInterUtils

#endif // IntCurveSurface_QuadricCurveExactInterUtils_HeaderFile
