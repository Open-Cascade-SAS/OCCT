// Copyright (c) 2025 OPEN CASCADE SAS
//
// This file is part of Open CASCADE Technology software library.
//
// This library is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License version 2.1 as published
// by the Free Software Foundation, with special exception defined in the file
// OCCT_LGPL_EXCEPTION.txt. Consult the file LICENSE_LGPL_21.txt included in OCCT
// distribution for complete text of the license and disclaimer of any warranty.
//
// Alternatively, this file may be used under the terms of Open CASCADE
// commercial license or contractual agreement.

#ifndef IntCurveSurface_PolyhedronUtils_pxx_HeaderFile
#define IntCurveSurface_PolyhedronUtils_pxx_HeaderFile

#include <Adaptor3d_Surface.hxx>
#include <Bnd_Box.hxx>
#include <GeomGridEval_Surface.hxx>
#include <gp.hxx>
#include <gp_Pnt.hxx>
#include <gp_Vec.hxx>
#include <gp_XYZ.hxx>
#include <NCollection_Array1.hxx>
#include <NCollection_Array2.hxx>
#include <NCollection_HArray1.hxx>
#include <Standard_Real.hxx>

//! Utility functions for polyhedron discretization of surfaces.
//! These template functions implement the core logic previously in IntCurveSurface_Polyhedron.gxx.
namespace IntCurveSurface_PolyhedronUtils
{

//! Minimum edge length for valid triangles.
constexpr double THE_MIN_EDGE_LENGTH_SQUARED = 1e-15;

//! Initialize polyhedron with uniform UV sampling using grid evaluator.
//! @param[in,out] theEval          Grid evaluator (must be initialized with surface)
//! @param[in]     theU0            First U parameter
//! @param[in]     theV0            First V parameter
//! @param[in]     theU1            Last U parameter
//! @param[in]     theV1            Last V parameter
//! @param[in]     theNbDeltaU      Number of U subdivisions
//! @param[in]     theNbDeltaV      Number of V subdivisions
//! @param[out]    thePnts          Array of sampled points (1-based indexing)
//! @param[out]    theU             Array of U parameters (1-based indexing)
//! @param[out]    theV             Array of V parameters (1-based indexing)
//! @param[out]    theIsOnBounds    Array of boundary flags (1-based indexing)
//! @param[in,out] theBnd           Bounding box to update
inline void InitUniform(GeomGridEval_Surface& theEval,
                        const double          theU0,
                        const double          theV0,
                        const double          theU1,
                        const double          theV1,
                        const int             theNbDeltaU,
                        const int             theNbDeltaV,
                        gp_Pnt*               thePnts,
                        double*               theU,
                        double*               theV,
                        bool*                 theIsOnBounds,
                        Bnd_Box&              theBnd)
{
  const double dU = (theU1 - theU0) / static_cast<double>(theNbDeltaU);
  const double dV = (theV1 - theV0) / static_cast<double>(theNbDeltaV);

  // Build parameter arrays
  const int aNbU = theNbDeltaU + 1;
  const int aNbV = theNbDeltaV + 1;

  NCollection_Array1<double> aUParams(1, aNbU);
  NCollection_Array1<double> aVParams(1, aNbV);

  for (int i = 0; i < aNbU; ++i)
  {
    aUParams(i + 1) = theU0 + i * dU;
  }
  for (int j = 0; j < aNbV; ++j)
  {
    aVParams(j + 1) = theV0 + j * dV;
  }

  // Evaluate grid
  const NCollection_Array2<gp_Pnt> aGrid = theEval.EvaluateGrid(aUParams, aVParams);

  // Copy results to output arrays (convert from 2D grid to 1D linear indexing)
  int Index = 1;
  for (int i1 = 0; i1 < aNbU; ++i1)
  {
    for (int i2 = 0; i2 < aNbV; ++i2)
    {
      const gp_Pnt& TP     = aGrid(i1 + 1, i2 + 1);
      thePnts[Index]       = TP;
      theU[Index]          = aUParams(i1 + 1);
      theV[Index]          = aVParams(i2 + 1);
      theIsOnBounds[Index] = (i1 == 0 || i1 == theNbDeltaU || i2 == 0 || i2 == theNbDeltaV);
      theBnd.Add(TP);
      ++Index;
    }
  }
}

//! Initialize polyhedron with explicit UV parameter arrays using grid evaluator.
//! @param[in,out] theEval          Grid evaluator (must be initialized with surface)
//! @param[in]     theUpars         Array of U parameters
//! @param[in]     theVpars         Array of V parameters
//! @param[in]     theNbDeltaU      Number of U subdivisions
//! @param[in]     theNbDeltaV      Number of V subdivisions
//! @param[out]    thePnts          Array of sampled points (1-based indexing)
//! @param[out]    theU             Array of U parameters (1-based indexing)
//! @param[out]    theV             Array of V parameters (1-based indexing)
//! @param[out]    theIsOnBounds    Array of boundary flags (1-based indexing)
//! @param[in,out] theBnd           Bounding box to update
inline void InitWithParams(GeomGridEval_Surface&             theEval,
                           const NCollection_Array1<double>& theUpars,
                           const NCollection_Array1<double>& theVpars,
                           const int                         theNbDeltaU,
                           const int                         theNbDeltaV,
                           gp_Pnt*                           thePnts,
                           double*                           theU,
                           double*                           theV,
                           bool*                             theIsOnBounds,
                           Bnd_Box&                          theBnd)
{
  // Evaluate grid using provided parameters
  const NCollection_Array2<gp_Pnt> aGrid = theEval.EvaluateGrid(theUpars, theVpars);

  const int i0    = theUpars.Lower();
  const int j0    = theVpars.Lower();
  int       Index = 1;

  for (int i1 = 0; i1 <= theNbDeltaU; ++i1)
  {
    for (int i2 = 0; i2 <= theNbDeltaV; ++i2)
    {
      const gp_Pnt& TP     = aGrid(i1 + 1, i2 + 1);
      thePnts[Index]       = TP;
      theU[Index]          = theUpars(i1 + i0);
      theV[Index]          = theVpars(i2 + j0);
      theIsOnBounds[Index] = (i1 == 0 || i1 == theNbDeltaU || i2 == 0 || i2 == theNbDeltaV);
      theBnd.Add(TP);
      ++Index;
    }
  }
}

//! Compute border deflection for a boundary isoline using grid evaluation.
//! Uses batch evaluation for better performance on complex surfaces.
//! @param[in,out] theEval      Grid evaluator (will be reused for isoline evaluation)
//! @param[in]     theParameter Fixed parameter value (U or V depending on isUIso)
//! @param[in]     thePMin      Start of varying parameter range
//! @param[in]     thePMax      End of varying parameter range
//! @param[in]     theIsUIso    True if this is a U-isoline, false for V-isoline
//! @param[in]     theNbSamples Number of samples along the boundary
//! @return Maximum deflection along the border
inline double ComputeBorderDeflection(GeomGridEval_Surface& theEval,
                                      const double          theParameter,
                                      const double          thePMin,
                                      const double          thePMax,
                                      const bool            theIsUIso,
                                      const int             theNbSamples)
{
  // Build parameter array with both boundary points and midpoints
  // For N segments: boundary points at i*delta, midpoints at (i+0.5)*delta
  // Total: 2*N + 1 points (N+1 boundaries + N midpoints, interleaved)
  const double aDelta  = (thePMax - thePMin) / theNbSamples;
  const int    aNbPnts = 2 * theNbSamples + 1;

  NCollection_Array1<double> aVaryingParams(1, aNbPnts);
  NCollection_Array1<double> aFixedParams(1, 1);
  aFixedParams(1) = theParameter;

  // Fill varying parameters: alternating boundary and midpoint values
  // Index 1, 3, 5, ... (odd) = boundary points (0, delta, 2*delta, ...)
  // Index 2, 4, 6, ... (even) = midpoints (delta/2, 3*delta/2, ...)
  for (int i = 0; i <= theNbSamples; ++i)
  {
    aVaryingParams(2 * i + 1) = thePMin + i * aDelta;
    if (i < theNbSamples)
    {
      aVaryingParams(2 * i + 2) = thePMin + (i + 0.5) * aDelta;
    }
  }

  // Evaluate grid: 1xN or Nx1 depending on isoline direction
  const NCollection_Array2<gp_Pnt> aGrid = theIsUIso
                                             ? theEval.EvaluateGrid(aFixedParams, aVaryingParams)
                                             : theEval.EvaluateGrid(aVaryingParams, aFixedParams);

  // Compute max deflection from pre-evaluated points
  double aDeflection = RealFirst();

  for (int i = 0; i < theNbSamples; ++i)
  {
    // Boundary points at indices 2*i+1 and 2*i+3 (1-based)
    // Midpoint at index 2*i+2 (1-based)
    gp_XYZ aP1, aP2, aPParMid;

    if (theIsUIso)
    {
      aP1      = aGrid(1, 2 * i + 1).XYZ();
      aP2      = aGrid(1, 2 * i + 3).XYZ();
      aPParMid = aGrid(1, 2 * i + 2).XYZ();
    }
    else
    {
      aP1      = aGrid(2 * i + 1, 1).XYZ();
      aP2      = aGrid(2 * i + 3, 1).XYZ();
      aPParMid = aGrid(2 * i + 2, 1).XYZ();
    }

    const gp_XYZ aPMid = (aP2 + aP1) / 2.0;
    const double aDist = (aPMid - aPParMid).Modulus();

    if (aDist > aDeflection)
      aDeflection = aDist;
  }

  return aDeflection;
}

//! Compute the number of triangles in the polyhedron.
//! @param[in] theNbDeltaU Number of U subdivisions
//! @param[in] theNbDeltaV Number of V subdivisions
//! @return Number of triangles (2 * nbdeltaU * nbdeltaV)
inline int NbTriangles(const int theNbDeltaU, const int theNbDeltaV)
{
  return theNbDeltaU * theNbDeltaV * 2;
}

//! Compute the number of points in the polyhedron.
//! @param[in] theNbDeltaU Number of U subdivisions
//! @param[in] theNbDeltaV Number of V subdivisions
//! @return Number of points ((nbdeltaU + 1) * (nbdeltaV + 1))
inline int NbPoints(const int theNbDeltaU, const int theNbDeltaV)
{
  return (theNbDeltaU + 1) * (theNbDeltaV + 1);
}

//! Get the three vertex indices of a triangle.
//! @param[in]  theIndex    Triangle index (1-based)
//! @param[out] theP1       First vertex index
//! @param[out] theP2       Second vertex index
//! @param[out] theP3       Third vertex index
//! @param[in]  theNbDeltaV Number of V subdivisions
inline void Triangle(const int theIndex, int& theP1, int& theP2, int& theP3, const int theNbDeltaV)
{
  const int line   = 1 + ((theIndex - 1) / (theNbDeltaV * 2));
  const int colon  = 1 + ((theIndex - 1) % (theNbDeltaV * 2));
  const int colpnt = (colon + 1) / 2;

  theP1 = (line - 1) * (theNbDeltaV + 1) + colpnt;
  theP2 = line * (theNbDeltaV + 1) + colpnt + ((colon - 1) % 2);
  theP3 = (line - 1 + (colon % 2)) * (theNbDeltaV + 1) + colpnt + 1;
}

//! Navigate to a connected triangle given a pivot point and edge point.
//! This function computes triangle connectivity for mesh traversal.
//! @param[in]  theTriang   Current triangle index (0 if unknown)
//! @param[in]  thePivot    Pivot point index
//! @param[in]  thePedge    Edge point index (0 if unknown)
//! @param[out] theTriCon   Connected triangle index (0 if on boundary)
//! @param[out] theOtherP   The other point of the connected triangle
//! @param[in]  theNbDeltaU Number of U subdivisions
//! @param[in]  theNbDeltaV Number of V subdivisions
//! @return Connected triangle index
inline int TriConnex(const int theTriang,
                     const int thePivot,
                     const int thePedge,
                     int&      theTriCon,
                     int&      theOtherP,
                     const int theNbDeltaU,
                     const int theNbDeltaV)
{
  const int Pivotm1    = thePivot - 1;
  const int nbdeltaVp1 = theNbDeltaV + 1;
  const int nbdeltaVm2 = theNbDeltaV + theNbDeltaV;

  const int ligP = Pivotm1 / nbdeltaVp1;
  const int colP = Pivotm1 - ligP * nbdeltaVp1;

  int ligE = 0, colE = 0, typE = 0;
  if (thePedge != 0)
  {
    ligE = (thePedge - 1) / nbdeltaVp1;
    colE = (thePedge - 1) - (ligE * nbdeltaVp1);
    if (ligP == ligE)
      typE = 1;
    else if (colP == colE)
      typE = 2;
    else
      typE = 3;
  }

  int linT = 0, colT = 0;
  int linO = 0, colO = 0;
  int t = 0, tt = 0;

  if (theTriang != 0)
  {
    t    = (theTriang - 1) / nbdeltaVm2;
    tt   = (theTriang - 1) - t * nbdeltaVm2;
    linT = 1 + t;
    colT = 1 + tt;
    if (typE == 0)
    {
      if (ligP == linT)
      {
        ligE = ligP - 1;
        colE = colP - 1;
        typE = 3;
      }
      else
      {
        if (colT == ligP + ligP)
        {
          ligE = ligP;
          colE = colP - 1;
          typE = 1;
        }
        else
        {
          ligE = ligP + 1;
          colE = colP + 1;
          typE = 3;
        }
      }
    }
    switch (typE)
    {
      case 1:
        if (linT == ligP)
        {
          linT++;
          linO = ligP + 1;
          colO = (colP > colE) ? colP : colE;
        }
        else
        {
          linT--;
          linO = ligP - 1;
          colO = (colP < colE) ? colP : colE;
        }
        break;
      case 2:
        if (colT == (colP + colP))
        {
          colT++;
          linO = (ligP > ligE) ? ligP : ligE;
          colO = colP + 1;
        }
        else
        {
          colT--;
          linO = (ligP < ligE) ? ligP : ligE;
          colO = colP - 1;
        }
        break;
      case 3:
        if ((colT & 1) == 0)
        {
          colT--;
          linO = (ligP > ligE) ? ligP : ligE;
          colO = (colP < colE) ? colP : colE;
        }
        else
        {
          colT++;
          linO = (ligP < ligE) ? ligP : ligE;
          colO = (colP > colE) ? colP : colE;
        }
        break;
    }
  }
  else
  {
    if (thePedge == 0)
    {
      linT = (1 > ligP) ? 1 : ligP;
      colT = (1 > (colP + colP)) ? 1 : (colP + colP);
      if (ligP == 0)
        linO = ligP + 1;
      else
        linO = ligP - 1;
      colO = colP;
    }
    else
    {
      switch (typE)
      {
        case 1:
          linT = ligP + 1;
          colT = (colP > colE) ? colP : colE;
          colT += colT;
          linO = ligP + 1;
          colO = (colP > colE) ? colP : colE;
          break;
        case 2:
          linT = (ligP > ligE) ? ligP : ligE;
          colT = colP + colP;
          linO = (ligP < ligE) ? ligP : ligE;
          colO = colP - 1;
          break;
        case 3:
          linT = (ligP > ligE) ? ligP : ligE;
          colT = colP + colE;
          linO = (ligP > ligE) ? ligP : ligE;
          colO = (colP < colE) ? colP : colE;
          break;
      }
    }
  }

  theTriCon = (linT - 1) * nbdeltaVm2 + colT;

  if (linT < 1)
  {
    linO = 0;
    colO = colP + colP - colE;
    if (colO < 0)
    {
      colO = 0;
      linO = 1;
    }
    else if (colO > theNbDeltaV)
    {
      colO = theNbDeltaV;
      linO = 1;
    }
    theTriCon = 0;
  }
  else if (linT > theNbDeltaU)
  {
    linO = theNbDeltaU;
    colO = colP + colP - colE;
    if (colO < 0)
    {
      colO = 0;
      linO = theNbDeltaU - 1;
    }
    else if (colO > theNbDeltaV)
    {
      colO = theNbDeltaV;
      linO = theNbDeltaU - 1;
    }
    theTriCon = 0;
  }

  if (colT < 1)
  {
    colO = 0;
    linO = ligP + ligP - ligE;
    if (linO < 0)
    {
      linO = 0;
      colO = 1;
    }
    else if (linO > theNbDeltaU)
    {
      linO = theNbDeltaU;
      colO = 1;
    }
    theTriCon = 0;
  }
  else if (colT > theNbDeltaV)
  {
    colO = theNbDeltaV;
    linO = ligP + ligP - ligE;
    if (linO < 0)
    {
      linO = 0;
      colO = theNbDeltaV - 1;
    }
    else if (linO > theNbDeltaU)
    {
      linO = theNbDeltaU;
      colO = theNbDeltaV - 1;
    }
    theTriCon = 0;
  }

  theOtherP = linO * nbdeltaVp1 + colO + 1;

  return theTriCon;
}

//! Compute the plane equation of a triangle.
//! @param[in]  theP1            First vertex point
//! @param[in]  theP2            Second vertex point
//! @param[in]  theP3            Third vertex point
//! @param[out] theNormalVector  Normal vector of the plane
//! @param[out] thePolarDistance Distance from origin to plane along normal
inline void PlaneEquation(const gp_Pnt& theP1,
                          const gp_Pnt& theP2,
                          const gp_Pnt& theP3,
                          gp_XYZ&       theNormalVector,
                          double&       thePolarDistance)
{
  const gp_XYZ v1 = theP2.XYZ() - theP1.XYZ();
  const gp_XYZ v2 = theP3.XYZ() - theP2.XYZ();
  const gp_XYZ v3 = theP1.XYZ() - theP3.XYZ();

  if (v1.SquareModulus() <= THE_MIN_EDGE_LENGTH_SQUARED)
  {
    theNormalVector.SetCoord(1.0, 0.0, 0.0);
    return;
  }
  if (v2.SquareModulus() <= THE_MIN_EDGE_LENGTH_SQUARED)
  {
    theNormalVector.SetCoord(1.0, 0.0, 0.0);
    return;
  }
  if (v3.SquareModulus() <= THE_MIN_EDGE_LENGTH_SQUARED)
  {
    theNormalVector.SetCoord(1.0, 0.0, 0.0);
    return;
  }

  theNormalVector       = (v1 ^ v2) + (v2 ^ v3) + (v3 ^ v1);
  const double aNormLen = theNormalVector.Modulus();
  if (aNormLen < gp::Resolution())
  {
    thePolarDistance = 0.0;
  }
  else
  {
    theNormalVector.Divide(aNormLen);
    thePolarDistance = theNormalVector * theP1.XYZ();
  }
}

//! Check if a point is contained within a triangle.
//! @param[in] theP1     First vertex point
//! @param[in] theP2     Second vertex point
//! @param[in] theP3     Third vertex point
//! @param[in] theTestPnt Point to test
//! @return True if point is inside triangle
inline bool Contain(const gp_Pnt& theP1,
                    const gp_Pnt& theP2,
                    const gp_Pnt& theP3,
                    const gp_Pnt& theTestPnt)
{
  const gp_XYZ v1 = (theP2.XYZ() - theP1.XYZ()) ^ (theTestPnt.XYZ() - theP1.XYZ());
  const gp_XYZ v2 = (theP3.XYZ() - theP2.XYZ()) ^ (theTestPnt.XYZ() - theP2.XYZ());
  const gp_XYZ v3 = (theP1.XYZ() - theP3.XYZ()) ^ (theTestPnt.XYZ() - theP3.XYZ());

  return (v1 * v2 >= 0.0 && v2 * v3 >= 0.0 && v3 * v1 >= 0.0);
}

//! Fill bounding boxes for all triangles in the polyhedron.
//! @param[in]     thePnts              Array of points
//! @param[in]     theNbDeltaU          Number of U subdivisions
//! @param[in]     theNbDeltaV          Number of V subdivisions
//! @param[in]     theDeflection        Deflection value for enlarging boxes
//! @param[in,out] theComponentsBnd     Array of bounding boxes to fill
inline void FillBounding(const gp_Pnt*                                    thePnts,
                         const int                                        theNbDeltaU,
                         const int                                        theNbDeltaV,
                         const double                                     theDeflection,
                         const occ::handle<NCollection_HArray1<Bnd_Box>>& theComponentsBnd)
{
  Bnd_Box   Boite;
  int       np1, np2, np3;
  const int nbtriangles = NbTriangles(theNbDeltaU, theNbDeltaV);

  for (int iTri = 1; iTri <= nbtriangles; ++iTri)
  {
    Triangle(iTri, np1, np2, np3, theNbDeltaV);
    const gp_Pnt& p1 = thePnts[np1];
    const gp_Pnt& p2 = thePnts[np2];
    const gp_Pnt& p3 = thePnts[np3];
    Boite.SetVoid();
    if (p1.SquareDistance(p2) > THE_MIN_EDGE_LENGTH_SQUARED)
    {
      if (p1.SquareDistance(p3) > THE_MIN_EDGE_LENGTH_SQUARED)
      {
        if (p2.SquareDistance(p3) > THE_MIN_EDGE_LENGTH_SQUARED)
        {
          Boite.Add(p1);
          Boite.Add(p2);
          Boite.Add(p3);
          Boite.Enlarge(theDeflection);
        }
      }
    }
    Boite.Enlarge(theDeflection);
    theComponentsBnd->SetValue(iTri, Boite);
  }
}

//! Compute deflection for a single triangle given a pre-evaluated center point.
//! @param[in] theP1       First vertex
//! @param[in] theP2       Second vertex
//! @param[in] theP3       Third vertex
//! @param[in] theCenter   Pre-evaluated center point on surface
//! @return Deflection value (distance from triangle center to surface)
inline double ComputeDeflectionWithCenter(const gp_Pnt& theP1,
                                          const gp_Pnt& theP2,
                                          const gp_Pnt& theP3,
                                          const gp_Pnt& theCenter)
{
  // Check for degenerate triangles
  if (theP1.SquareDistance(theP2) <= THE_MIN_EDGE_LENGTH_SQUARED)
    return 0.0;
  if (theP1.SquareDistance(theP3) <= THE_MIN_EDGE_LENGTH_SQUARED)
    return 0.0;
  if (theP2.SquareDistance(theP3) <= THE_MIN_EDGE_LENGTH_SQUARED)
    return 0.0;

  // Compute normal vector
  const gp_XYZ XYZ1 = theP2.XYZ() - theP1.XYZ();
  const gp_XYZ XYZ2 = theP3.XYZ() - theP2.XYZ();
  const gp_XYZ XYZ3 = theP1.XYZ() - theP3.XYZ();
  gp_Vec       NormalVector((XYZ1 ^ XYZ2) + (XYZ2 ^ XYZ3) + (XYZ3 ^ XYZ1));

  const double aNormLen = NormalVector.Magnitude();
  if (aNormLen < gp::Resolution())
    return 0.0;

  NormalVector.Divide(aNormLen);

  // Compute distance from center to triangle plane
  const gp_Vec P1P(theP1, theCenter);
  return std::abs(P1P.Dot(NormalVector));
}

//! Compute the maximum deflection over all triangles.
//! Evaluates triangle centroids individually using the surface adaptor.
//! @tparam PolyhedronType Type of polyhedron class
//! @param[in] theSurface     Surface adaptor for point evaluation
//! @param[in] thePolyhedron  The polyhedron object (provides Triangle/Point access)
//! @param[in] theNbTriangles Number of triangles
//! @return Maximum deflection value
template <typename PolyhedronType>
double ComputeMaxDeflection(const Adaptor3d_Surface& theSurface,
                            const PolyhedronType&    thePolyhedron,
                            const int                theNbTriangles)
{
  if (theNbTriangles <= 0)
    return 0.0;

  double tol = 0.0;
  for (int i = 1; i <= theNbTriangles; ++i)
  {
    int i1, i2, i3;
    thePolyhedron.Triangle(i, i1, i2, i3);

    double       u1, v1, u2, v2, u3, v3;
    const gp_Pnt P1 = thePolyhedron.Point(i1, u1, v1);
    const gp_Pnt P2 = thePolyhedron.Point(i2, u2, v2);
    const gp_Pnt P3 = thePolyhedron.Point(i3, u3, v3);

    const double uCenter = (u1 + u2 + u3) / 3.0;
    const double vCenter = (v1 + v2 + v3) / 3.0;

    gp_Pnt aCenter;
    theSurface.D0(uCenter, vCenter, aCenter);

    const double tol1 = ComputeDeflectionWithCenter(P1, P2, P3, aCenter);
    if (tol1 > tol)
      tol = tol1;
  }
  return tol;
}

//! Compute the maximum border deflection over all four boundaries using grid evaluation.
//! @param[in,out] theEval     Grid evaluator (will be reused for each boundary)
//! @param[in]     theU0       First U parameter
//! @param[in]     theV0       First V parameter
//! @param[in]     theU1       Last U parameter
//! @param[in]     theV1       Last V parameter
//! @param[in]     theNbDeltaU Number of U subdivisions
//! @param[in]     theNbDeltaV Number of V subdivisions
//! @return Maximum border deflection
inline double ComputeMaxBorderDeflection(GeomGridEval_Surface& theEval,
                                         const double          theU0,
                                         const double          theV0,
                                         const double          theU1,
                                         const double          theV1,
                                         const int             theNbDeltaU,
                                         const int             theNbDeltaV)
{
  double maxDeflection = RealFirst();

  // Lower bound (U-isoline at U=U0, V varies from V0 to V1)
  double aDeflection = ComputeBorderDeflection(theEval, theU0, theV0, theV1, true, theNbDeltaV);
  if (aDeflection > maxDeflection)
    maxDeflection = aDeflection;

  // Upper bound (U-isoline at U=U1, V varies from V0 to V1)
  aDeflection = ComputeBorderDeflection(theEval, theU1, theV0, theV1, true, theNbDeltaV);
  if (aDeflection > maxDeflection)
    maxDeflection = aDeflection;

  // Lower bound (V-isoline at V=V0, U varies from U0 to U1)
  aDeflection = ComputeBorderDeflection(theEval, theV0, theU0, theU1, false, theNbDeltaU);
  if (aDeflection > maxDeflection)
    maxDeflection = aDeflection;

  // Upper bound (V-isoline at V=V1, U varies from U0 to U1)
  aDeflection = ComputeBorderDeflection(theEval, theV1, theU0, theU1, false, theNbDeltaU);
  if (aDeflection > maxDeflection)
    maxDeflection = aDeflection;

  return maxDeflection;
}

//! Check if an edge between two points lies on the boundary.
//! @param[in] theIndex1      First point index
//! @param[in] theIndex2      Second point index
//! @param[in] theIsOnBounds  Array of boundary flags
//! @param[in] theNbDeltaU    Number of U subdivisions
//! @param[in] theNbDeltaV    Number of V subdivisions
//! @return True if edge is on boundary
inline bool IsOnBound(const int   theIndex1,
                      const int   theIndex2,
                      const bool* theIsOnBounds,
                      const int   theNbDeltaU,
                      const int   theNbDeltaV)
{
  const int aDiff = std::abs(theIndex1 - theIndex2);

  if (aDiff != 1 && aDiff != theNbDeltaV + 1)
    return false;

  for (int i = 0; i <= theNbDeltaU; ++i)
  {
    if ((theIndex1 == 1 + i * (theNbDeltaV + 1)) && (theIndex2 == theIndex1 - 1))
      return false;

    if ((theIndex1 == (1 + i) * (theNbDeltaV + 1)) && (theIndex2 == theIndex1 + 1))
      return false;
  }

  return (theIsOnBounds[theIndex1] && theIsOnBounds[theIndex2]);
}

//! Deallocate polyhedron arrays.
//! @param[in,out] thePnts        Points array to delete and nullify
//! @param[in,out] theU           U parameters array to delete and nullify
//! @param[in,out] theV           V parameters array to delete and nullify
//! @param[in,out] theIsOnBounds  Boundary flags array to delete and nullify
inline void Destroy(void*& thePnts, void*& theU, void*& theV, void*& theIsOnBounds)
{
  if (thePnts)
    delete[] static_cast<gp_Pnt*>(thePnts);
  if (theU)
    delete[] static_cast<double*>(theU);
  if (theV)
    delete[] static_cast<double*>(theV);
  if (theIsOnBounds)
    delete[] static_cast<bool*>(theIsOnBounds);
  thePnts = theU = theV = theIsOnBounds = NULL;
}

//! Allocate polyhedron arrays.
//! @param[in]  theNbDeltaU    Number of U subdivisions
//! @param[in]  theNbDeltaV    Number of V subdivisions
//! @param[out] thePnts        Points array
//! @param[out] theU           U parameters array
//! @param[out] theV           V parameters array
//! @param[out] theIsOnBounds  Boundary flags array
inline void AllocateArrays(const int theNbDeltaU,
                           const int theNbDeltaV,
                           void*&    thePnts,
                           void*&    theU,
                           void*&    theV,
                           void*&    theIsOnBounds)
{
  const int t   = (theNbDeltaU + 1) * (theNbDeltaV + 1) + 1;
  thePnts       = new gp_Pnt[t];
  theU          = new double[t];
  theV          = new double[t];
  theIsOnBounds = new bool[t];
}

//! Set deflection over-estimation with minimum threshold.
//! @param[in]     theFlec       Deflection value
//! @param[out]    theDeflection Stored deflection value
//! @param[in,out] theBnd        Bounding box to enlarge
inline void SetDeflectionOverEstimation(const double theFlec,
                                        double&      theDeflection,
                                        Bnd_Box&     theBnd)
{
  constexpr double THE_MIN_DEFLECTION = 0.0001;
  if (theFlec < THE_MIN_DEFLECTION)
  {
    theDeflection = THE_MIN_DEFLECTION;
    theBnd.Enlarge(THE_MIN_DEFLECTION);
  }
  else
  {
    theDeflection = theFlec;
    theBnd.Enlarge(theFlec);
  }
}

//! Get UV parameters at point index.
//! @param[in]  theIndex Index of the point
//! @param[in]  theU     U parameters array
//! @param[in]  theV     V parameters array
//! @param[out] theOutU  Output U parameter
//! @param[out] theOutV  Output V parameter
inline void Parameters(const int   theIndex,
                       void* const theU,
                       void* const theV,
                       double&     theOutU,
                       double&     theOutV)
{
  const double* aU = static_cast<const double*>(theU);
  const double* aV = static_cast<const double*>(theV);
  theOutU          = aU[theIndex];
  theOutV          = aV[theIndex];
}

//! Get point with UV parameters.
//! @param[in]  theIndex Index of the point
//! @param[in]  thePnts  Points array
//! @param[in]  theU     U parameters array
//! @param[in]  theV     V parameters array
//! @param[out] theOutU  Output U parameter
//! @param[out] theOutV  Output V parameter
//! @return Reference to the point
inline const gp_Pnt& Point(const int   theIndex,
                           void* const thePnts,
                           void* const theU,
                           void* const theV,
                           double&     theOutU,
                           double&     theOutV)
{
  const gp_Pnt* aPnts = static_cast<const gp_Pnt*>(thePnts);
  const double* aU    = static_cast<const double*>(theU);
  const double* aV    = static_cast<const double*>(theV);
  theOutU             = aU[theIndex];
  theOutV             = aV[theIndex];
  return aPnts[theIndex];
}

//! Get point by index.
//! @param[in] theIndex Index of the point
//! @param[in] thePnts  Points array
//! @return Reference to the point
inline const gp_Pnt& Point(const int theIndex, void* const thePnts)
{
  const gp_Pnt* aPnts = static_cast<const gp_Pnt*>(thePnts);
  return aPnts[theIndex];
}

//! Get point by index (output parameter version).
//! @param[in]  theIndex Index of the point
//! @param[in]  thePnts  Points array
//! @param[out] thePoint Output point
inline void Point(const int theIndex, void* const thePnts, gp_Pnt& thePoint)
{
  const gp_Pnt* aPnts = static_cast<const gp_Pnt*>(thePnts);
  thePoint            = aPnts[theIndex];
}

} // namespace IntCurveSurface_PolyhedronUtils

#endif // IntCurveSurface_PolyhedronUtils_pxx_HeaderFile
