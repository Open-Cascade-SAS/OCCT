// Copyright (c) 1998-1999 Matra Datavision
// Copyright (c) 1999-2014 OPEN CASCADE SAS
//
// This file is part of Open CASCADE Technology software library.
//
// This library is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License version 2.1 as published
// by the Free Software Foundation, with special exception defined in the file
// OCCT_LGPL_EXCEPTION.txt. Consult the file LICENSE_LGPL_21.txt included in OCCT
// distribution for complete text of the license and disclaimer of any warranty.
//
// Alternatively, this file may be used under the terms of Open CASCADE
// commercial license or contractual agreement.

// #include <LibCtl_Library.ixx>
#include <Standard_NoSuchObject.hxx>

//  Global List of Modules, from which we will be served

static Handle(LibCtl_GlobalNode) theglobal;

//  Data for optimization (last Protocol requested)

static Handle(TheProtocol) theprotocol;
static Handle(LibCtl_Node) thelast;

//  Feeding the global list
//  WARNING: SetGlobal performs substitution, i.e. it's the last one
//   that is right for a given Protocol
void LibCtl_Library::SetGlobal(const Handle(TheModule)&   amodule,
                               const Handle(TheProtocol)& aprotocol)
{
  if (theglobal.IsNull())
    theglobal = new LibCtl_GlobalNode;
  theglobal->Add(amodule, aprotocol);
}

// Constructor from Protocol
LibCtl_Library::LibCtl_Library(const Handle(TheProtocol)& aprotocol)
{
  Standard_Boolean last = Standard_False;
  if (aprotocol.IsNull())
    return; // NO protocol = EMPTY Lib
  if (!theprotocol.IsNull())
    last = (theprotocol == aprotocol);

  if (last)
    thelist = thelast;
  //  If no optimization available: build the list
  else
  {
    AddProtocol(aprotocol);
    //  This defines the optimization (for the next time)
    thelast     = thelist;
    theprotocol = aprotocol;
  }
}

//  Constructeur vide
LibCtl_Library::LibCtl_Library() {}

//  Adding a Protocol: beware, deoptimizes (otherwise risk of confusion!)
void LibCtl_Library::AddProtocol(const Handle(Standard_Transient)& aprotocol)
{
  //  DownCast because Protocol->Resources, even redefined and used in other
  //  libraries, must always return the highest type
  Handle(TheProtocol) aproto = Handle(TheProtocol)::DownCast(aprotocol);
  if (aproto.IsNull())
    return;

  //  First, add this one to the list: search for the Node
  Handle(LibCtl_GlobalNode) curr;
  for (curr = theglobal; !curr.IsNull();)
  { // curr->Next : plus loin
    const Handle(TheProtocol)& protocol = curr->Protocol();
    if (!protocol.IsNull())
    {
      //  Match Protocol ?
      if (protocol->DynamicType() == aprotocol->DynamicType())
      {
        if (thelist.IsNull())
          thelist = new LibCtl_Node;
        thelist->AddNode(curr);
        break; // UN SEUL MODULE PAR PROTOCOLE
      }
    }
    curr = curr->Next(); // this formula is refused in "for"
  }
  //  Then, process the resources
  Standard_Integer nb = aproto->NbResources();
  for (Standard_Integer i = 1; i <= nb; i++)
  {
    AddProtocol(aproto->Resource(i));
  }
  //  Don't forget to deoptimize
  theprotocol.Nullify();
  thelast.Nullify();
}

void LibCtl_Library::Clear()
{
  thelist = new LibCtl_Node;
}

void LibCtl_Library::SetComplete()
{
  thelist = new LibCtl_Node;
  //    We take each of the Protocols from the Global List and add it
  Handle(LibCtl_GlobalNode) curr;
  for (curr = theglobal; !curr.IsNull();)
  { // curr->Next : plus loin
    const Handle(TheProtocol)& protocol = curr->Protocol();
    //    Since we take everything, we don't worry about Resources!
    if (!protocol.IsNull())
      thelist->AddNode(curr);
    curr = curr->Next(); // this formula is refused in "for"
  }
}

//  Selection: Very powerful, we return the Module corresponding to a Type
//  (as well as the CaseNumber returned by the corresponding protocol)

Standard_Boolean LibCtl_Library::Select(const TheObject&   obj,
                                        Handle(TheModule)& module,
                                        Standard_Integer&  CN) const
{
  module.Nullify();
  CN = 0; // Response "not found"
  if (thelist.IsNull())
    return Standard_False;
  Handle(LibCtl_Node) curr = thelist;
  for (curr = thelist; !curr.IsNull();)
  { // curr->Next : plus loin
    const Handle(TheProtocol)& protocol = curr->Protocol();
    if (!protocol.IsNull())
    {
      CN = protocol->CaseNumber(obj);
      if (CN > 0)
      {
        module = curr->Module();
        return Standard_True;
      }
    }
    curr = curr->Next(); // this formula is refused in "for"
  }
  return Standard_False; // here, not found
}

//  ....                        Iteration                        ....

void LibCtl_Library::Start()
{
  thecurr = thelist;
}

Standard_Boolean LibCtl_Library::More() const
{
  return (!thecurr.IsNull());
}

void LibCtl_Library::Next()
{
  if (!thecurr.IsNull())
    thecurr = thecurr->Next();
}

const Handle(TheModule)& LibCtl_Library::Module() const
{
  if (thecurr.IsNull())
    throw Standard_NoSuchObject("Library from LibCtl");
  return thecurr->Module();
}

const Handle(TheProtocol)& LibCtl_Library::Protocol() const
{
  if (thecurr.IsNull())
    throw Standard_NoSuchObject("Library from LibCtl");
  return thecurr->Protocol();
}
